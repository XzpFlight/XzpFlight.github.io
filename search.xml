<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>串联网络各大协议</title>
      <link href="/2023/12/28/Major-protocols-for-serial-networks/"/>
      <url>/2023/12/28/Major-protocols-for-serial-networks/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>天各一方的两台计算机是如何通信的呢？在成千上万的计算机中，为什么一台计算机能够准确着寻找到另外一台计算机，并且把数据发送给它呢？<br>可能很多人都听说过网络通信的5层模型，但是可能并不是很清楚为什么需要五层模型，五层模型负责的任务也有可能经常混淆。下面是网络通信的五层模型</p><p><img src="http://sc1goen2r.hn-bkt.clouddn.com/23122801.jpg"></p><h3 id="1-物理层"><a href="#1-物理层" class="headerlink" title="1-物理层"></a>1-物理层</h3><p>一台计算机与另一台计算机要进行通信，第一件要做的事是什么？当然是要把这台计算机与另外的其他计算机连起来啊，这样，我们才能把数据传输过去。例如可以通过光纤啊，电缆啊，双绞线啊等介质把他们连接起来，然后才能进行通信。</p><p><img src="http://sc1goen2r.hn-bkt.clouddn.com/23122802.jpg"></p><p>也就是说，物理层负责把两台计算机连起来，然后在计算机之间通过高低电频来传送0,1这样的电信号。</p><h3 id="2-数据链路层"><a href="#2-数据链路层" class="headerlink" title="2-数据链路层"></a>2-数据链路层</h3><p>前面说了，物理层它只是单纯着负责把计算机连接起来，并且在计算机之间传输0,1这样的电信号。如果这些0,1组合的传送毫无规则的话，计算机是解读不了的。一大堆0,1谁知道是什么鬼啊。</p><p><img src="http://sc1goen2r.hn-bkt.clouddn.com/23122803.jpg"></p><p>因此，我们需要制定一套规则来进行0,1的传送。例如多少个电信号为一组啊，每一组信号应该如何标识才能让计算机读懂啊等等。<br>于是，有了以太网协议。</p><h4 id="2-1-以太网协议"><a href="#2-1-以太网协议" class="headerlink" title="2-1-以太网协议"></a>2-1-以太网协议</h4><p>以太网协议规定，一组电信号构成一个数据包，我们把这个数据包称之为<code>帧</code>。每一个桢由标头（ Head ）和数据（ Data ）两部分组成。</p><p><img src="http://sc1goen2r.hn-bkt.clouddn.com/23122804.jpg"></p><p>帧的大小一般为64-1518个字节。假如需要传送的数据很大的话，就分成多个桢来进行传送。<br>对于表头和数据这两个部分，他们存放的都是一些什么数据呢？我猜你眯着眼睛都能想到他们应该放什么数据。毫无疑问，我们至少得知道这个桢是谁发送，发送给谁的等这些信息吧？所以标头部分主要是一些说明数据，例如发送者，接收者等信息。而数据部分则是这个数据包具体的，想给接收者的内容。<br>大家想一个问题，一个桢的长度是64~1518个字节，也就是说桢的长度不是固定的，那你觉得标头部分的字节长度是固定的吗？它当然是固定的啊，假如不是固定的，每个桢都是单独发的，那计算机怎么知道标头是几个字节，数据是几个字节呢。所以标头部分的字节是固定的，并且固定为18个字节。<br>把一台计算的的数据通过物理层和链路层发送给另一台计算机，究竟是谁发给谁的，计算机与计算机之间如何区分，，你总得给他们一个唯一的标识吧？<br>于是， MAC 地址出现了。</p><h4 id="2-2-MAC地址"><a href="#2-2-MAC地址" class="headerlink" title="2-2-MAC地址"></a>2-2-MAC地址</h4><p>连入网络的每一个计算机都会有网卡接口，每一个网卡都会有一个唯一的地址，这个地址就叫做 MAC 地址。计算机之间的数据传送，就是通过 MAC 地址来唯一寻找、传送的。</p><p><img src="http://sc1goen2r.hn-bkt.clouddn.com/23122805.jpg"></p><p>MAC 地址由48个二进制位所构成，在网卡生产时就被唯一标识了。</p><h4 id="2-3-广播与-ARP-协议"><a href="#2-3-广播与-ARP-协议" class="headerlink" title="2-3-广播与 ARP 协议"></a>2-3-广播与 ARP 协议</h4><h5 id="2-3-1-广播"><a href="#2-3-1-广播" class="headerlink" title="2-3-1-广播"></a>2-3-1-广播</h5><p><img src="http://sc1goen2r.hn-bkt.clouddn.com/23122806.jpg"></p><p>如图，假如计算机 A 知道了计算机 B 的 MAC 地址，然后计算机 A 想要给计算机 B 传送数据，虽然计算机 A 知道了计算机 B 的 MAC 地址，可是它要怎么给它传送数据呢？计算机 A 不仅连着计算机 B ，而且计算机 A 也还连着其他的计算机。虽然计算机 A 知道计算机 B 的 MAC 地址，可是计算机 A 却不知道知道计算机 B 是分布在哪边路线上，为了解决这个问题，于是，有了<code>广播</code>的出现。<br>在同一个<code>子网</code>中，计算机 A 要向计算机 B 发送一个数据包，这个数据包会包含接收者的 MAC 地址。当发送时，计算机 A 是通过<code>广播</code>的方式发送的，这时同一个子网中的计算机 C , D 也会收到这个数据包的，然后收到这个数据包的计算机，会把数据包的 MAC 地址取出来，与自身的 MAC 地址对比，如果两者相同，则接受这个数据包，否则就丢弃这个数据包。这种发送方式我们称之为广播，就像我们平时在广场上通过广播的形式呼叫某个人一样，如果这个名字是你，你就理会一下，如果不是你，你就当作听不见。</p><h5 id="2-3-2-ARP-协议。"><a href="#2-3-2-ARP-协议。" class="headerlink" title="2-3-2-ARP 协议。"></a>2-3-2-ARP 协议。</h5><p>那么问题来了，计算机 A 是如何知道计算机 B的 MAC 地址的呢？这个时候就得由 ARP 协议这个家伙来解决了，不过 ARP 协议会涉及到 IP 地址，我们下面才会扯到 IP 地址。因此我们先放着，就当作是有这么一个 ARP 协议，通过它我们可以知道子网中其他计算机的 MAC 地址。</p><h3 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3-网络层"></a>3-网络层</h3><p>上面我们有说到子网这个关键词，实际上我们所处的网络，是由无数个子网络构成的。广播的时候，也只有同一个子网里面的计算机能够收到。<br>假如没有子网这种划分的话，计算机 A 通过广播的方式发一个数据包给计算机 B ，其他所有计算机也都能收到这个数据包，然后进行对比再舍弃。世界上有那么多它计算机，每一台计算机都能收到其他所有计算机的数据包，那就不得了了。那还不得奔溃。因此产生了<code>子网</code>这么一个东西。<br>那么问题来了，我们如何区分哪些 MAC 地址是属于同一个子网的呢？假如是同一个子网，那我们就用广播的形式把数据传送给对方，如果不是同一个子网的，我们就会把数据发给网关，让网关进行转发。<br>为了解决这个问题，于是，有了 IP 协议。</p><h4 id="3-1-IP协议"><a href="#3-1-IP协议" class="headerlink" title="3-1-IP协议"></a>3-1-IP协议</h4><p> IP 协议，它所定义的地址，我们称之为 <code>IP 地址</code>。 IP 协议有两种版本，一种是IPv4，另一种是IPv6。不过我们目前大多数用的还是IPv4，我们现在也只讨论IPv4这个版本的协议。<br>这个 IP 地址由32位的二进制数组成，我们一般把它分成4段的十进制表示，地址范围为<code>0.0.0.0~255.255.255.255</code>。<br>每一台想要联网的计算机都会有一个 IP 地址。这个 IP 地址被分为两部分，前面一部分代表<code>网络部分</code>，后面一部分代表<code>主机部分</code>。并且网络部分和主机部分所占用的二进制位数是不固定的。<br>假如两台计算机的网络部分是一模一样的，我们就说这两台计算机是处于同一个子网中。例如<code>192.168.43.1</code>和<code>192.168.43.2</code>，假如这两个 IP 地址的网络部分为24位，主机部分为8位。那么他们的网络部分都为<code>192.168.43</code>，所以他们处于同一个子网中。<br>可是问题来了，你怎么知道网络部分是占几位，主机部分又是占几位呢？也就是说，单单从两台计算机的 IP 地址，我们是无法判断他们的是否处于同一个子网中的。<br>这就引申出了另一个关键词﹣–﹣<code>子网掩码</code>。子网掩码和 IP 地址一样也是32位二进制数，不过它的网络部分规定全部为1，主机部分规定全部为0．也就是说，假如上面那两个 IP 地址的网络部分为24位，主机部分为8位的话，那他们的子网掩码都为<code>11111111.11111111.11111111.00000000</code>即<code>255.255.255.0</code>。</p><p><img src="http://sc1goen2r.hn-bkt.clouddn.com/23122807.jpg"></p><p>那有了子网掩码，如何来判端 IP 地址是否处于同一个子网中呢。显然，知道了子网掩码，相当于我们知道了网络部分是几位，主机部分是几位。我们只需要把 IP 地址与它的子网掩码做与（ <code>and</code> ）运算，然后把各自的结果进行比较就行了，如果比较的结果相同，则代表是同一个子网，否则不是同一个子网。<br>例如，<code>192.168.43.1</code>和<code>192.168.43.2</code>的子码掩码都为<code>255.255.255.0</code>，把 IP 与子码掩码相与，可以得到他们都为<code>192.168.43.0</code>，进而他们处于同一个子网中。</p><h4 id="3-2-ARP协议"><a href="#3-2-ARP协议" class="headerlink" title="3-2-ARP协议"></a>3-2-ARP协议</h4><p>有了上面 IP 协议的知识，我们回来讲一下 ARP 协议。<br>有了两台计算机的 IP 地址与子网掩码，我们就可以判断出它们是否处于同一个子网之中了。<br>假如他们处于同一个子网之中，计算机 A 要给计算机 B 发送数据时。我们可以通过 ARP 协议来得到计算机 B 的 MAC 地址。<br> ARP 协议也是通过广播的形式给同一个子网中的每台电脑发送一个数据包（当然，这个数据包会包含接收方的 IP 地址）。对方收到这个数据包之后，会取出 IP 地址与自身的对比，如果相同，则把自己的 MAC 地址回复给对方，否则就丢弃这个数据包。这样，计算机 A 就能知道计算机 B 的 MAC 地址了。</p><p><img src="http://sc1goen2r.hn-bkt.clouddn.com/23122808.jpg"></p><p>可能有人会问，知道了 MAC 地址之后，发送数据是通过广播的形式发送，询问对方的 MAC 地址也是通过广播的形式来发送，那其他计算机怎么知道你是要传送数据还是要询问 MAC 地址呢？其实在询问 MAC 地址的数据包中，在对方的 MAC 地址这一栏中，填的是一个特殊的 MAC 地址，其他计算机看到这个特殊的 MAC 地址之后，就能知道广播想干嘛了。<br>假如两台计算机的 IP 不是处于同一个子网之中，这个时候，我们就会把数据包发送给网关，然后让网关让我们进行转发传送。</p><h4 id="3-3-DNS服务器"><a href="#3-3-DNS服务器" class="headerlink" title="3-3-DNS服务器"></a>3-3-DNS服务器</h4><p>这里再说一个问题，我们是如何知道对方计算机的 IP 地址的呢？这个问题可能有人会觉得很白痴，心想，当然是计算机的操作者来进行输入了。这没错，当我们想要访问某个网站的时候，我们可以输入 IP 来进行访问，但是我相信绝大多数人是输入一个网址域名的，例如访问百度是输入<a href="http://www.baidu.com这个域名.其实当我们输入这个域名时,会有一个叫做dns服务器的家伙来帮我们解析这个域名,然后返回这个域名对应的/">www.baidu.com这个域名。其实当我们输入这个域名时，会有一个叫做DNS服务器的家伙来帮我们解析这个域名，然后返回这个域名对应的</a> IP 给我们的。<br><strong>因此，网络层的功能就是让我们在茫茫人海中，能够找到另一台计算机在哪里，是否属于同一个子网等。</strong></p><h3 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4-传输层"></a>4-传输层</h3><p>通过物理层、数据链路层以及网络层的互相帮助，我们已经把数据成功从计算机 A 传送到计算机 B 了，可是，计算机 B 里面有各种各样的应用程序，计算机该如何知道这些数据是给谁的呢？<br>这个时候，**端口( <code>Port</code> )**这个家伙就上场了，也就是说，我们在从计算机 A 传数据给计算表 B 的时候，还得指定一个端口，以供特定的应用程序来接受处理。<br>也就是说，传输层的功能就是建立端口到端口的通信。相比网络层的功能是建立主机到主机的通信。<br>也就是说，只有有了 IP 和端口，我们才能进行准确着通信。这个时候可能有人会说，我输入 IP 地址的时候并没有指定一个端口啊。其实呢，对于有些传输协议，已经有设定了一些默认端口了。例如 http 的传输默认端口是80，这些端口信息也会包含在数据包里的。<br>传输层最常见的两大协议是 TCP 协议和 UDP 协议，其中 TCP 协议与 UDP 最大的不同就是 TCP 提供可靠的传输，而 UDP 提供的是不可靠传输。</p><h3 id="5-应用层"><a href="#5-应用层" class="headerlink" title="5-应用层"></a>5-应用层</h3><p>终于说到应用层了，应用层这一层最接近我们用户了。<br>虽然我们收到了传输层传来的数据，可是这些传过来的数据五花八门，有 html 格式的，有mp4格式的，各种各样。你确定你能看的懂？<br>因此我们需要指定这些数据的格式规则，收到后才好解读渲染。例如我们最常见的 Http 数据包中，就会指定该数据包是什么格式的文件了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>五层模型至此讲到这里。对于有些层讲的比较简洁，就随便概况了一下。我们下篇博客见~</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data structure algorithm program for trees (3)</title>
      <link href="/2023/10/10/Data-structure-algorithm-program-for-trees-3/"/>
      <url>/2023/10/10/Data-structure-algorithm-program-for-trees-3/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>篇接上文，继续栽树！</p><h2 id="JZ54-二叉搜索树的第k个节点"><a href="#JZ54-二叉搜索树的第k个节点" class="headerlink" title="JZ54 二叉搜索树的第k个节点"></a>JZ54 二叉搜索树的第k个节点</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一棵结点数为n 二叉搜索树，请找出其中的第 k 小的TreeNode结点值。<br>1.返回第k小的节点值即可<br>2.不能查找的情况，如二叉树为空，则返回-1，或者k大于n等等，也返回-1<br>3.保证n个节点的值不一样</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">KthNode</span><span class="params">(TreeNode* proot, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (proot == <span class="literal">nullptr</span> || k == <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="comment">// 如果根节点为空或k为0，则返回-1表示无效</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        stack&lt;TreeNode*&gt; stack;  <span class="comment">// 创建一个栈来辅助遍历二叉树</span></span><br><span class="line">        TreeNode* cur = proot;  <span class="comment">// 当前节点指针指向根节点</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;  <span class="comment">// 计数器，用于记录已经访问过的节点数量</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span> || !stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 当前节点不为空或栈不为空时循环</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="comment">// 将当前节点及其左子节点依次压入栈，直到当前节点为空</span></span><br><span class="line">                stack.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            cur = stack.<span class="built_in">top</span>();  <span class="comment">// 弹出栈顶元素作为当前节点</span></span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">            count++;  <span class="comment">// 计数器加1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (k == count) &#123;</span><br><span class="line">                <span class="comment">// 如果k等于计数器，说明当前节点是第k小的节点，返回其值</span></span><br><span class="line">                <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            cur = cur-&gt;right;  <span class="comment">// 更新当前节点为其右子节点，继续下一轮循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 遍历完成仍然没有找到第k小的节点，返回-1表示无效</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度"><a href="#算法思路-amp-步骤-amp-时空复杂度" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>这段代码实现了在二叉搜索树中找到第k小的节点值的功能。</p><ol><li>首先判断根节点 <code>proot</code> 是否为空或者 <code>k</code> 是否为0。如果是，则返回 -1 表示无效。</li><li>创建一个栈 <code>stack</code> 用于辅助遍历二叉树。</li><li>初始化当前节点指针 <code>cur</code> 为根节点 <code>proot</code>。</li><li>初始化计数器 <code>count</code> 为0，用于记录已经访问过的节点数量。</li><li>进入循环，条件是当前节点 <code>cur</code> 不为空或者栈不为空。</li><li>在循环中，首先将当前节点及其左子节点依次压入栈，直到当前节点为空。</li><li>弹出栈顶元素作为当前节点 <code>cur</code>，并将计数器 <code>count</code> 加1。</li><li>如果 <code>k</code> 等于 <code>count</code>，说明当前节点是第k小的节点，返回其值 <code>cur-&gt;val</code>。</li><li>将 <code>cur</code> 更新为其右子节点，继续下一轮循环。</li><li>如果遍历完成仍然没有找到第k小的节点，返回 -1 表示无效。</li></ol><h2 id="JZ33-二叉搜索树的后序遍历序列"><a href="#JZ33-二叉搜索树的后序遍历序列" class="headerlink" title="JZ33 二叉搜索树的后序遍历序列"></a>JZ33 二叉搜索树的后序遍历序列</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回 true ,否则返回 false 。假设输入的数组的任意两个数字都互不相同。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">recursion</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; sequence, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义递归函数，判断给定序列在[left, right]范围内是否是一个合法的二叉搜索树的后序遍历结果</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="comment">// 如果左边界大于等于右边界，说明当前范围只有一个节点或没有节点，返回true表示有效</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="type">int</span> root = sequence[right];  <span class="comment">// 取最右边的元素作为根节点</span></span><br><span class="line">        <span class="keyword">for</span> (j = right; j &gt;= left; j--) &#123;</span><br><span class="line">            <span class="type">int</span> cur = sequence[j];</span><br><span class="line">            <span class="keyword">if</span> (cur &lt; root) &#123;</span><br><span class="line">                <span class="comment">// 从右往左遍历序列，找到第一个小于根节点值的元素，记为j</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = j; i &gt;= left; i--) &#123;</span><br><span class="line">            <span class="type">int</span> cur = sequence[i];</span><br><span class="line">            <span class="keyword">if</span> (cur &gt; root) &#123;</span><br><span class="line">                <span class="comment">// 从j开始往左遍历序列，如果出现大于根节点值的元素，返回false表示无效</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用递归函数判断左子树部分[left, j]是否是合法的后序遍历结果，以及右子树部分[j+1, right-1]是否是合法的后序遍历结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recursion</span>(sequence, left, j) &amp;&amp; <span class="built_in">recursion</span>(sequence, j + <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果序列为空，返回false表示无效</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recursion</span>(sequence, <span class="number">0</span>, sequence.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 调用递归函数判断整个序列是否是一个合法的二叉搜索树的后序遍历结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-1"><a href="#算法思路-amp-步骤-amp-时空复杂度-1" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>这段代码实现了判断一个序列是否是二叉搜索树的后序遍历结果。</p><p>算法思路如下：</p><ol><li>首先判断序列的长度，如果为空，则返回false表示无效。</li><li>调用递归函数<code>recursion</code>，传入序列、左边界<code>left</code>和右边界<code>right</code>（初始为整个序列范围）。</li><li>在递归函数中，首先判断如果左边界大于等于右边界，说明当前范围只有一个节点或没有节点，返回true表示有效。</li><li>取最右边的元素作为根节点<code>root</code>。</li><li>从右往左遍历序列，找到第一个小于根节点值的元素，记为<code>j</code>。</li><li>从<code>j</code>开始往左遍历序列，如果出现大于根节点值的元素，返回false表示无效。</li><li>调用递归函数判断左子树部分<code>[left, j]</code>是否是合法的后序遍历结果，以及右子树部分<code>[j+1, right-1]</code>是否是合法的后序遍历结果。</li><li>如果左子树和右子树都是合法的后序遍历结果，返回true表示有效；否则，返回false表示无效。</li></ol><h2 id="JZ36-二叉搜索树与双向链表"><a href="#JZ36-二叉搜索树与双向链表" class="headerlink" title="JZ36 二叉搜索树与双向链表"></a>JZ36 二叉搜索树与双向链表</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。<br>注意:<br>1.要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继<br>2.返回链表中的第一个节点的指针<br>3.函数返回的TreeNode，有左右指针，其实可以看成一个双向链表的数据结构<br>4.你不用输出双向链表，程序会根据你的返回值自动打印输出</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRootOfTree == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;  <span class="comment">// 如果根节点为空，则返回空指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* head = <span class="literal">nullptr</span>;  <span class="comment">// 定义链表头指针为nullptr</span></span><br><span class="line">        TreeNode* pre = head;  <span class="comment">// 定义双向链表中当前节点的前一个节点为nullptr</span></span><br><span class="line">        <span class="type">bool</span> isfirst = <span class="literal">true</span>;  <span class="comment">// 定义布尔变量，用于标记是否是链表的第一个节点</span></span><br><span class="line">        stack&lt;TreeNode*&gt; stack;  <span class="comment">// 定义栈，用于辅助进行中序遍历</span></span><br><span class="line">        <span class="keyword">while</span> (pRootOfTree != <span class="literal">nullptr</span> || !stack.<span class="built_in">empty</span>()) &#123;  <span class="comment">// 当前节点不为nullptr或者栈不为空时循环</span></span><br><span class="line">            <span class="keyword">while</span> (pRootOfTree != <span class="literal">nullptr</span>) &#123;  <span class="comment">// 将当前节点及其左子节点依次入栈</span></span><br><span class="line">                stack.<span class="built_in">push</span>(pRootOfTree);</span><br><span class="line">                pRootOfTree = pRootOfTree-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            pRootOfTree = stack.<span class="built_in">top</span>();  <span class="comment">// 从栈中取出一个节点</span></span><br><span class="line">            stack.<span class="built_in">pop</span>();  <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">            <span class="keyword">if</span> (isfirst) &#123;  <span class="comment">// 如果是第一个节点</span></span><br><span class="line">                head = pRootOfTree;  <span class="comment">// 设置链表头节点</span></span><br><span class="line">                pre = head;  <span class="comment">// 将pre指向该节点</span></span><br><span class="line">                isfirst = <span class="literal">false</span>;  <span class="comment">// 标记已经不是第一个节点了</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 如果不是第一个节点</span></span><br><span class="line">                pRootOfTree-&gt;left = pre;  <span class="comment">// 将当前节点左指针指向pre</span></span><br><span class="line">                pre-&gt;right = pRootOfTree;  <span class="comment">// 将pre右指针指向当前节点</span></span><br><span class="line">                pre = pRootOfTree;  <span class="comment">// 将pre更新为当前节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            pRootOfTree = pRootOfTree-&gt;right;  <span class="comment">// 将当前节点指向其右子节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;  <span class="comment">// 返回链表的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-2"><a href="#算法思路-amp-步骤-amp-时空复杂度-2" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>这段代码实现了将二叉搜索树转换为一个有序的双向链表。</p><p>算法思路如下：</p><ol><li>首先判断给定的二叉搜索树是否为空，如果为空，则返回nullptr。</li><li>创建两个指针<code>head</code>和<code>pre</code>，初始化为nullptr，用于记录链表的头节点和当前节点的前一个节点。</li><li>声明一个布尔变量<code>isfirst</code>，初始化为true，用于标记当前节点是否是链表的第一个节点。</li><li>创建一个栈<code>stack</code>，用于辅助进行中序遍历。</li><li>进入循环，当当前节点不为空或栈不为空时：<ul><li>循环将当前节点以及其左子节点依次入栈，直到当前节点为空。</li><li>从栈中取出一个节点作为当前节点，并将其指向左子节点的指针置空。</li><li>如果是第一个节点，将其设置为链表的头节点，并将<code>pre</code>指向该节点，然后将<code>isfirst</code>标记为false。</li><li>如果不是第一个节点，将当前节点与<code>pre</code>建立双向链接，并更新<code>pre</code>为当前节点。</li><li>将当前节点指向其右子节点，并继续下一轮循环。</li></ul></li><li>循环结束后，返回<code>head</code>作为链表的头节点。</li></ol><h2 id="JZ79-判断是不是平衡二叉树"><a href="#JZ79-判断是不是平衡二叉树" class="headerlink" title="JZ79 判断是不是平衡二叉树"></a>JZ79 判断是不是平衡二叉树</h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>输入一棵节点数为 n 二叉树，判断该二叉树是否是平衡二叉树。<br>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树<br>平衡二叉树（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">depthandbalance</span><span class="params">(TreeNode* pRoot, <span class="type">int</span>&amp; depth)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果当前节点为空，则认为是平衡的</span></span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">nullptr</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;x</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;  <span class="comment">// 左子树的深度</span></span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;  <span class="comment">// 右子树的深度</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归调用depthandbalance函数判断左子树和右子树是否平衡，并同时计算它们的深度</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">depthandbalance</span>(pRoot-&gt;left, left) == <span class="literal">false</span> || <span class="built_in">depthandbalance</span>(pRoot-&gt;right, right) == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果左子树和右子树的深度差大于1，则认为不平衡</span></span><br><span class="line">        <span class="keyword">if</span> (left - right &gt; <span class="number">1</span> || left - right &lt; <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新当前节点的深度为左子树深度和右子树深度的较大值加上1</span></span><br><span class="line">        depth = left &gt; right ? left + <span class="number">1</span> : right + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 返回平衡结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;  <span class="comment">// 用于记录当前节点的深度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">depthandbalance</span>(pRoot, depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-3"><a href="#算法思路-amp-步骤-amp-时空复杂度-3" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>这段代码是一个判断二叉树是否平衡的函数实现。</p><ol><li>首先判断给定的二叉树根节点是否为空，如果为空，则返回true，因为空树被认为是平衡的。</li><li>定义一个整数变量<code>depth</code>，用于记录当前节点的深度。</li><li>递归调用<code>depthandbalance()</code>函数来判断左子树和右子树是否平衡，同时计算它们的深度，并将结果保存在<code>left</code>和<code>right</code>中。</li><li>如果左子树或右子树不平衡（深度差大于1），则返回false，表示整个二叉树不平衡。</li><li>如果左子树和右子树都平衡，计算当前节点的深度（较大的子树深度加上1），并将深度更新到<code>depth</code>中。</li><li>返回true，表示二叉树平衡。</li></ol><h2 id="JZ8-二叉树的下一个结点"><a href="#JZ8-二叉树的下一个结点" class="headerlink" title="JZ8 二叉树的下一个结点"></a>JZ8 二叉树的下一个结点</h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>给定一个二叉树其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的next指针。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeLinkNode* <span class="title">GetNext</span><span class="params">(TreeLinkNode* pNode)</span> </span>&#123;  <span class="comment">// 定义GetNext函数，接收一个二叉树节点指针，并返回下一个节点指针</span></span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;right)&#123;  <span class="comment">// 如果pNode有右子树</span></span><br><span class="line">            TreeLinkNode*res=pNode-&gt;right;  <span class="comment">// 指针res指向pNode的右子节点</span></span><br><span class="line">            <span class="keyword">while</span>(res-&gt;left)&#123;  <span class="comment">// 如果res有左子树，说明pNode的右子树不是最底层的节点，需要向左继续遍历</span></span><br><span class="line">                res=res-&gt;left;  <span class="comment">// 继续向左遍历</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;  <span class="comment">// 返回下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;next&amp;&amp;pNode==pNode-&gt;next-&gt;left)&#123;  <span class="comment">// 如果pNode没有右子树，并且pNode是其父节点的左子节点</span></span><br><span class="line">            <span class="keyword">return</span> pNode-&gt;next;  <span class="comment">// 下一个节点就是其父节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;next)&#123;  <span class="comment">// 如果pNode不是根节点，并且pNode是其父节点的右子节点</span></span><br><span class="line">            TreeLinkNode*res=pNode-&gt;next;  <span class="comment">// 指针res指向pNode的父节点</span></span><br><span class="line">            <span class="keyword">while</span>(res-&gt;next&amp;&amp;res==res-&gt;next-&gt;right)&#123;  <span class="comment">// 如果res有父节点，且res是其父节点的右子节点</span></span><br><span class="line">                res=res-&gt;next;  <span class="comment">// 继续向上遍历</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res-&gt;next;  <span class="comment">// 返回下一个节点的父节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;  <span class="comment">// 如果pNode是根节点，或者pNode没有右子树并且也没有父节点，则返回空指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-4"><a href="#算法思路-amp-步骤-amp-时空复杂度-4" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>这段代码实现了一个二叉树中序遍历的下一个节点的查找函数。根据给定的节点pNode，函数会返回中序遍历中pNode的下一个节点。</p><ul><li>首先，判断pNode的右子树是否存在。如果存在，说明pNode有右子树，那么中序遍历时下一个节点一定是右子树中最左边的节点。所以从pNode的右子节点开始，一直找到其左子节点为止，即为下一个节点。</li><li>如果pNode没有右子树，则继续判断pNode的父节点pNode-&gt;next。如果pNode是其父节点的左子节点，那么下一个节点就是其父节点pNode-&gt;next。</li><li>最后，如果pNode不是根节点，并且pNode是其父节点的右子节点，那么下一个节点一定在pNode的祖先节点中。从pNode的父节点开始，沿着父节点的指针向上遍历，直到找到一个节点的父节点是该节点的左子节点，或者到达了根节点。如果找到了符合条件的节点，那么该节点的父节点就是下一个节点。</li></ul><p>代码中使用了一个TreeLinkNode结构体表示二叉树节点，包含了节点的值val、左子节点left、右子节点right和指向父节点的指针next。GetNext函数接收一个TreeLinkNode指针，并返回下一个节点的指针。</p><h2 id="JZ86-在二叉树中找到两个节点的最近公共祖先"><a href="#JZ86-在二叉树中找到两个节点的最近公共祖先" class="headerlink" title="JZ86 在二叉树中找到两个节点的最近公共祖先"></a>JZ86 在二叉树中找到两个节点的最近公共祖先</h2><h3 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h3><p>给定一棵二叉树(保证非空)以及这棵树上的两个节点对应的val值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, <span class="type">int</span> o1, <span class="type">int</span> o2)</span> </span>&#123;  <span class="comment">// 定义lowestCommonAncestor函数，接收一个二叉树的根节点root以及两个目标节点值o1和o2，并返回最近公共祖先节点的值</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;  <span class="comment">// 如果根节点为空，说明已经到达叶子节点，返回-1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == o1 || root-&gt;val == o2) &#123;  <span class="comment">// 如果根节点的值等于o1或者o2，说明当前节点就是目标节点之一，直接返回节点的值</span></span><br><span class="line">            <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, o1, o2);  <span class="comment">// 递归调用lowestCommonAncestor函数，查找左子树中的最近公共祖先节点</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, o1, o2);  <span class="comment">// 递归调用lowestCommonAncestor函数，查找右子树中的最近公共祖先节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="number">-1</span> &amp;&amp; right != <span class="number">-1</span>) &#123;  <span class="comment">// 如果左子树和右子树都返回了最近公共祖先节点的值，说明o1和o2分别位于当前节点的左右子树中，当前节点就是最近公共祖先节点</span></span><br><span class="line">            <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="number">-1</span>) &#123;  <span class="comment">// 如果只有左子树返回了最近公共祖先节点的值，说明o1和o2都位于左子树中，将左子树返回的值作为答案</span></span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (right != <span class="number">-1</span>) &#123;  <span class="comment">// 如果只有右子树返回了最近公共祖先节点的值，说明o1和o2都位于右子树中，将右子树返回的值作为答案</span></span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 如果左右子树都没有返回最近公共祖先节点的值，说明o1和o2都不在以当前节点为根的子树中，返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-5"><a href="#算法思路-amp-步骤-amp-时空复杂度-5" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>这段代码实现了二叉树中两个节点的最近公共祖先（Lowest Common Ancestor）的查找函数。给定一个二叉树的根节点root，以及两个目标节点值o1和o2，函数会返回o1和o2的最近公共祖先节点的值。</p><ul><li>首先进行判断，如果根节点为空，则返回-1表示不存在最近公共祖先。</li><li>接着，判断当前节点root的值是否等于目标节点值o1或o2。如果是的话，说明root本身就是其中一个目标节点，故直接返回root的值即可。</li><li>然后，递归调用最近公共祖先函数，分别传入root的左子节点和右子节点，以及目标节点值o1和o2。这里使用left和right来存储递归调用的结果。</li><li>在递归的过程中，会不断向下遍历二叉树，直到找到满足条件的节点，或者遍历到叶子节点为止。</li><li>回溯到父节点之后，在当前节点处判断左右子节点的结果left和right。如果left和right均不为-1，说明o1和o2分别位于当前节点的左右子树中，那么当前节点就是最近公共祖先，返回当前节点的值。</li><li>如果left不为-1，而right为-1，说明o1和o2都位于当前节点的左子树中，那么left即为最近公共祖先，返回left的值。</li><li>如果left为-1，而right不为-1，说明o1和o2都位于当前节点的右子树中，那么right即为最近公共祖先，返回right的值。</li><li>最后，如果上述情况均不满足，说明o1和o2没有找到最近公共祖先，返回-1表示不存在。</li></ul><p>代码中使用了一个TreeNode结构体表示二叉树节点，包含了节点的值val、左子节点left和右子节点right。lowestCommonAncestor函数接收一个TreeNode指针作为根节点，以及两个目标节点值o1和o2，并返回最近公共祖先的值。</p><h2 id="JZ68-二叉搜索树的最近公共祖先"><a href="#JZ68-二叉搜索树的最近公共祖先" class="headerlink" title="JZ68 二叉搜索树的最近公共祖先"></a>JZ68 二叉搜索树的最近公共祖先</h2><h3 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。<br>1.对于该题的最近的公共祖先定义:对于有根树T的两个节点p、q，最近公共祖先LCA(T,p,q)表示一个节点x，满足x是p和q的祖先且x的深度尽可能大。在这里，一个节点也可以是它自己的祖先.<br>2.二叉搜索树是若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值<br>3.所有节点的值都是唯一的。<br>4.p、q 为不同节点且均存在于给定的二叉搜索树中。</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义一个辅助函数，用于从根节点到目标节点的路径</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Path_X</span><span class="params">(TreeNode* root, <span class="type">int</span> X)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;path;  <span class="comment">// 保存路径节点值的数组</span></span><br><span class="line">        TreeNode* node = root;  <span class="comment">// 当前节点指针，从根节点开始</span></span><br><span class="line">        <span class="keyword">while</span> (node-&gt;val != X) &#123;  <span class="comment">// 当当前节点的值不等于目标节点值时</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(node-&gt;val);  <span class="comment">// 将当前节点值添加到路径中</span></span><br><span class="line">            <span class="keyword">if</span> (X &lt; node-&gt;val) &#123;  <span class="comment">// 如果目标节点值小于当前节点值，说明目标节点在左子树中，继续遍历左子树</span></span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (X &gt; node-&gt;val) &#123;  <span class="comment">// 如果目标节点值大于当前节点值，说明目标节点在右子树中，继续遍历右子树</span></span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">push_back</span>(node-&gt;val);  <span class="comment">// 将目标节点值添加到路径中</span></span><br><span class="line">        <span class="keyword">return</span> path;  <span class="comment">// 返回根节点到目标节点的路径</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, <span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;path_p = <span class="built_in">Path_X</span>(root, p);  <span class="comment">// 获取p节点的路径</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;path_q = <span class="built_in">Path_X</span>(root, q);  <span class="comment">// 获取q节点的路径</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;  <span class="comment">// 初始化最近公共祖先节点的值为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; path_p.<span class="built_in">size</span>() &amp;&amp; i &lt; path_q.<span class="built_in">size</span>(); i++) &#123;  <span class="comment">// 遍历p和q的路径，找到最近的公共节点</span></span><br><span class="line">            <span class="keyword">if</span> (path_p[i] == path_q[i]) &#123;  <span class="comment">// 如果路径上的节点值相等，说明是公共节点</span></span><br><span class="line">                res = path_p[i];  <span class="comment">// 更新最近公共祖先节点的值</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 如果节点值不相等，说明路径分叉，停止遍历</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;  <span class="comment">// 返回最近公共祖先节点的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-6"><a href="#算法思路-amp-步骤-amp-时空复杂度-6" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>首先，我们需要定义一个辅助函数 <code>Path_X</code>，用于获取从根节点到目标节点的路径。</p><p>在 <code>Path_X</code> 函数中，我们通过从根节点开始，按照二叉搜索树的性质进行比较，找到目标节点。具体步骤如下：</p><ol><li>初始化一个空数组 <code>path</code>，用于保存路径的节点值。</li><li>从根节点开始，将根节点的值添加到 <code>path</code> 中。</li><li>根据目标节点的值与当前节点的值的比较，如果目标节点的值小于当前节点的值，则说明目标节点在当前节点的左子树中，我们将当前节点移动到左子节点，并将左子节点的值添加到 <code>path</code> 中。</li><li>如果目标节点的值大于当前节点的值，则说明目标节点在当前节点的右子树中，我们将当前节点移动到右子节点，并将右子节点的值添加到 <code>path</code> 中。</li><li>重复步骤3和步骤4，直到当前节点的值等于目标节点的值为止，此时将目标节点的值添加到 <code>path</code> 中。</li><li>返回 <code>path</code>，即为从根节点到目标节点的路径。</li></ol><p>接下来，在 <code>lowestCommonAncestor</code> 函数中，我们调用 <code>Path_X</code> 函数获取目标节点 <code>p</code> 和 <code>q</code> 的路径，并进行公共祖先的查找。</p><p>具体步骤如下：</p><ol><li>调用 <code>Path_X</code> 函数获取节点 <code>p</code> 的路径，保存在 <code>path_p</code> 中。</li><li>调用 <code>Path_X</code> 函数获取节点 <code>q</code> 的路径，保存在 <code>path_q</code> 中。</li><li>初始化一个变量 <code>res</code> 为0，用于存储最近公共祖先节点的值。</li><li>使用一个循环遍历 <code>path_p</code> 和 <code>path_q</code>，比较路径中相同位置上的节点值。<ul><li>如果节点值相等，说明是公共节点，更新 <code>res</code> 的值为当前节点值。</li><li>如果节点值不相等，说明路径分叉，停止遍历。</li></ul></li><li>返回 <code>res</code>，即为最近公共祖先节点的值。</li></ol><p>因此，这个算法的主要步骤是：通过辅助函数获取两个目标节点的路径，然后遍历路径找到最近公共祖先节点。</p><p>时间复杂度分析：由于需要分别遍历两个目标节点的路径，时间复杂度为 <code>O(n)</code>，其中 <code>n</code> 为二叉搜索树的节点数。</p><p>空间复杂度分析：由于需要存储两个目标节点的路径，空间复杂度为 <code>O(h)</code>，其中 <code>h</code> 为二叉搜索树的高度。在最坏情况下（单链表形式的树），<code>h=n</code>，空间复杂度为 <code>O(n)</code>。</p><h2 id="JZ37-序列化二叉树"><a href="#JZ37-序列化二叉树" class="headerlink" title="JZ37 序列化二叉树"></a>JZ37 序列化二叉树</h2><h3 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a>描述</h3><p>请实现两个函数，分别用来序列化和反序列化二叉树，不对序列化之后的字符串进行约束，但要求能够根据序列化之后的字符串重新构造出一棵与原二叉树相同的树。</p><p>二叉树的序列化(Serialize)是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树等遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#）</p><p>二叉树的反序列化(Deserialize)是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 序列化二叉树为字符串</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">serializefunc</span><span class="params">(TreeNode* root, string&amp; str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            str += <span class="string">&#x27;#&#x27;</span>;  <span class="comment">// 空节点用 &#x27;#&#x27; 表示</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string temp = <span class="built_in">to_string</span>(root-&gt;val);  <span class="comment">// 将节点值转为字符串</span></span><br><span class="line">        str += temp + <span class="string">&#x27;!&#x27;</span>;  <span class="comment">// 节点值后面加上 &#x27;!&#x27; 作为分隔符</span></span><br><span class="line">        <span class="built_in">serializefunc</span>(root-&gt;left, str);  <span class="comment">// 递归序列化左子树</span></span><br><span class="line">        <span class="built_in">serializefunc</span>(root-&gt;right, str);  <span class="comment">// 递归序列化右子树</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化二叉树，返回一个字符数组</span></span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">Serialize</span><span class="params">(TreeNode *root)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;  <span class="comment">// 如果根节点为空，返回 &quot;#&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="built_in">serializefunc</span>(root, res);  <span class="comment">// 序列化二叉树为字符串</span></span><br><span class="line">        <span class="type">char</span> *charres = <span class="keyword">new</span> <span class="type">char</span>[res.<span class="built_in">size</span>() + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(charres, res.<span class="built_in">c_str</span>());  <span class="comment">// 字符串转为字符数组</span></span><br><span class="line">        charres[res.<span class="built_in">size</span>()] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 添加结束符</span></span><br><span class="line">        <span class="keyword">return</span> charres;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化字符串为二叉树</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserializefunc</span><span class="params">(<span class="type">char</span>** str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((**str) == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            (*str)++;  <span class="comment">// 指针右移，跳过当前节点的 &quot;#&quot;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;  <span class="comment">// 返回空节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((**str) != <span class="string">&#x27;!&#x27;</span> &amp;&amp; (**str) != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            val = val * <span class="number">10</span> + ((**str) - <span class="string">&#x27;0&#x27;</span>);  <span class="comment">// 计算节点值</span></span><br><span class="line">            (*str)++;  <span class="comment">// 指针右移，读取下一个字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);  <span class="comment">// 创建当前节点</span></span><br><span class="line">        <span class="keyword">if</span> ((**str) == <span class="string">&#x27;\0&#x27;</span>) &#123;  <span class="comment">// 如果已经到达字符串末尾，返回当前节点</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            (*str)++;  <span class="comment">// 指针右移，跳过当前节点的 &quot;!&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;left = <span class="built_in">deserializefunc</span>(str);  <span class="comment">// 递归构建左子树</span></span><br><span class="line">        root-&gt;right = <span class="built_in">deserializefunc</span>(str);  <span class="comment">// 递归构建右子树</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化字符数组为二叉树</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">Deserialize</span><span class="params">(<span class="type">char</span> *str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="string">&quot;#&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;  <span class="comment">// 如果输入字符串为 &quot;#&quot;，表示空节点，直接返回 nullptr</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">deserializefunc</span>(&amp;str);  <span class="comment">// 反序列化字符串为二叉树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-7"><a href="#算法思路-amp-步骤-amp-时空复杂度-7" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>这个算法是通过递归的方式实现二叉树的序列化和反序列化。以下是算法的详细思路和步骤以及时间空间复杂度的分析。</p><h5 id="序列化-Serialize"><a href="#序列化-Serialize" class="headerlink" title="序列化(Serialize)"></a>序列化(Serialize)</h5><ol><li>若根节点为空，将 “#” 加入结果字符串，并返回。</li><li>将根节点的值转为字符串，并加入结果字符串。</li><li>递归调用 <code>Serialize</code> 方法序列化左子树。</li><li>递归调用 <code>Serialize</code> 方法序列化右子树。</li><li>返回序列化结果字符串。</li></ol><p>该算法通过先序遍历的方式对二叉树进行序列化。具体步骤如下：</p><ul><li><p>若根节点为空，在结果字符串中添加字符 “#”，表示空节点。</p></li><li><p>若根节点不为空，将根节点的值转为字符串，加入结果字符串中，并在值后面添加字符 “!” 作为分隔符。</p></li><li><p>递归调用 <code>Serialize</code> 方法序列化左子树。</p></li><li><p>递归调用 <code>Serialize</code> 方法序列化右子树。</p></li><li><p>最后，返回序列化结果字符串。</p></li><li><p>时间复杂度：在遍历二叉树的过程中，需要访问每个节点一次，因此时间复杂度为 O(N)，其中 N 表示二叉树中的节点数。</p></li><li><p>空间复杂度：除了存储序列化结果字符串外，算法的递归调用栈的空间复杂度为二叉树的高度，即 O(logN) ~ O(N)，其中 N 表示二叉树中的节点数。</p></li></ul><h5 id="反序列化-Deserialize"><a href="#反序列化-Deserialize" class="headerlink" title="反序列化(Deserialize)"></a>反序列化(Deserialize)</h5><ol><li>若输入字符串为 “#”，表示空节点，直接返回 nullptr。</li><li>读取字符串中的值直到遇到字符 “!” 或字符串结束符 “\0”，将读取到的值转为整数作为当前节点的值。</li><li>创建当前节点，并递归调用 <code>Deserialize</code> 方法构建左子树。</li><li>递归调用 <code>Deserialize</code> 方法构建右子树。</li><li>返回构建好的二叉树根节点。</li></ol><p>该算法通过递归的方式对序列化字符串进行反序列化，重新构建二叉树。具体步骤如下：</p><ul><li><p>若输入字符串为 “#”，表示空节点，直接返回 nullptr。</p></li><li><p>从字符串中读取一个节点的值，直到遇到字符 “!” 或字符串结束符 “\0”。</p></li><li><p>将读取到的值转为整数，创建当前节点。</p></li><li><p>递归调用 <code>Deserialize</code> 方法构建左子树。</p></li><li><p>递归调用 <code>Deserialize</code> 方法构建右子树。</p></li><li><p>最后，返回构建好的二叉树根节点。</p></li><li><p>时间复杂度：在解析序列化字符串的过程中，需要访问每个字符一次，因此时间复杂度为 O(N)，其中 N 表示字符的个数。</p></li><li><p>空间复杂度：除了存储二叉树节点和指针外，算法的递归调用栈的空间复杂度为二叉树的高度，即 O(logN) ~ O(N)，其中 N 表示二叉树中的节点数。</p></li></ul><p>综上所述，该算法的时间复杂度为 O(N)，空间复杂度为 O(N)。其中 N 表示二叉树中的节点数。</p><h1 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h1><p>期待下篇博客与你相见~</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data structure algorithm program for trees (2)</title>
      <link href="/2023/10/10/Data-structure-algorithm-program-for-trees-2/"/>
      <url>/2023/10/10/Data-structure-algorithm-program-for-trees-2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>篇接上文，继续栽树！</p><h2 id="JZ7-重建二叉树"><a href="#JZ7-重建二叉树" class="headerlink" title="JZ7 重建二叉树"></a>JZ7 重建二叉树</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map; <span class="comment">// 哈希表用于存储中序遍历结果元素及其索引的映射关系</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">reconstructTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preOrder, <span class="type">int</span> pstart, <span class="type">int</span> pend, </span></span></span><br><span class="line"><span class="params"><span class="function">                              vector&lt;<span class="type">int</span>&gt;&amp; vinOrder, <span class="type">int</span> vstart, <span class="type">int</span> vend)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pstart &gt; pend || vstart &gt; vend) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 先序遍历结果或中序遍历结果为空，返回空指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preOrder[pstart]); <span class="comment">// 创建根节点</span></span><br><span class="line">        <span class="type">int</span> rootindex = map[preOrder[pstart]]; <span class="comment">// 根节点在中序遍历结果中的索引位置</span></span><br><span class="line">        <span class="type">int</span> leftlen = rootindex - vstart; <span class="comment">// 左子树的长度</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归构建左子树：</span></span><br><span class="line">        <span class="comment">// 先序遍历起始位置为 pstart + 1，终止位置为 pstart + leftlen；</span></span><br><span class="line">        <span class="comment">// 中序遍历起始位置为 vstart，终止位置为 rootindex - 1。</span></span><br><span class="line">        root-&gt;left = <span class="built_in">reconstructTree</span>(preOrder, pstart + <span class="number">1</span>, pstart + leftlen, </span><br><span class="line">                                     vinOrder, vstart, rootindex - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归构建右子树：</span></span><br><span class="line">        <span class="comment">// 先序遍历起始位置为 pstart + leftlen + 1，终止位置为 pend；</span></span><br><span class="line">        <span class="comment">// 中序遍历起始位置为 rootindex + 1，终止位置为 vend。</span></span><br><span class="line">        root-&gt;right = <span class="built_in">reconstructTree</span>(preOrder, pstart + leftlen + <span class="number">1</span>, pend, </span><br><span class="line">                                      vinOrder, rootindex + <span class="number">1</span>, vend);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">// 返回根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preOrder, vector&lt;<span class="type">int</span>&gt;&amp; vinOrder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> plen = preOrder.<span class="built_in">size</span>(); <span class="comment">// 先序遍历结果长度</span></span><br><span class="line">        <span class="type">int</span> vlen = vinOrder.<span class="built_in">size</span>(); <span class="comment">// 中序遍历结果长度</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (plen == <span class="number">0</span> || vlen == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 先序遍历结果或中序遍历结果为空，返回空指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">            map[vinOrder[i]] = i; <span class="comment">// 将中序遍历结果中各元素及其索引存入哈希表中</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用递归函数构建二叉树，并返回根节点：</span></span><br><span class="line">        <span class="comment">// 先序遍历起始位置为 0，终止位置为 plen - 1；</span></span><br><span class="line">        <span class="comment">// 中序遍历起始位置为 0，终止位置为 vlen - 1。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reconstructTree</span>(preOrder, <span class="number">0</span>, plen - <span class="number">1</span>, vinOrder, <span class="number">0</span>, vlen - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度"><a href="#算法思路-amp-步骤-amp-时空复杂度" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>这段代码是根据先序遍历和中序遍历结果构建一棵二叉树。给定一棵二叉树的先序遍历结果和中序遍历结果，我们需要重建这棵二叉树并返回根节点。</p><ol><li>定义一个哈希表 <code>unordered_map&lt;int, int&gt; map</code> 用于存储中序遍历结果中每个元素对应的索引位置（值 -&gt; 索引）。</li><li>使用递归函数 <code>reconstructTree()</code> 实现构建二叉树的过程：<ul><li>如果先序遍历的起始位置大于结束位置或中序遍历的起始位置大于结束位置，则说明该子树为空，返回 <code>nullptr</code>。</li><li>创建根节点，其值为先序遍历起始位置的元素值。</li><li>根据根节点的值在中序遍历结果中找到对应的索引位置 <code>rootindex</code>。</li><li>计算左子树的长度 <code>leftlen = rootindex - vstart</code>。</li><li>递归构建左子树：先序遍历的起始位置为 <code>pstart + 1</code>，终止位置为 <code>pstart + leftlen</code>；中序遍历的起始位置为 <code>vstart</code>，终止位置为 <code>rootindex - 1</code>。</li><li>递归构建右子树：先序遍历的起始位置为 <code>pstart + leftlen + 1</code>，终止位置为 <code>pend</code>；中序遍历的起始位置为 <code>rootindex + 1</code>，终止位置为 <code>vend</code>。</li><li>返回根节点。</li></ul></li><li>在 <code>reConstructBinaryTree()</code> 函数中，首先判断先序遍历结果和中序遍历结果是否为空，如果有空，则直接返回 <code>nullptr</code>。</li><li>遍历中序遍历结果，将各元素及其索引存入哈希表 <code>map</code> 中。</li><li>调用 <code>reconstructTree()</code> 函数构建二叉树，并返回根节点。</li></ol><p>这段代码的时间复杂度为 O(n)，其中 n 表示节点数目。</p><h2 id="JZ27-二叉树的镜像"><a href="#JZ27-二叉树的镜像" class="headerlink" title="JZ27 二叉树的镜像"></a>JZ27 二叉树的镜像</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Mirror</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个栈，用于辅助实现迭代遍历</span></span><br><span class="line">        stack&lt;TreeNode*&gt;stack;</span><br><span class="line">        <span class="comment">// 将根节点压入栈中</span></span><br><span class="line">        stack.<span class="built_in">push</span>(pRoot);</span><br><span class="line">        <span class="comment">// 迭代直到栈为空</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">// 从栈顶取出一个节点</span></span><br><span class="line">            TreeNode*node=stack.<span class="built_in">top</span>();</span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 若该节点有左子树，则将其左子树压入栈中</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若该节点有右子树，则将其右子树压入栈中</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 交换该节点的左右子树</span></span><br><span class="line">            TreeNode*temp=node-&gt;left;</span><br><span class="line">            node-&gt;left=node-&gt;right;</span><br><span class="line">            node-&gt;right=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回翻转后的二叉树的根节点</span></span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-1"><a href="#算法思路-amp-步骤-amp-时空复杂度-1" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>该算法使用迭代的方式来实现二叉树的翻转。其主要思路如下：</p><ol><li>首先检查根节点是否为空，若为空则直接返回空节点。</li><li>创建一个栈用于辅助实现迭代遍历，将根节点压入栈中。</li><li>进入循环，直到栈为空为止。在每次循环中执行以下操作：<ul><li>从栈中取出一个节点，表示当前要处理的节点。</li><li>若该节点有左子树，则将左子树压入栈中（因为要进行翻转操作）。</li><li>若该节点有右子树，则将右子树压入栈中。</li><li>交换该节点的左右子树，完成翻转操作。</li></ul></li><li>循环结束后，返回翻转后的二叉树的根节点。</li></ol><p>该算法的关键点在于使用栈来辅助实现迭代遍历。通过不断地从栈中取出节点并处理，保证了每个节点的左右子树都被正确处理和交换。</p><p>算法的时间复杂度是O(N)，其中N是二叉树中的节点数，因为每个节点都需要遍历一次。空间复杂度是O(M)，其中M是二叉树的最大宽度，即树的某一层的节点数量。由于使用了栈来辅助遍历，所以空间复杂度与树的宽度相关。</p><h2 id="JZ28-对称的二叉树"><a href="#JZ28-对称的二叉树" class="headerlink" title="JZ28 对称的二叉树"></a>JZ28 对称的二叉树</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stack&lt;TreeNode*&gt;stack;</span><br><span class="line">    stack.<span class="built_in">push</span>(pRoot-&gt;left);  <span class="comment">// 将左子树根节点压入栈中</span></span><br><span class="line">    stack.<span class="built_in">push</span>(pRoot-&gt;right);  <span class="comment">// 将右子树根节点压入栈中</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        TreeNode* rightNode=stack.<span class="built_in">top</span>();  <span class="comment">// 取出栈顶的右子树节点</span></span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">        TreeNode* leftNode=stack.<span class="built_in">top</span>();  <span class="comment">// 取出栈顶的左子树节点</span></span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(leftNode==<span class="literal">nullptr</span> &amp;&amp; rightNode==<span class="literal">nullptr</span>)&#123;  <span class="comment">// 如果左右子树节点都为空，表示对称</span></span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">// 进入下一次循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(leftNode==<span class="literal">nullptr</span> || rightNode==<span class="literal">nullptr</span> || leftNode-&gt;val!=rightNode-&gt;val)&#123;  <span class="comment">// 左右子树节点不对称</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">        stack.<span class="built_in">push</span>(leftNode-&gt;left);  <span class="comment">// 将左子树节点的左子节点压入栈中</span></span><br><span class="line">        stack.<span class="built_in">push</span>(rightNode-&gt;right);  <span class="comment">// 将右子树节点的右子节点压入栈中</span></span><br><span class="line">        stack.<span class="built_in">push</span>(leftNode-&gt;right);  <span class="comment">// 将左子树节点的右子节点压入栈中</span></span><br><span class="line">        stack.<span class="built_in">push</span>(rightNode-&gt;left);  <span class="comment">// 将右子树节点的左子节点压入栈中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 循环结束后，没有返回false，表示二叉树是对称的，返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-2"><a href="#算法思路-amp-步骤-amp-时空复杂度-2" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>该算法使用迭代的方式来判断二叉树的对称性。其主要思路如下：</p><ol><li>首先检查根节点是否为空，若为空则直接返回true（空树被视为对称的）。</li><li>创建一个栈用于辅助实现迭代遍历，将左子树和右子树的根节点分别压入栈中。</li><li>进入循环，直到栈为空为止。在每次循环中执行以下操作：<ul><li>从栈中取出两个节点，分别表示当前要比较的左子树节点和右子树节点。</li><li>如果两个节点都为空，则继续下一次循环。</li><li>如果有一个节点为空，或者两个节点的值不相等，则返回false，表示不对称。</li><li>将左子树节点的左子节点、右子节点和右子树节点的右子节点、左子节点分别压入栈中，以保证对称性的比较。</li></ul></li><li>循环结束后，如果没有返回false，表示二叉树是对称的，返回true。</li></ol><p>该算法的时间复杂度是O(N)，其中N是二叉树中的节点数，因为每个节点都需要遍历一次。空间复杂度是O(M)，其中M是二叉树的最大宽度，即树的某一层的节点数量。由于使用了栈来辅助遍历，所以空间复杂度与树的宽度相关。</p><h2 id="JZ26-树的子结构"><a href="#JZ26-树的子结构" class="headerlink" title="JZ26 树的子结构"></a>JZ26 树的子结构</h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>输入两棵二叉树A，B，判断B是不是A的子结构。（我们约定空树不是任意一个树的子结构）<br>假如给定A为{8,8,7,9,2,#,#,#,#,4,7}，B为{8,9,2}，可以看出B是A的子结构</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 判断两个二叉树是否相等</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isequal</span><span class="params">(TreeNode* tree1, TreeNode* tree2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tree1 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tree1-&gt;val != tree2-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isequal</span>(tree1-&gt;left, tree2-&gt;left) &amp;&amp; <span class="built_in">isequal</span>(tree1-&gt;right, tree2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断pRoot2是否是pRoot1的子结构</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果pRoot1或pRoot2为空，则返回false</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot1 == <span class="literal">nullptr</span> || pRoot2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果pRoot2和pRoot1相等，则返回true</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isequal</span>(pRoot1, pRoot2))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归判断pRoot2是否是pRoot1的左子树的子结构或右子树的子结构</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">HasSubtree</span>(pRoot1-&gt;left, pRoot2) || <span class="built_in">HasSubtree</span>(pRoot1-&gt;right, pRoot2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-3"><a href="#算法思路-amp-步骤-amp-时空复杂度-3" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>在这段代码中，<code>HasSubtree()</code> 函数判断 <code>pRoot2</code> 是否是 <code>pRoot1</code> 的子结构。为了实现这个功能，定义了一个辅助函数 <code>isequal()</code>，用来判断两棵二叉树是否相等。</p><ul><li><p><code>isequal()</code> 函数通过递归的方式判断两棵二叉树是否相等。具体步骤如下：</p><ul><li>如果 <code>tree2</code> 为空树，说明已经遍历完 <code>pRoot2</code> 的所有节点，则返回 true。</li><li>如果 <code>tree1</code> 为空树，但 <code>tree2</code> 不为空树，说明 <code>pRoot1</code> 已经遍历完，但 <code>pRoot2</code> 还有剩余节点，返回 false。</li><li>如果 <code>tree1</code> 和 <code>tree2</code> 的值不相等，返回 false。</li><li>递归判断 <code>tree1</code> 的左子树和 <code>tree2</code> 的左子树是否相等，以及 <code>tree1</code> 的右子树和 <code>tree2</code> 的右子树是否相等。如果两个都相等，返回 true；否则，返回 false。</li></ul></li><li><p><code>HasSubtree()</code> 函数中首先判断 <code>pRoot1</code> 和 <code>pRoot2</code> 是否为空树，若为空树，则返回 false；若相等，则返回 true。然后递归判断 <code>pRoot2</code> 是否是 <code>pRoot1</code> 的左子树的子结构或右子树的子结构。如果其中任意一条路径返回 true，说明 <code>pRoot2</code> 是 <code>pRoot1</code> 的子结构，返回 true；否则，返回 false。</p></li></ul><p>这段代码的时间复杂度取决于两个二叉树中的节点数量，为 O(MN)，其中 M 和 N 分别是两棵二叉树的节点数量。空间复杂度为 O(M)，递归调用的栈空间消耗与 <code>pRoot1</code> 的高度相关。</p><h2 id="JZ82-二叉树中和为某一值的路径-一"><a href="#JZ82-二叉树中和为某一值的路径-一" class="headerlink" title="JZ82 二叉树中和为某一值的路径(一)"></a>JZ82 二叉树中和为某一值的路径(一)</h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>给定一个二叉树root和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。<br>1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点<br>2.叶子节点是指没有子节点的节点<br>3.路径只能从父节点到子节点，不能从子节点到父节点<br>4.总节点数目为n</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果根节点为空，则返回false，因为空节点找不到路径</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个栈，用于辅助深度优先遍历</span></span><br><span class="line">        stack&lt;pair&lt;TreeNode*, <span class="type">int</span>&gt;&gt; stack;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将根节点和路径和（根节点的值）入栈</span></span><br><span class="line">        stack.<span class="built_in">push</span>(&#123;root, root-&gt;val&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 循环直到栈为空</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 取出栈顶元素</span></span><br><span class="line">            <span class="keyword">auto</span> temp = stack.<span class="built_in">top</span>();</span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 判断当前节点是否为叶子节点且路径和等于sum</span></span><br><span class="line">            <span class="comment">// 如果是，则返回true</span></span><br><span class="line">            <span class="keyword">if</span> (temp.first-&gt;left == <span class="literal">nullptr</span> &amp;&amp; temp.first-&gt;right == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">                    sum == temp.second) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将当前节点的左子节点入栈，并更新路径和</span></span><br><span class="line">            <span class="keyword">if</span> (temp.first-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(&#123;temp.first-&gt;left, temp.second + temp.first-&gt;left-&gt;val&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将当前节点的右子节点入栈，并更新路径和</span></span><br><span class="line">            <span class="keyword">if</span> (temp.first-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(&#123;temp.first-&gt;right, temp.second + temp.first-&gt;right-&gt;val&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当栈为空时，表示已经遍历完整个二叉树，但没有找到满足条件的路径和，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-4"><a href="#算法思路-amp-步骤-amp-时空复杂度-4" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>在这段代码中，使用迭代方式实现深度优先遍历，判断二叉树中是否存在从根节点到叶子节点的路径和等于给定值 <code>sum</code>。</p><p>首先对根节点进行非空判断，如果为空，则返回 false。</p><p>接下来，创建一个栈，用于辅助深度优先遍历。将根节点和路径和（根节点的值）入栈。</p><p>进入循环，每次取出栈顶元素 <code>temp</code>，包含当前节点 <code>temp.first</code> 和当前路径和 <code>temp.second</code>。</p><p>判断当前节点是否为叶子节点且路径和等于 <code>sum</code>。如果是，则返回 true；否则，继续往下遍历。</p><p>将当前节点的左子节点入栈，并更新路径和为原路径和加上左子节点的值。</p><p>将当前节点的右子节点入栈，并更新路径和为原路径和加上右子节点的值。</p><p>当栈为空时，表示已经遍历完整个二叉树，但没有找到满足条件的路径和，返回 false。</p><p>注：代码中循环使用的是迭代方式实现的深度优先遍历，相对于递归方式，迭代方式不会消耗额外的栈空间，提高了代码的鲁棒性和稳定性。</p><h2 id="JZ34-二叉树中和为某一值的路径-二"><a href="#JZ34-二叉树中和为某一值的路径-二" class="headerlink" title="JZ34 二叉树中和为某一值的路径(二)"></a>JZ34 二叉树中和为某一值的路径(二)</h2><h3 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h3><p>输入一颗二叉树的根节点root和一个整数expectNumber，找出二叉树中结点值的和为expectNumber的所有路径。<br>1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点<br>2.叶子节点是指没有子节点的节点<br>3.路径只能从父节点到子节点，不能从子节点到父节点<br>4.总节点数目为n</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res; <span class="comment">// 存储结果的二维数组</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 当前路径的一维数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果当前节点为空，直接返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 将当前节点的值添加到路径中</span></span><br><span class="line">        target -= root-&gt;val; <span class="comment">// 更新目标值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; target == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前节点是叶子节点且目标值为0，说明找到了一条符合要求的路径</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(path); <span class="comment">// 将路径添加到结果中</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, target); <span class="comment">// 递归调用左子节点</span></span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, target); <span class="comment">// 递归调用右子节点</span></span><br><span class="line"></span><br><span class="line">        path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，将路径中的最后一个节点弹出，用于搜索其他路径</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">FindPath</span>(TreeNode* root, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, target); <span class="comment">// 调用深度优先搜索函数找到所有路径</span></span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-5"><a href="#算法思路-amp-步骤-amp-时空复杂度-5" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><ul><li><code>void dfs(TreeNode* root, int target)</code> ：深度优先搜索函数，用于遍历树的每个节点。</li><li><code>if (root == nullptr)</code> ：如果当前节点为空，直接返回。</li><li><code>path.push_back(root-&gt;val)</code> ：将当前节点的值添加到路径中。</li><li><code>target -= root-&gt;val</code> ：更新目标值，减去当前节点的值。</li><li><code>if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr &amp;&amp; target == 0)</code> ：如果当前节点是叶子节点且目标值为0，说明找到了一条符合要求的路径。</li><li><code>res.push_back(path)</code> ：将找到的路径添加到结果中。</li><li><code>dfs(root-&gt;left, target)</code> ：递归调用左子节点。</li><li><code>dfs(root-&gt;right, target)</code> ：递归调用右子节点。</li><li><code>path.pop_back()</code> ：回溯，将路径中的最后一个节点弹出，用于搜索其他路径。</li><li><code>dfs(root, target)</code> ：调用深度优先搜索函数找到所有路径。</li><li><code>return res</code> ：返回结果。</li></ul><p>这段代码实现了在二叉树中寻找路径和为给定值 <code>target</code> 的所有路径。</p><p>首先定义了一个全局变量 <code>res</code>，用来存储找到的路径结果。</p><p>定义了一个辅助函数 <code>dfs</code>，用于进行深度优先搜索。参数 <code>root</code> 表示当前节点，<code>target</code> 表示当前剩余的目标值。</p><p>如果当前节点为空，直接返回。</p><p>将当前节点的值添加到 <code>path</code> 中，并更新目标值。</p><p>如果当前节点是叶子节点且目标值为0，表示找到了一条路径，将 <code>path</code> 添加到 <code>res</code> 中。</p><p>递归调用左子节点和右子节点，并传入更新后的目标值。</p><p>完成递归后，将 <code>path</code> 中的最后一个元素（即当前节点）弹出，用于回溯到上一层。</p><p>最后，在主函数 <code>FindPath</code> 中调用 <code>dfs</code> 来进行深度优先搜索。</p><p>返回 <code>res</code> 即为找到的所有路径。</p><p>需要注意的是，路径是从根节点到叶子节点，因此在找到路径后要进行回溯，将路径中的最后一个节点弹出。这样可以确保每次递归都从当前节点的兄弟节点开始搜索，而不是回到父节点重新搜索。</p><p>另外，由于题目中要求返回的是二维数组类型，所以 <code>res</code> 的类型是 <code>vector&lt;vector&lt;int&gt;&gt;</code>。</p><h2 id="JZ84-二叉树中和为某一值的路径-三"><a href="#JZ84-二叉树中和为某一值的路径-三" class="headerlink" title="JZ84 二叉树中和为某一值的路径(三)"></a>JZ84 二叉树中和为某一值的路径(三)</h2><h3 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h3><p>给定一个二叉树root和一个整数值 sum ，求该树有多少路径的的节点值之和等于 sum 。<br>1.该题路径定义不需要从根节点开始，也不需要在叶子节点结束，但是一定是从父亲节点往下到孩子节点<br>2.总节点数目为n<br>3.保证最后返回的路径个数在整形范围内(即路径个数小于2^31 -1)</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>; <span class="comment">// 用于存储路径数量的变量</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 用于存储路径的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果当前节点为空，直接返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 将当前节点的值添加到路径中</span></span><br><span class="line">        sum -= root-&gt;val; <span class="comment">// 更新目标值，减去当前节点的值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123; <span class="comment">// 如果目标值为0，说明找到了一条符合要求的路径</span></span><br><span class="line">            res++; <span class="comment">// 将结果加1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, sum); <span class="comment">// 递归调用左子节点</span></span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, sum); <span class="comment">// 递归调用右子节点</span></span><br><span class="line"></span><br><span class="line">        path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，将路径中的最后一个节点弹出，用于搜索其他路径</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">FindPath</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果根节点为空，直接返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root, sum); <span class="comment">// 调用深度优先搜索函数找到所有路径</span></span><br><span class="line">        <span class="built_in">FindPath</span>(root-&gt;left, sum); <span class="comment">// 递归调用左子树</span></span><br><span class="line">        <span class="built_in">FindPath</span>(root-&gt;right, sum); <span class="comment">// 递归调用右子树</span></span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-6"><a href="#算法思路-amp-步骤-amp-时空复杂度-6" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>这段代码使用了深度优先搜索（DFS）来计算二叉树中路径和为给定值 <code>sum</code> 的路径数量。</p><ol><li>定义一个变量 <code>res</code> 来存储路径数量的计数，初始值为0。</li><li>定义一个数组 <code>path</code> 来存储当前路径的节点值。</li><li>编写一个深度优先搜索函数 <code>dfs</code>，用于遍历树的每个节点。</li><li>在 <code>dfs</code> 函数中，首先判断当前节点是否为空，若为空则直接返回。</li><li>将当前节点的值添加到路径 <code>path</code> 中。</li><li>更新目标值 <code>sum</code>，将其减去当前节点的值。</li><li>如果目标值 <code>sum</code> 为0，说明找到了一条符合要求的路径，将计数器 <code>res</code> 加1。</li><li>递归地调用左子节点和右子节点，分别进行深度优先搜索。</li><li>回溯，将 <code>path</code> 中的最后一个节点弹出，用于搜索其他路径。</li><li>编写主函数 <code>FindPath</code> 来调用深度优先搜索函数并计算所有路径的数量。</li><li>若根节点为空，则直接返回0。</li><li>调用深度优先搜索函数 <code>dfs</code> 来找到所有路径。</li><li>递归调用左子树和右子树，分别计算它们的路径数量。</li><li>返回最终的路径数量 <code>res</code>。</li></ol><p>通过以上步骤，算法会遍历二叉树的所有路径，并计算出路径和为给定值 <code>sum</code> 的路径数量。</p><h1 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h1><p>期待下篇博客与你相见~</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bulk algorithm questions (2)</title>
      <link href="/2023/10/09/Bulk-algorithm-questions-2/"/>
      <url>/2023/10/09/Bulk-algorithm-questions-2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>篇接上回，直接开干！</p><h2 id="JZ21-调整数组顺序使奇数位于偶数前面-一"><a href="#JZ21-调整数组顺序使奇数位于偶数前面-一" class="headerlink" title="JZ21 调整数组顺序使奇数位于偶数前面(一)"></a>JZ21 调整数组顺序使奇数位于偶数前面(一)</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>输入一个长度为 n 整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前面部分，所有的偶数位于数组的后面部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reOrderArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果数组为空或只有一个元素，直接返回原数组</span></span><br><span class="line">        <span class="keyword">if</span>(array.<span class="built_in">size</span>()==<span class="number">0</span> || array.<span class="built_in">size</span>()==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> oddnum=<span class="number">0</span>; <span class="comment">// 确定数组元素为奇数的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;array.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历数组计算奇数个数</span></span><br><span class="line">            <span class="keyword">if</span>(array[i]%<span class="number">2</span> == <span class="number">1</span>) &#123; <span class="comment">// 数组元素为奇数</span></span><br><span class="line">                oddnum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(array.size())</span></span>; <span class="comment">// 初始化结果数组大小</span></span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;array.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历数组</span></span><br><span class="line">            <span class="keyword">if</span>(array[i]%<span class="number">2</span> == <span class="number">1</span>) &#123; <span class="comment">// 数组元素为奇数，则放在res数组前面</span></span><br><span class="line">                res[index] = array[i];</span><br><span class="line">                index++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[oddnum] = array[i]; <span class="comment">// 数组元素为偶数，则放在res数组后面，按顺序放置</span></span><br><span class="line">                oddnum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度"><a href="#算法思路-amp-步骤-amp-时空复杂度" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><ul><li>代码功能</li></ul><p>给定一个整型数组 <code>array</code>，将其中的奇数放在前面，偶数放在后面，保持原有的相对顺序不变，返回重新排列后的数组。</p><ul><li>算法思路</li></ul><p>这道题是一道比较简单的数组操作题。因为要求奇数和偶数分别在前后，而且要保持顺序不变，所以最直接的想法就是用两个指针分别指向数组头尾，然后往中间遍历。左指针找到第一个偶数，右指针找到第一个奇数，然后交换它们。</p><p>但是这道题有个要求是要保证奇数之间和偶数之间的相对顺序不变。因此，我们不能像上述方法一样直接交换数字。</p><p>我们可以开辟一个长度为n的数组<code>res</code>，遍历原始数组，统计数组中奇数的个数 <code>oddnum</code>，将所有奇数按顺序放在数组前部，再将剩下的偶数按顺序放在数组后部。</p><p>遍历原始数组时，如果数组元素为奇数，就把它放在<code>res</code>数组的前面，使用变量<code>index</code>记录此时<code>res</code>数组填充位置的下标；否则，就把它放在<code>res</code>数组的后面，使用变量<code>oddnum</code>记录此时<code>res</code>数组填充位置的下标。最后返回<code>res</code>数组即可。</p><ul><li>时间复杂度</li></ul><p>时间复杂度为<code>O(n)</code>，其中n为原始数组的长度，需要遍历两次数组。</p><ul><li>空间复杂度</li></ul><p>空间复杂度为<code>O(n)</code>，需要开辟一个长度为n的res数组来存储重新排列后的数组。</p><h2 id="JZ43-整数中1出现的次数（从1到n整数中1出现的次数）"><a href="#JZ43-整数中1出现的次数（从1到n整数中1出现的次数）" class="headerlink" title="JZ43 整数中1出现的次数（从1到n整数中1出现的次数）"></a>JZ43 整数中1出现的次数（从1到n整数中1出现的次数）</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>输入一个整数 n ，求 1～n 这 n 个整数的十进制表示中 1 出现的次数<br>例如， 1~13 中包含 1 的数字有 1 、 10 、 11 、 12 、 13 因此共出现 6 次</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123; <span class="comment">// 如果n等于0，则直接返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">10</span>) &#123; <span class="comment">// 如果n小于10，则只有一个数字1出现</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// 初始化一个变量sum用于累加数字1出现的次数</span></span><br><span class="line">        <span class="keyword">while</span> (n) &#123; <span class="comment">// 外层循环从n开始递减到1</span></span><br><span class="line">            <span class="type">int</span> temp = n; <span class="comment">// 每次循环将n赋值给temp，用于判断当前数字temp的每一位是否为1</span></span><br><span class="line">            <span class="keyword">while</span> (temp) &#123; <span class="comment">// 内层循环遍历当前数字的每一位</span></span><br><span class="line">                <span class="keyword">if</span> (temp % <span class="number">10</span> == <span class="number">1</span>) &#123; <span class="comment">// 如果当前数字的最低位是1，则sum加1</span></span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">                temp /= <span class="number">10</span>; <span class="comment">// 将当前数字的最低位删除，判断下一位数字是否为1</span></span><br><span class="line">            &#125;</span><br><span class="line">            n--; <span class="comment">// 内层循环结束后，将n减1，继续下一轮循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum; <span class="comment">// 返回sum作为结果，即1到n之间所有数字中数字1出现的总次数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-1"><a href="#算法思路-amp-步骤-amp-时空复杂度-1" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>这段代码的功能是计算从1到给定整数n之间所有数字中，数字1出现的次数。</p><ul><li>如果n等于0，则直接返回0。</li><li>如果n小于10，则表示n为个位数，只有一个数字1出现。</li><li>初始化一个变量sum用于累加数字1出现的次数。</li><li>使用两层循环，外层循环从n开始递减到1，内层循环判断当前数字temp的每一位是否为1，如果是则sum加1。</li><li>内层循环结束后，将n减1，继续下一轮循环。</li><li>最终返回sum作为结果，即1到n之间所有数字中数字1出现的总次数。</li></ul><p>该算法的时间复杂度为O(n*log10(n))，其中n为给定的整数。由于内层循环的迭代次数与n的位数相关，每次迭代需要遍历当前数字的位数次数，而n的位数为log10(n)。空间复杂度为O(1)，只使用了常数级别的额外空间。</p><h2 id="JZ45-把数组排成最小的数"><a href="#JZ45-把数组排成最小的数" class="headerlink" title="JZ45 把数组排成最小的数"></a>JZ45 把数组排成最小的数</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>输入一个非负整数数组numbers，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。<br>例如输入数组[3，32，321]，则打印出这三个数字能排成的最小数字为321323。<br>1.输出结果可能非常大，所以你需要返回一个字符串而不是整数<br>2.拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 自定义排序规则函数，比较x和y拼接后的字符串的大小</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x, <span class="type">const</span> <span class="type">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">to_string</span>(x) + <span class="built_in">to_string</span>(y)) &lt; (<span class="built_in">to_string</span>(y) + <span class="built_in">to_string</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">PrintMinNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (numbers.<span class="built_in">empty</span>()) &#123; <span class="comment">// 如果numbers为空，直接返回空字符串res</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), cmp); <span class="comment">// 使用自定义排序规则对numbers进行升序排序</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历排序后的numbers</span></span><br><span class="line">            res += <span class="built_in">to_string</span>(numbers[i]); <span class="comment">// 将每个数字转换为字符串并拼接到结果字符串res上</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回最终的结果字符串res</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-2"><a href="#算法思路-amp-步骤-amp-时空复杂度-2" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>这段代码是给定一个int类型的vector numbers，要求将numbers中的数字按照特定规则拼接成一个最小的字符串。</p><ul><li>定义一个静态成员函数<code>cmp</code>，用于自定义排序规则。比较两个数字x和y，如果<code>(to_string(x)+to_string(y)) &lt; (to_string(y)+to_string(x))</code>，则x应该排在y之前。</li><li>在主函数<code>PrintMinNumber</code>中，首先定义一个空字符串res作为结果。</li><li>如果numbers为空，直接返回空字符串res。</li><li>使用<code>sort</code>函数对numbers进行排序，排序依据是使用自定义的比较函数<code>cmp</code>。</li><li>遍历排序后的numbers，将每个数字转换为字符串并拼接到res上。</li><li>返回最终的结果字符串res。</li></ul><p>注意，这里的排序规则是基于比较拼接后的字符串的大小来确定数字的顺序，而不是直接比较数字本身的大小。</p><p>该算法的时间复杂度为O(nlogn)，其中n为numbers中的数字个数。排序操作的时间复杂度为O(nlogn)，遍历和拼接字符串的时间复杂度为O(n)。空间复杂度为O(n)，需要额外存储排序后的数字。</p><h2 id="JZ49-丑数"><a href="#JZ49-丑数" class="headerlink" title="JZ49 丑数"></a>JZ49 丑数</h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第 n个丑数。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> res = <span class="number">0</span>; <span class="comment">// 定义一个长整型变量res表示当前找到的第index个丑数，初始化为0。</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt;= <span class="number">0</span>) &#123; <span class="comment">// 如果传入的参数index小于等于0，则直接返回0。</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;<span class="type">long</span>, vector&lt;<span class="type">long</span>&gt;, greater&lt;<span class="type">long</span>&gt;&gt; pq; <span class="comment">// 定义一个小根堆pq，存储目前已经找到的所有丑数，这里使用long类型是因为丑数可能很大。</span></span><br><span class="line">        unordered_map&lt;<span class="type">long</span>, <span class="type">int</span>&gt; mp; <span class="comment">// 定义一个哈希表mp，记录每个丑数出现的次数，避免重复计算相同的丑数。</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; X = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;; <span class="comment">// 定义一个数组X表示因子2、3、5，依次以它们作为因子，生成下一个丑数。</span></span><br><span class="line">        mp[<span class="number">1ll</span>]++; <span class="comment">// 将1加入到mp中，保证pq不为空。</span></span><br><span class="line">        pq.<span class="built_in">push</span>(<span class="number">1ll</span>); <span class="comment">// 将1加入到pq中。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123; <span class="comment">// 循环查找index个丑数。</span></span><br><span class="line">            res = pq.<span class="built_in">top</span>(); <span class="comment">// 取出pq中最小的丑数。</span></span><br><span class="line">            pq.<span class="built_in">pop</span>(); <span class="comment">// 弹出pq中最小的丑数。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123; <span class="comment">// 以因子2、3、5分别生成下一个丑数。</span></span><br><span class="line">                <span class="type">long</span> next = res * X[k]; <span class="comment">// 计算下一个丑数。</span></span><br><span class="line">                <span class="keyword">if</span> (mp.<span class="built_in">find</span>(next) == mp.<span class="built_in">end</span>()) &#123; <span class="comment">// 如果下一个丑数没有出现过，则加入到pq和mp中，避免重复计算相同的丑数。</span></span><br><span class="line">                    pq.<span class="built_in">push</span>(next);</span><br><span class="line">                    mp[next]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)res; <span class="comment">// 返回找到的第index个丑数，注意需要强制类型转换为int类型。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-3"><a href="#算法思路-amp-步骤-amp-时空复杂度-3" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>这段代码是求第index个丑数，即只含有因子2、3、5的正整数中，排在第index位的数。具体思路如下：</p><ul><li>定义一个长整型变量res表示当前找到的第index个丑数，初始化为0。</li><li>如果传入的参数index小于等于0，则直接返回0。</li><li>定义一个小根堆pq和一个哈希表mp，分别用来存储目前已经找到的所有丑数和每个丑数出现的次数。</li><li>定义一个数组X表示因子2、3、5，依次以它们作为因子，生成下一个丑数，并将其加入到pq和mp中。</li><li>直到找到第index个丑数为止。</li></ul><p>因为pq是小根堆，所以每次取出的都是当前最小的丑数，这样就可以保证找到的是按照大小顺序排列的前index个丑数。同时使用哈希表mp可以避免重复计算相同的丑数。</p><p>该算法的时间复杂度为O(nlogn)，其中n为index。每次从pq中取出最小的丑数的时间复杂度是O(logn)，向pq中插入丑数的时间复杂度也是O(logn)。同时，每个丑数最多只会被乘以因子2、3、5一次，因此每个丑数最多会被插入pq中一次，总共插入的次数也是O(nlogn)级别的。空间复杂度为O(n)，需要存储pq和mp中的n个元素。</p><p>最终返回的res值可能会超过int类型范围，因此需要强制类型转换为int类型后再返回。</p><h2 id="JZ74-和为S的连续正数序列"><a href="#JZ74-和为S的连续正数序列" class="headerlink" title="JZ74 和为S的连续正数序列"></a>JZ74 和为S的连续正数序列</h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列?<br>返回值描述：<br>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">FindContinuousSequence</span>(<span class="type">int</span> sum) &#123;</span><br><span class="line">        <span class="comment">// 创建一个结果变量，用于存储所有满足条件的连续序列</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义起始和结束的指针，以及当前序列的和</span></span><br><span class="line">        <span class="type">int</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> end = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> cursum = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 利用双指针在滑动窗口中查找连续序列</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt;= sum / <span class="number">2</span>) &#123;  <span class="comment">// 起始指针最大不超过 sum 的一半</span></span><br><span class="line">            <span class="keyword">if</span> (cursum &lt; sum) &#123;  <span class="comment">// 当前序列和小于目标值，向右扩展窗口</span></span><br><span class="line">                cursum += ++end;  <span class="comment">// 更新当前序列和为原和加上新的数</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cursum &gt; sum) &#123;  <span class="comment">// 当前序列和大于目标值，向左收缩窗口</span></span><br><span class="line">                cursum -= start++;  <span class="comment">// 更新当前序列和为原和减去最左边的数</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 当前序列和等于目标值，满足条件</span></span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; sequence;  <span class="comment">// 创建一个临时存储满足条件的连续序列的变量</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                    sequence.<span class="built_in">push_back</span>(i);  <span class="comment">// 将满足条件的数添加到序列中</span></span><br><span class="line">                &#125;</span><br><span class="line">                res.<span class="built_in">push_back</span>(sequence);  <span class="comment">// 将满足条件的序列添加到结果中</span></span><br><span class="line">                cursum -= start++;  <span class="comment">// 更新当前序列和，并向右滑动窗口</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;  <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-4"><a href="#算法思路-amp-步骤-amp-时空复杂度-4" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>该算法使用双指针的思路来解决问题，具体步骤如下：</p><ol><li>创建一个空的二维数组<code>res</code>，用于存储所有满足条件的连续序列。</li><li>定义起始指针<code>start</code>和结束指针<code>end</code>，初始值都为1，用于表示当前连续序列的范围。</li><li>定义一个变量<code>cursum</code>，用于记录当前连续序列的和，初始值为1（即序列中只有一个数1）。</li><li>进入循环，判断起始指针是否小于等于<code>sum</code>的一半，因为要找到的连续序列至少包含两个数，所以起始指针最大不超过<code>sum</code>的一半。</li><li>在循环中，分三种情况进行处理：<ul><li>如果<code>cursum</code>小于目标值<code>sum</code>，则将结束指针右移，并将当前指向的数加到<code>cursum</code>上，表示扩展序列范围。</li><li>如果<code>cursum</code>大于目标值<code>sum</code>，则将起始指针右移，并将最左边的数从<code>cursum</code>中减去，表示收缩序列范围。</li><li>如果<code>cursum</code>等于目标值<code>sum</code>，则说明找到了一个满足条件的连续序列，将该序列添加到结果列表中。然后将起始指针右移，并将最左边的数从<code>cursum</code>中减去，继续寻找下一个序列。</li></ul></li><li>循环结束后，返回结果数组<code>res</code>。</li></ol><p>该算法的时间复杂度为O(sum)，空间复杂度为O(1)，因为只使用了常数级别的额外空间。</p><h2 id="JZ57-和为S的两个数字"><a href="#JZ57-和为S的两个数字" class="headerlink" title="JZ57 和为S的两个数字"></a>JZ57 和为S的两个数字</h2><h3 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h3><p>输入一个升序数组 array 和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，返回任意一组即可，如果无法找出这样的数字，返回一个空数组即可。</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">FindNumbersWithSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; array, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;                           <span class="comment">// 定义左指针，初始值为数组的起始位置</span></span><br><span class="line">        <span class="type">int</span> right = array.<span class="built_in">size</span>() - <span class="number">1</span>;           <span class="comment">// 定义右指针，初始值为数组的末尾位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;                  <span class="comment">// 循环条件为左指针小于右指针</span></span><br><span class="line">            <span class="keyword">if</span> (array[left] + array[right] &gt; sum) &#123;</span><br><span class="line">                right--;                        <span class="comment">// 当前和过大，将右指针向左移动一位</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[left] + array[right] &lt; sum) &#123;</span><br><span class="line">                left++;                         <span class="comment">// 当前和过小，将左指针向右移动一位</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;array[left], array[right]&#125;;   <span class="comment">// 找到满足条件的两个数，返回它们组成的数组</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;                              <span class="comment">// 没有找到满足条件的两个数，返回空数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-5"><a href="#算法思路-amp-步骤-amp-时空复杂度-5" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>这段代码实现了在给定数组中查找两个数，使其和等于目标值<code>sum</code>。代码通过使用双指针的方法，在有序数组中进行查找。</p><ol><li>定义左指针<code>left</code>初始值为0，表示数组的起始位置。</li><li>定义右指针<code>right</code>初始值为数组的末尾位置。</li><li>进入循环，循环条件为<code>left&lt;right</code>，即左指针小于右指针。</li><li>在循环中，判断<code>array[left] + array[right]</code>与目标值<code>sum</code>的关系：<ul><li>如果<code>array[left] + array[right]</code>大于目标值<code>sum</code>，说明当前和过大，需要将右指针向左移动一位，减小和的值。</li><li>如果<code>array[left] + array[right]</code>小于目标值<code>sum</code>，说明当前和过小，需要将左指针向右移动一位，增大和的值。</li><li>如果<code>array[left] + array[right]</code>等于目标值<code>sum</code>，说明找到了满足条件的两个数，将它们放入一个数组中并返回。</li></ul></li><li>循环结束后，如果没有找到满足条件的两个数，返回一个空数组。</li></ol><p>该算法利用了数组的有序性，通过不断调整左右指针的位置，来逼近目标值<code>sum</code>，从而找到满足条件的两个数。</p><h2 id="JZ58-左旋转字符串"><a href="#JZ58-左旋转字符串" class="headerlink" title="JZ58 左旋转字符串"></a>JZ58 左旋转字符串</h2><h3 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h3><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列  S ，请你把其循环左移 K 位后的序列输出。例如，字符序列 S = ”abcXYZdef” , 要求输出循环左移 3 位后的结果，即 “XYZdefabc”</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">LeftRotateString</span><span class="params">(string str, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.<span class="built_in">empty</span>() || n == <span class="number">0</span> || n % str.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;  <span class="comment">// 特殊情况判断</span></span><br><span class="line">            <span class="keyword">return</span> str;     </span><br><span class="line">        &#125;</span><br><span class="line">        n %= str.<span class="built_in">size</span>();                                   <span class="comment">// 取余操作，避免不必要的重复遍历</span></span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt; str.<span class="built_in">size</span>(); i++) &#123;             <span class="comment">// 从第n个字符开始遍历，将其后的字符添加到新字符串中</span></span><br><span class="line">            res += str[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;                      <span class="comment">// 再次遍历，将前n个字符添加到新字符串中</span></span><br><span class="line">            res += str[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;                                        <span class="comment">// 返回新的字符串res</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-6"><a href="#算法思路-amp-步骤-amp-时空复杂度-6" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>这段代码实现了将给定字符串左旋转n个字符的操作。例如，对于字符串”abcdefg”，左旋转2个字符后得到字符串”cdefgab”。</p><ol><li>判断特殊情况，如果字符串为空或者左旋转的位数为0或者是字符串长度的整数倍，则直接返回原字符串。</li><li>将左旋转的位数对字符串长度取余，避免不必要的重复遍历。</li><li>遍历字符串，将从第n个字符开始的所有字符加入一个新的字符串res中。</li><li>再次遍历字符串，将前n个字符也加入新的字符串res中。</li><li>返回新的字符串res，即为左旋转n个字符的结果。</li></ol><p>该算法通过两次遍历字符串的方式来实现左旋转n个字符的操作，时间复杂度为O(n)，空间复杂度为O(n)。</p><h2 id="JZ62-孩子们的游戏-圆圈中最后剩下的数"><a href="#JZ62-孩子们的游戏-圆圈中最后剩下的数" class="headerlink" title="JZ62 孩子们的游戏(圆圈中最后剩下的数)"></a>JZ62 孩子们的游戏(圆圈中最后剩下的数)</h2><h3 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a>描述</h3><pre><code>每年六一儿童节，牛客都会准备一些小礼物和小游戏去看望孤儿院的孩子们。其中，有个游戏是这样的：首先，让 n 个小朋友们围成一个大圈，小朋友们的编号是0~n-1。然后，随机指定一个数 m ，让编号为0的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌，然后可以在礼品箱中任意的挑选礼物，并且不再回到圈中，从他的下一个小朋友开始，继续0... m-1报数....这样下去....直到剩下最后一个小朋友，可以不用表演，并且拿到牛客礼品，请你试着想下，哪个小朋友会得到这份礼品呢？</code></pre><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">function</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;          <span class="comment">// 辅助递归函数</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;                       <span class="comment">// 当序列中只有一个数字时，直接返回该数字的下标0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">function</span>(n<span class="number">-1</span>,m);          <span class="comment">// 在(n-1)个数字中找到最后剩下的数字的下标，下标从0开始</span></span><br><span class="line">        <span class="keyword">return</span> (x+m)%n;                 <span class="comment">// 根据上一次求得的下标和m计算出在n个数字中最后剩下的数字的下标</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>||m==<span class="number">0</span>)&#123;                 <span class="comment">// 特殊情况判断</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">function</span>(n,m);           <span class="comment">// 返回最后剩下的数字的下标</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-7"><a href="#算法思路-amp-步骤-amp-时空复杂度-7" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>这段代码实现了约瑟夫环问题，即在n个数中，每次从第m个数开始报数，报到m的人出局，最后剩下的那个人的编号。</p><ol><li>对于一个长度为1的序列，只有唯一的一个元素可以被选中，直接返回0。</li><li>对于一个长度为n的序列，将其看作初始状态下从0到n-1编号的n个人围成一圈。</li><li>第一次从第m个人(编号从0开始)开始报数。每报到第m个人时，将其从序列中删除。由于是围成一圈的序列，因此当最后一位被删除后，再从第0位开始继续报数，依次循环直到剩下最后一个人。</li><li>递归求解上述过程，返回最后剩下的那个人的编号。</li></ol><p>该算法通过递归调用来实现约瑟夫环问题的求解，时间复杂度为O(n)，空间复杂度为O(1)。</p><h2 id="JZ75-字符流中第一个不重复的字符"><a href="#JZ75-字符流中第一个不重复的字符" class="headerlink" title="JZ75 字符流中第一个不重复的字符"></a>JZ75 字符流中第一个不重复的字符</h2><h3 id="描述-8"><a href="#描述-8" class="headerlink" title="描述"></a>描述</h3><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 “go” 时，第一个只出现一次的字符是 “g” 。当从该字符流中读出前六个字符 “google” 时，第一个只出现一次的字符是”l”。</p><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string str = <span class="string">&quot;&quot;</span>;                        <span class="comment">// 保存字符流</span></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;             <span class="comment">// 哈希表，记录字符出现次数</span></span><br><span class="line">    queue&lt;<span class="type">char</span>&gt; q;                           <span class="comment">// 队列，保存只出现一次的字符</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">        str += ch;                            <span class="comment">// 将字符加入字符流</span></span><br><span class="line">        mp[ch]++;                             <span class="comment">// 字符出现次数加一</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mp[ch] == <span class="number">1</span>) &#123;                     <span class="comment">// 如果字符在字符流中只出现一次，则加入队列</span></span><br><span class="line">            q.<span class="built_in">push</span>(ch);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                              <span class="comment">// 否则，将队列中已经出现超过一次的字符移除</span></span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; mp[q.<span class="built_in">front</span>()] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">empty</span>()) &#123;                       <span class="comment">// 如果队列为空，则返回 &#x27;#&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">front</span>();                      <span class="comment">// 返回队列头部的字符，即第一个只出现一次的字符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-8"><a href="#算法思路-amp-步骤-amp-时空复杂度-8" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>这段代码实现了一个字符流中第一个只出现一次的字符查找的功能。</p><ol><li>使用一个字符串 <code>str</code> 来保存字符流中的字符。</li><li>使用一个哈希表 <code>mp</code> 来记录每个字符出现的次数。</li><li>使用一个队列 <code>q</code> 来保存只出现一次的字符。当插入一个字符时，如果该字符在 <code>mp</code> 中的出现次数为1，则将其加入队列；否则，将队列中已经出现超过一次的字符移除。</li><li>当需要查询第一个只出现一次的字符时，如果队列为空，则返回 <code>#</code>，否则返回队列的头部元素。</li></ol><h2 id="JZ14-剪绳子"><a href="#JZ14-剪绳子" class="headerlink" title="JZ14 剪绳子"></a>JZ14 剪绳子</h2><h3 id="描述-9"><a href="#描述-9" class="headerlink" title="描述"></a>描述</h3><p>给你一根长度为 n 的绳子，请把绳子剪成整数长的 m 段（ m 、 n 都是整数， n &gt; 1 并且 m &gt; 1 ， m &lt;= n ），每段绳子的长度记为 k[1],…,k[m] 。请问 k[1]<em>k[2]</em>…*k[m] 可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18 。</p><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cutRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) &#123;                        <span class="comment">// 当绳子长度小于等于3时，特殊情况处理</span></span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> numof_3 = n / <span class="number">3</span>;                  <span class="comment">// 绳子可以剪成多少段长度为3的段</span></span><br><span class="line">        <span class="type">int</span> excep = n % <span class="number">3</span>;                    <span class="comment">// 剪完长度为3的段后剩余的绳子长度</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (excep == <span class="number">0</span>) &#123;                     <span class="comment">// 没有剩余，返回3的numof_3次方</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>, numof_3);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (excep == <span class="number">1</span>) &#123;              <span class="comment">// 剩余一个长度为1的绳子，剪一段长度为3的绳子成两段长度为2的绳子</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>, numof_3 - <span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                              <span class="comment">// 剩余一个长度为2的绳子</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>, numof_3) * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-9"><a href="#算法思路-amp-步骤-amp-时空复杂度-9" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>这段代码实现了剪绳子问题，即给定一个长度为n的绳子，将其剪成m段，求这m段绳子的最大乘积。</p><ol><li>当<code>n &lt;= 3</code>时，绳子太短无法剪成多段，最大乘积为<code>n - 1</code>。因此，先判断特殊情况。</li><li>将绳子剪成长度为3的段，可以得到最大的乘积。因此，首先计算绳子可以剪成几段长度为3的段（numof_3）。</li><li>剩余的绳子长度为<code>excep</code>，有三种情况：<ul><li>如果excep为0，说明剪完长度为3的段后没有剩余，直接返回3的numof_3次方。</li><li>如果excep为1，说明剪完长度为3的段后剩下一个长度为1的绳子，将其中一段长度为3的绳子剪成两段长度为2的绳子，返回3的(numof_3 - 1)次方乘以2的平方。</li><li>如果excep为2，说明剪完长度为3的段后剩下一个长度为2的绳子，直接返回3的numof_3次方乘以2。</li></ul></li><li>返回最终的结果。</li></ol><h2 id="JZ83-剪绳子（进阶版）"><a href="#JZ83-剪绳子（进阶版）" class="headerlink" title="JZ83 剪绳子（进阶版）"></a>JZ83 剪绳子（进阶版）</h2><h3 id="描述-10"><a href="#描述-10" class="headerlink" title="描述"></a>描述</h3><p>给你一根长度为 n 的绳子，请把绳子剪成整数长的 m 段（ m 、 n 都是整数， n &gt; 1 并且 m &gt; 1 ， m &lt;= n ），每段绳子的长度记为 k[1],…,k[m] 。请问 k[1]<em>k[2]</em>…*k[m] 可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18 。</p><p>由于答案过大，请对 998244353 取模。</p><h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mod = <span class="number">998244353</span>;  <span class="comment">// 取模运算的模数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速乘法，计算 (x * y) % mod</span></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">quickcf</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, <span class="type">long</span> <span class="type">long</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        x %= mod;   <span class="comment">// 取模运算，使x保持在合理范围内</span></span><br><span class="line">        y %= mod;   <span class="comment">// 取模运算，使y保持在合理范围内</span></span><br><span class="line">        <span class="keyword">while</span> (y) &#123;  <span class="comment">// 当y不为0时循环</span></span><br><span class="line">            <span class="keyword">if</span> (y &amp; <span class="number">1</span>) &#123;  <span class="comment">// 如果y的二进制最低位为1</span></span><br><span class="line">                res += x;  <span class="comment">// 把x加到结果中</span></span><br><span class="line">                res %= mod;  <span class="comment">// 取模运算，保持结果在合理范围内</span></span><br><span class="line">            &#125;</span><br><span class="line">            y = y &gt;&gt; <span class="number">1</span>;  <span class="comment">// 将y右移一位，相当于除以2</span></span><br><span class="line">            x = x &lt;&lt; <span class="number">1</span>;  <span class="comment">// 将x左移一位，相当于乘以2</span></span><br><span class="line">            x %= mod;  <span class="comment">// 取模运算，保持x在合理范围内</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;  <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速幂运算，计算 x 的 y 次方 % mod</span></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">quickm</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, <span class="type">long</span> <span class="type">long</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;  <span class="comment">// 初始化结果为1</span></span><br><span class="line">        <span class="keyword">while</span> (y) &#123;  <span class="comment">// 当y不为0时循环</span></span><br><span class="line">            <span class="keyword">if</span> (y &amp; <span class="number">1</span>) &#123;  <span class="comment">// 如果y的二进制最低位为1</span></span><br><span class="line">                res = <span class="built_in">quickcf</span>(x, res);  <span class="comment">// 计算 x * res % mod，更新结果</span></span><br><span class="line">            &#125;</span><br><span class="line">            y = y &gt;&gt; <span class="number">1</span>;  <span class="comment">// 将y右移一位，相当于除以2</span></span><br><span class="line">            x = <span class="built_in">quickcf</span>(x, x);  <span class="comment">// 计算 x * x % mod，更新x的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;  <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">cutRope</span><span class="params">(<span class="type">long</span> <span class="type">long</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> number - <span class="number">1</span>;  <span class="comment">// 当绳子长度小于等于3时，直接返回绳子长度-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (number % <span class="number">3</span> == <span class="number">0</span>) &#123;  <span class="comment">// 绳子长度为3的倍数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">quickm</span>(<span class="number">3</span>, number / <span class="number">3</span>);  <span class="comment">// 返回 3^(number/3) % mod</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (number % <span class="number">3</span> == <span class="number">1</span>) &#123;  <span class="comment">// 绳子长度 - 1 是 3 的倍数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">quickcf</span>(<span class="number">4</span>, <span class="built_in">quickm</span>(<span class="number">3</span>, number / <span class="number">3</span> - <span class="number">1</span>));  <span class="comment">// 返回 4 * 3^((number/3)-1) % mod</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 绳子长度 - 2 是 3 的倍数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">quickcf</span>(<span class="number">2</span>, <span class="built_in">quickm</span>(<span class="number">3</span>, number / <span class="number">3</span>));  <span class="comment">// 返回 2 * 3^(number/3) % mod</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-10"><a href="#算法思路-amp-步骤-amp-时空复杂度-10" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>这个算法是解决剪绳子问题的，主要思路是利用数学推导和快速幂运算求解。</p><p>剪绳子问题大致描述如下：给定一根长度为n的绳子，把这根绳子剪成m段（m、n都是整数），每段绳子的长度记为k[1], k[2], …, k[m]，请问k[1] * k[2] * … * k[m]的最大乘积是多少？</p><p>为了求解这个问题，我们可以采用贪心算法。由于要求k[1] * k[2] * … * k[m]的最大乘积，我们可以尽量将绳子剪成长度相等的若干段，这样可以得到最大的乘积。具体来说，如果n可以被m整除，则每一段的长度都是n/m，此时得到的乘积最大；如果n不能被m整除，为了得到最大乘积，我们可以把余数尽可能地平均分配到每段中。</p><p>但是在实现过程中，存在一个问题，那就是数值可能太大，会导致计算结果超出机器能表示的范围。因此，我们需要对计算结果进行取模运算。这里，我们选择取模数为998244353。</p><p>为了在程序中高效地处理模运算，我们引入了快速乘法和快速幂运算的概念。快速乘法和快速幂运算都是通过二分法的思想，不断地将计算问题分解成规模更小的子问题，从而大大减少了计算量。通过这些技巧，我们可以在避免溢出的前提下高效地求解剪绳子问题。</p><p>具体步骤如下：</p><ol><li>判断特殊情况：如果绳子长度小于等于3，则直接返回绳子长度减1；</li><li>如果绳子长度为3的倍数，将每段绳子的长度都设为n/3，此时得到的乘积最大，返回3^(n/3) % mod；</li><li>如果绳子长度不是3的倍数，判断余数r：<ul><li>如果r=1，把一段长度为2的绳子加入某一段长度为n/3-1的绳子中，此时每段绳子的长度都是n/3，乘积最大，返回4 * 3^((n/3)-1) % mod；</li><li>如果r=2，把一段长度为1的绳子加入某一段长度为n/3的绳子中，此时每段绳子的长度都是n/3，乘积最大，返回2 * 3^(n/3) % mod。</li></ul></li></ol><p>因为采用了快速幂、快速乘法、取模运算等技巧，这个算法的时间复杂度为O(logn)，空间复杂度为O(1)。</p><h1 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h1><p>期待下篇博客与你相见~</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data structure algorithm problem for trees (1)</title>
      <link href="/2023/09/28/Data-structure-algorithm-problem-for-trees/"/>
      <url>/2023/09/28/Data-structure-algorithm-problem-for-trees/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>话不多说，直接栽树！</p><h2 id="JZ55-二叉树的深度"><a href="#JZ55-二叉树的深度" class="headerlink" title="JZ55 二叉树的深度"></a>JZ55 二叉树的深度</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度，根节点的深度视为 1 。</p><h3 id="代码–递归法"><a href="#代码–递归法" class="headerlink" title="代码–递归法"></a>代码–递归法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果根节点为空，返回深度为0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归计算左子树和右子树的深度，取较大者，并加1表示当前节点的深度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">TreeDepth</span>(pRoot-&gt;left), <span class="built_in">TreeDepth</span>(pRoot-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><p>该代码使用递归的方式计算二叉树的深度。具体步骤如下：</p><ol><li>如果给定根节点 <code>pRoot</code> 为空，返回深度为0。</li><li>递归调用函数 <code>TreeDepth</code> 计算左子树的深度，并递归调用函数 <code>TreeDepth</code> 计算右子树的深度。</li><li>取左子树和右子树深度的较大值，并加1表示当前节点的深度。</li><li>将计算得到的深度作为返回值返回给上层递归调用。</li></ol><h4 id="时间-amp-空间复杂度"><a href="#时间-amp-空间复杂度" class="headerlink" title="时间&amp;空间复杂度"></a>时间&amp;空间复杂度</h4><p>时间复杂度分析：</p><p>该算法对于每个节点都会进行一次递归调用，因此遍历二叉树的所有节点需要 O(n) 的时间，其中 n 是二叉树中节点的个数。</p><p>空间复杂度分析：</p><p>递归调用会使用系统栈空间，当二叉树为平衡二叉树时，递归深度为 O(logn)，因此空间复杂度为 O(logn)。当二叉树为非平衡二叉树时，递归深度最差情况下为 O(n)，因此空间复杂度为 O(n)。</p><p>总结：</p><p>该算法使用递归的方式实现计算给定二叉树的深度，时间复杂度为 O(n)，空间复杂度为 O(logn) 或 O(n)，具体取决于二叉树的形状。递归方法更加简洁，但在处理大规模输入时可能会导致栈溢出，可以考虑使用迭代的方式进行优化。</p><h3 id="代码–迭代法（队列）"><a href="#代码–迭代法（队列）" class="headerlink" title="代码–迭代法（队列）"></a>代码–迭代法（队列）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">// 结果变量初始化为0</span></span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果根节点为空返回深度0</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; queue; <span class="comment">// 定义一个队列，元素类型为树节点类型</span></span><br><span class="line">        queue.<span class="built_in">push</span>(pRoot); <span class="comment">// 根节点入队</span></span><br><span class="line">        TreeNode* node = <span class="literal">nullptr</span>; <span class="comment">// 临时节点用来存取出队的节点</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) &#123; <span class="comment">// 队列不为空</span></span><br><span class="line">            <span class="type">int</span> len = queue.<span class="built_in">size</span>(); <span class="comment">// 获取当前队列的长度，即这一层节点的个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123; <span class="comment">// 遍历该层所有节点</span></span><br><span class="line">                node = queue.<span class="built_in">front</span>(); <span class="comment">// 队头取出一个节点</span></span><br><span class="line">                queue.<span class="built_in">pop</span>(); <span class="comment">// 出队</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123; <span class="comment">// 如果该节点有左子树则入队</span></span><br><span class="line">                    queue.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123; <span class="comment">// 有右子树则入队</span></span><br><span class="line">                    queue.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">// 循环完毕表示上一层的所有节点的孩子节点均已入队，双亲节点全已出队</span></span><br><span class="line">            res++; <span class="comment">// 层数深度+1</span></span><br><span class="line">        &#125;<span class="comment">// 队列为空了说明贯彻到底了</span></span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回结果变量值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h4><p>该代码使用队列迭代的方式实现计算二叉树的深度。具体步骤如下：</p><ol><li>如果给定根节点 <code>pRoot</code> 为空，返回深度为0。</li><li>定义一个队列 <code>queue</code> ，将根节点入队。</li><li>定义一个变量 <code>res</code> 保存当前层数，初始化为0。</li><li>循环遍历队列中的所有节点，并取出队头元素 <code>node</code> ：<ul><li>如果 <code>node</code> 的左子树不为空，则将其左子树入队；</li><li>如果 <code>node</code> 的右子树不为空，则将其右子树入队。</li></ul></li><li>遍历完队列中的所有节点后，层数加1。</li><li>如果队列不为空，则继续执行第4步；否则，退出循环并返回结果变量 <code>res</code>。</li></ol><h4 id="时间-amp-空间复杂度-1"><a href="#时间-amp-空间复杂度-1" class="headerlink" title="时间&amp;空间复杂度"></a>时间&amp;空间复杂度</h4><ul><li>时间复杂度分析：<br>该算法需要遍历二叉树中所有节点一次，因此时间复杂度为 O(n)。</li><li>空间复杂度分析：<br>该算法使用了一个队列来存储二叉树中每一层的节点。当二叉树为平衡二叉树时，队列中最多同时存储两层节点，因此空间复杂度为 O(2^(logn+1))=O(n)，其中 n 是二叉树中节点的个数。<br>当二叉树为非平衡二叉树时，队列中最多同时存储 n-1 个节点，因此空间复杂度为 O(n)。</li></ul><p>总结：</p><p>该算法使用了队列迭代的方式实现计算给定二叉树的深度，时间复杂度为 O(n)，空间复杂度为 O(n)。</p><h2 id="JZ32-从上往下打印二叉树"><a href="#JZ32-从上往下打印二叉树" class="headerlink" title="JZ32 从上往下打印二叉树"></a>JZ32 从上往下打印二叉树</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>不分行从上往下打印出二叉树的每个节点，同层节点从左至右打印。例如输入{8,6,10,#,#,2,1}，如以下图中的示例二叉树，则依次打印8,6,10,2,1(空节点不打印，跳过)，请你将打印的结果存放到一个数组里面，返回。</p><h3 id="代码–迭代法（队列）-1"><a href="#代码–迭代法（队列）-1" class="headerlink" title="代码–迭代法（队列）"></a>代码–迭代法（队列）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res; <span class="comment">// 定义一个空的 vector，用于保存遍历结果</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果树为空，直接返回空 vector</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; queue; <span class="comment">// 定义一个队列，元素类型为树节点类型</span></span><br><span class="line">        queue.<span class="built_in">push</span>(root); <span class="comment">// 根节点入队</span></span><br><span class="line">        TreeNode* node = <span class="literal">nullptr</span>; <span class="comment">// 临时节点用来存取出队的节点</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) &#123; <span class="comment">// 如果队列非空，说明还有节点未遍历完成</span></span><br><span class="line">            <span class="type">int</span> len = queue.<span class="built_in">size</span>(); <span class="comment">// 获取当前队列的长度，即这一层节点的个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123; <span class="comment">// 遍历该层所有节点</span></span><br><span class="line">                node = queue.<span class="built_in">front</span>(); <span class="comment">// 队头取出一个节点</span></span><br><span class="line">                queue.<span class="built_in">pop</span>(); <span class="comment">// 出队</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">// 将取出节点的值加入到 vector 中</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123; <span class="comment">// 如果该节点有左子树则入队</span></span><br><span class="line">                    queue.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123; <span class="comment">// 有右子树则入队</span></span><br><span class="line">                    queue.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// 循环完毕表示上一层的所有节点的孩子节点均已入队，双亲节点全已出队</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回 vector</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-2"><a href="#算法思路-2" class="headerlink" title="算法思路"></a>算法思路</h4><p>该代码使用队列的方式对二叉树进行按层遍历，并将遍历结果保存在 vector 中。具体步骤如下：</p><ol><li>如果给定根节点 <code>root</code> 为空，返回空 vector。</li><li>定义一个空的 vector <code>res</code>，用于保存遍历结果。</li><li>定义一个队列 <code>queue</code>，元素类型为 TreeNode 指针。</li><li>将根节点入队。</li><li>当队列非空时，重复执行以下步骤：<ul><li>获取当前队列的长度 <code>len</code>（即待处理节点的数量）。</li><li>遍历队列中前 <code>len</code> 个节点，依次执行以下步骤：<ul><li>取出队头元素 <code>node</code>。</li><li>将 <code>node</code> 的值加入到 vector <code>res</code> 中。</li><li>如果 <code>node</code> 的左子树不为空，则将其左子树入队。</li><li>如果 <code>node</code> 的右子树不为空，则将其右子树入队。</li></ul></li></ul></li><li>遍历完所有节点后，返回 vector <code>res</code>。</li></ol><h4 id="时间-amp-空间复杂度-2"><a href="#时间-amp-空间复杂度-2" class="headerlink" title="时间&amp;空间复杂度"></a>时间&amp;空间复杂度</h4><ul><li>时间复杂度分析：</li></ul><p>该算法需要处理二叉树中每个节点一次，因此时间复杂度为 O(n)，其中 n 是二叉树中节点的个数。</p><ul><li>空间复杂度分析：</li></ul><p>该算法需要使用队列存储每一层的节点，队列中最多会同时存储一层节点，因此空间复杂度为 O(n)。</p><p>总结：</p><p>该算法使用队列的方式按层遍历给定二叉树，并将遍历结果保存在 vector 中。代码简洁，易于理解，时间复杂度为 O(n)，空间复杂度为 O(n)。</p><h2 id="JZ77-按之字形顺序打印二叉树"><a href="#JZ77-按之字形顺序打印二叉树" class="headerlink" title="JZ77 按之字形顺序打印二叉树"></a>JZ77 按之字形顺序打印二叉树</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）</p><h3 id="代码–迭代法（队列）-2"><a href="#代码–迭代法（队列）-2" class="headerlink" title="代码–迭代法（队列）"></a>代码–迭代法（队列）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">Print</span>(TreeNode* pRoot) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res; <span class="comment">// 定义一个空的二维向量，用于保存遍历结果</span></span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果树为空，直接返回空二维向量</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; queue; <span class="comment">// 定义一个队列，元素类型为树节点类型</span></span><br><span class="line">        queue.<span class="built_in">push</span>(pRoot); <span class="comment">// 根节点入队</span></span><br><span class="line">        TreeNode* node = <span class="literal">nullptr</span>; <span class="comment">// 临时节点用来存取出队的节点</span></span><br><span class="line">        <span class="type">bool</span> isrtl = <span class="literal">false</span>; <span class="comment">// 用于表示是否需要反转当前层的节点值</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) &#123; <span class="comment">// 如果队列非空，说明还有节点未遍历完成</span></span><br><span class="line">            <span class="type">int</span> len = queue.<span class="built_in">size</span>(); <span class="comment">// 获取当前队列的长度，即这一层节点的个数</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; temp; <span class="comment">// 用于存储当前层的节点值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123; <span class="comment">// 遍历该层所有节点</span></span><br><span class="line">                node = queue.<span class="built_in">front</span>(); <span class="comment">// 队头取出一个节点</span></span><br><span class="line">                queue.<span class="built_in">pop</span>(); <span class="comment">// 出队</span></span><br><span class="line">                temp.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">// 将取出节点的值加入到当前层的子向量中</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123; <span class="comment">// 如果该节点有左子树则入队</span></span><br><span class="line">                    queue.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123; <span class="comment">// 有右子树则入队</span></span><br><span class="line">                    queue.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// 循环完毕表示上一层的所有节点的孩子节点均已入队，双亲节点全已出队</span></span><br><span class="line">            <span class="keyword">if</span> (isrtl) &#123; <span class="comment">// 如果需要反转当前层的节点值，则进行反转操作</span></span><br><span class="line">                <span class="built_in">reverse</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp); <span class="comment">// 将当前层的节点值保存到二维向量中</span></span><br><span class="line">            isrtl = !isrtl; <span class="comment">// 切换是否需要反转的标志</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回二维向量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-3"><a href="#算法思路-3" class="headerlink" title="算法思路"></a>算法思路</h4><p>该代码使用队列的方式对二叉树进行按层遍历，并将每一层的节点值存储在不同的子向量中，最后返回二维向量。具体步骤如下：</p><ol><li>如果给定根节点 <code>pRoot</code> 为空，返回空的二维向量。</li><li>定义一个空的二维向量 <code>res</code>，用于保存遍历结果。</li><li>定义一个队列 <code>queue</code>，元素类型为 TreeNode 指针。</li><li>将根节点入队。</li><li>当队列非空时，重复执行以下步骤：<ul><li>获取当前队列的长度 <code>len</code>（即待处理节点的数量）。</li><li>定义一个空的向量 <code>temp</code>，用于存储当前层的节点值。</li><li>遍历队列中前 <code>len</code> 个节点，依次执行以下步骤：<ul><li>取出队头元素 <code>node</code>。</li><li>将 <code>node</code> 的值加入到向量 <code>temp</code> 中。</li><li>如果 <code>node</code> 的左子树不为空，则将其左子树入队。</li><li>如果 <code>node</code> 的右子树不为空，则将其右子树入队。</li></ul></li><li>如果需要反转当前层的节点值（通过标志 <code>isrtl</code> 判断），则进行反转操作。</li><li>将向量 <code>temp</code> 存入二维向量 <code>res</code> 中。</li><li>切换是否需要反转的标志 <code>isrtl</code>。</li></ul></li><li>遍历完所有节点后，返回二维向量 <code>res</code>。</li></ol><h4 id="时间-amp-空间复杂度-3"><a href="#时间-amp-空间复杂度-3" class="headerlink" title="时间&amp;空间复杂度"></a>时间&amp;空间复杂度</h4><ul><li>时间复杂度分析：</li></ul><p>该算法需要处理二叉树中每个节点一次，因此时间复杂度为 O(n)，其中 n 是二叉树中节点的个数。</p><ul><li>空间复杂度分析：</li></ul><p>该算法需要使用队列存储每一层的节点和一个临时向量存储当前层的节点值，队列中最多会同时存储一层节点，因此空间复杂度为 O(n)。</p><p>总结：</p><p>该算法使用队列的方式按层遍历给定二叉树，并将每一层的节点值存储在不同的子向量中，最后返回二维向量。代码简洁，易于理解，时间复杂度为 O(n)，空间复杂度为 O(n)。</p><h2 id="JZ78-把二叉树打印成多行"><a href="#JZ78-把二叉树打印成多行" class="headerlink" title="JZ78 把二叉树打印成多行"></a>JZ78 把二叉树打印成多行</h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>给定一个节点数为 n 二叉树，要求从上到下按层打印二叉树的 val 值，同一层结点从左至右输出，每一层输出一行，将输出的结果存放到一个二维数组中返回。</p><h3 id="代码–迭代法（队列）-3"><a href="#代码–迭代法（队列）-3" class="headerlink" title="代码–迭代法（队列）"></a>代码–迭代法（队列）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">Print</span>(TreeNode* pRoot) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res; <span class="comment">// 定义一个空的二维向量，用于保存遍历结果</span></span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果根节点为空，直接返回空二维向量</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; queue; <span class="comment">// 定义一个队列，元素类型为树节点类型的指针</span></span><br><span class="line">        queue.<span class="built_in">push</span>(pRoot); <span class="comment">// 根节点入队</span></span><br><span class="line">        TreeNode* node = <span class="literal">nullptr</span>; <span class="comment">// 临时节点用来存取出队的节点</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) &#123; <span class="comment">// 如果队列非空，说明还有节点未遍历完成</span></span><br><span class="line">            <span class="type">int</span> len = queue.<span class="built_in">size</span>(); <span class="comment">// 获取当前队列的长度，即这一层节点的个数</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; temp; <span class="comment">// 用于存储当前层的节点值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123; <span class="comment">// 遍历该层所有节点</span></span><br><span class="line">                node = queue.<span class="built_in">front</span>(); <span class="comment">// 队头取出一个节点</span></span><br><span class="line">                queue.<span class="built_in">pop</span>(); <span class="comment">// 出队</span></span><br><span class="line">                temp.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">// 将取出节点的值加入到当前层的子向量中</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123; <span class="comment">// 如果该节点有左子树则入队</span></span><br><span class="line">                    queue.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123; <span class="comment">// 如果该节点有右子树则入队</span></span><br><span class="line">                    queue.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp); <span class="comment">// 将当前层的节点值保存到二维向量中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回二维向量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-4"><a href="#算法思路-4" class="headerlink" title="算法思路"></a>算法思路</h4><p>该代码使用队列的方式对二叉树进行按层遍历，并将每一层的节点值存储在不同的子向量中，最后返回二维向量。</p><p>具体步骤如下：</p><ol><li>如果给定的根节点 <code>pRoot</code> 为空，直接返回空的二维向量 <code>res</code>。</li><li>定义一个空的二维向量 <code>res</code>，用于保存遍历结果。</li><li>如果根节点不为空，执行以下步骤：<ul><li>定义一个队列 <code>queue</code>，元素类型为指向树节点的指针。</li><li>将根节点 <code>pRoot</code> 入队。</li><li>定义一个临时节点指针 <code>node</code>。</li><li>当队列非空时，重复执行以下步骤：<ul><li>获取当前队列的长度 <code>len</code>，即当前层的节点个数。</li><li>定义一个空的向量 <code>temp</code>，用于存储当前层的节点值。</li><li>遍历队列中的前 <code>len</code> 个节点，依次执行以下步骤：<ul><li>将队头节点出队并赋值给 <code>node</code>。</li><li>将 <code>node</code> 的值加入到向量 <code>temp</code> 中。</li><li>如果 <code>node</code> 的左子树不为空，将左子树入队。</li><li>如果 <code>node</code> 的右子树不为空，将右子树入队。</li></ul></li><li>将向量 <code>temp</code> 存入二维向量 <code>res</code> 中，表示当前层的节点值。</li></ul></li></ul></li><li>返回二维向量 <code>res</code>。</li></ol><h4 id="时间-amp-空间复杂度-4"><a href="#时间-amp-空间复杂度-4" class="headerlink" title="时间&amp;空间复杂度"></a>时间&amp;空间复杂度</h4><ul><li>时间复杂度分析：</li></ul><p>该算法需要处理二叉树中每个节点一次，因此时间复杂度为 O(n)，其中 n 是二叉树中节点的个数。</p><ul><li>空间复杂度分析：</li></ul><p>该算法需要使用队列存储每一层的节点和一个临时向量存储当前层的节点值，队列中最多会同时存储一层节点，因此空间复杂度为 O(n)。</p><p>总结：</p><p>该代码使用队列的方式按层遍历给定二叉树，并将每一层的节点值存储在不同的子向量中，最后返回二维向量。代码简洁，易于理解，时间复杂度为 O(n)，空间复杂度为 O(n)。</p><h2 id="111-二叉树的最小深度（LeetCode-热题）"><a href="#111-二叉树的最小深度（LeetCode-热题）" class="headerlink" title="111. 二叉树的最小深度（LeetCode 热题）"></a>111. 二叉树的最小深度（LeetCode 热题）</h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明：叶子节点是指没有子节点的节点。</p><h3 id="代码–迭代法（队列）-4"><a href="#代码–迭代法（队列）-4" class="headerlink" title="代码–迭代法（队列）"></a>代码–迭代法（队列）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义变量 res 用于保存最小深度，初始化为0</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果根节点为空，则直接返回0作为最小深度</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个队列 queue 存储节点指针，并将根节点入队</span></span><br><span class="line">        queue&lt;TreeNode*&gt; queue;</span><br><span class="line">        queue.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="comment">// 设定初始深度为1，即根节点所在的层级</span></span><br><span class="line">        res = <span class="number">1</span>;</span><br><span class="line">        TreeNode* node = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 进入循环，直到队列为空</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 获取当前队列的长度 len，表示当前层级的节点个数</span></span><br><span class="line">            <span class="type">int</span> len = queue.<span class="built_in">size</span>();</span><br><span class="line">            <span class="comment">// 遍历当前层级的所有节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="comment">// 取出队头节点并赋值给 node</span></span><br><span class="line">                node = queue.<span class="built_in">front</span>();</span><br><span class="line">                queue.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 如果 node 是叶子节点（左右子树都为空），则返回当前深度 res</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果 node 的左子树不为空，则将左子树入队</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                    queue.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果 node 的右子树不为空，则将右子树入队</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                    queue.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每遍历完一层，深度 res 加1</span></span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若循环结束仍未返回最小深度，则返回 res</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-5"><a href="#算法思路-5" class="headerlink" title="算法思路"></a>算法思路</h4><ol><li>首先定义一个变量 <code>res</code> 用于保存最小深度，初始化为0。</li><li>如果根节点为空，则直接返回0作为最小深度。</li><li>创建一个队列 <code>queue</code> 存储节点指针，并将根节点入队。</li><li>设定初始深度为1，即根节点所在的层级。</li><li>进入循环，直到队列为空：<ul><li>获取当前队列的长度 <code>len</code>，表示当前层级的节点个数。</li><li>遍历当前层级的所有节点：<ul><li>取出队头节点并赋值给 <code>node</code>。</li><li>如果 <code>node</code> 是叶子节点（左右子树都为空），则返回当前深度 <code>res</code>。</li><li>如果 <code>node</code> 的左子树不为空，则将左子树入队。</li><li>如果 <code>node</code> 的右子树不为空，则将右子树入队。</li></ul></li><li>每遍历完一层，深度 <code>res</code> 加1。</li></ul></li><li>若循环结束仍未返回最小深度，则返回 <code>res</code>。</li></ol><h4 id="时间-amp-空间复杂度-5"><a href="#时间-amp-空间复杂度-5" class="headerlink" title="时间&amp;空间复杂度"></a>时间&amp;空间复杂度</h4><p>这段代码的时间复杂度为 O(n)，其中 n 是二叉树的节点数量。空间复杂度为 O(m)，其中 m 是队列中最多同时存储的节点数量，即一层的最大节点数。</p><h1 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h1><p>期待下篇博客与你相见~</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bulk algorithm questions (1)</title>
      <link href="/2023/09/27/Bulk-algorithm-questions/"/>
      <url>/2023/09/27/Bulk-algorithm-questions/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>话不多说，直接开干！</p><h2 id="JZ66-构建乘积数组"><a href="#JZ66-构建乘积数组" class="headerlink" title="JZ66 构建乘积数组"></a>JZ66 构建乘积数组</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个数组 A[0,1,…,n-1] ,请构建一个数组 B[0,1,…,n-1] ,其中 B 的元素 B[i]=A[0]<em>A[1]</em>…*A[i-1]<em>A[i+1]</em>…*A[n-1]（除 A[i] 以外的全部元素的的乘积）。程序中不能使用除法。（注意：规定 B[0] = A[1] * A[2] * … * A[n-1]，B[n-1] = A[0] * A[1] * … * A[n-2]）<br>对于 A 长度为 1 的情况，B 无意义，故而无法构建，用例中不包括这种情况。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">multiply</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = A.<span class="built_in">size</span>(); <span class="comment">// 获取输入vector的长度</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(len, <span class="number">1</span>)</span></span>; <span class="comment">// 创建一个长度为len的新vector，并初始化为1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历一遍输入vector，计算每个位置之前所有元素的乘积并保存到输出vector中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] * A[i - <span class="number">1</span>]; <span class="comment">// 当前位置的值等于前一个位置的值乘以前一个位置对应的输入vector元素</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> temp = <span class="number">1</span>; <span class="comment">// 用于记录当前元素之后所有元素的乘积的临时变量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从后往前遍历一遍输入vector</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res[i] *= temp; <span class="comment">// 当前位置的值乘以temp，即为除了当前元素之外其他元素的乘积</span></span><br><span class="line">            temp *= A[i]; <span class="comment">// 更新temp，将当前位置对应的输入vector元素乘入temp中</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回结果vector</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度"><a href="#算法思路-amp-步骤-amp-时空复杂度" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>该算法是一种巧妙的利用乘积的性质来计算每个位置之前和之后所有元素的乘积的方法。</p><p>算法的主要思路如下：</p><ol><li><p>首先创建一个结果vector <code>res</code>，长度与输入vector <code>A</code> 相同，且每个元素初始化为1。这是因为我们要计算每个位置上除了自身之外其他元素的乘积，初始值设为1便于后续计算。</p></li><li><p>第一个循环，从左到右遍历输入vector <code>A</code>，计算每个位置之前所有元素的乘积。对于 <code>res[i]</code> 来说，它等于 <code>res[i-1] * A[i-1]</code>，即它的前一个位置的值乘以前一个位置对应的 <code>A</code> 中的元素。这样就得到了每个位置之前所有元素的乘积。</p></li><li><p>第二个循环，从右到左遍历输入vector <code>A</code>，计算每个位置之后所有元素的乘积，并与之前遍历得到的乘积相乘。对于 <code>res[i]</code> 来说，它等于它之前计算得到的值 <code>res[i]</code> 乘以当前位置之后所有元素的乘积。具体做法是使用一个变量 <code>temp</code>，初始值设为1，每次迭代时将其乘以当前位置对应的 <code>A</code> 中的元素，然后将 <code>res[i]</code> 乘以 <code>temp</code> 得到最终结果。</p></li><li><p>返回结果vector <code>res</code>。</p></li></ol><p>这种算法思路利用了乘积的性质，避免了重复计算，并且只使用了常数级别的额外空间，使得算法的时间复杂度为O(n)，空间复杂度为O(1)。</p><h2 id="JZ50-第一个只出现一次的字符"><a href="#JZ50-第一个只出现一次的字符" class="headerlink" title="JZ50 第一个只出现一次的字符"></a>JZ50 第一个只出现一次的字符</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>在一个长为 字符串中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用unordered_map作为哈希表，存储字符及其出现次数</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一次遍历字符串，统计每个字符出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            hash[str[i]]++;  <span class="comment">// 将字符作为键，出现次数作为值，递增计数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二次遍历字符串，查找第一个出现次数为1的字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash[str[i]] == <span class="number">1</span>) &#123;  <span class="comment">// 如果字符的出现次数为1</span></span><br><span class="line">                <span class="keyword">return</span> i;  <span class="comment">// 返回该字符在字符串中的索引位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 如果没有找到出现次数为1的字符，返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-1"><a href="#算法思路-amp-步骤-amp-时空复杂度-1" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>该代码实现了一个函数 <code>FirstNotRepeatingChar</code>，用于找到字符串中第一个不重复的字符，并返回它在字符串中的索引位置。</p><p>函数使用了一个 <code>unordered_map</code> 数据结构 <code>hash</code>，其中字符为键，出现次数为值。首先，通过遍历字符串 <code>str</code>，统计每个字符出现的次数，将结果保存在 <code>hash</code> 中。</p><p>然后，再次遍历字符串 <code>str</code>，查找第一个出现次数为1的字符。如果找到了，就返回其索引位置；如果遍历完整个字符串都没有找到出现次数为1的字符，就返回-1。</p><p>这个函数的时间复杂度为O(n)，其中n是字符串的长度，因为需要遍历字符串两次。空间复杂度为O(k)，其中k是字符串中不同字符的个数，因为需要使用哈希表存储字符及其出现次数。</p><h2 id="JZ5-替换空格"><a href="#JZ5-替换空格" class="headerlink" title="JZ5 替换空格"></a>JZ5 替换空格</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>请实现一个函数，将一个字符串s中的每个空格替换成“%20”。<br>例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个空字符串</span></span><br><span class="line">        string res;</span><br><span class="line">        <span class="comment">// 如果输入的字符串为空，则直接返回空字符串</span></span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将要替换的字符串存储在str中</span></span><br><span class="line">        string str=<span class="string">&quot;%20&quot;</span>;</span><br><span class="line">        <span class="comment">// 遍历输入字符串s</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">// 如果当前字符是空格</span></span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">// 在res字符串中添加str</span></span><br><span class="line">                res+=str;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 否则，在res字符串中添加s[i]</span></span><br><span class="line">                res+=s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回替换后的结果字符串res</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-2"><a href="#算法思路-amp-步骤-amp-时空复杂度-2" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>这是一段实现替换空格的代码，将字符串中的所有空格替换为”%20”。</p><p>代码首先创建一个空字符串<code>res</code>，用于存储替换后的结果。</p><p>接下来检查输入字符串是否为空。如果为空，直接返回空字符串。</p><p>然后，将要替换的字符串”%20”存储在<code>str</code>中。</p><p>接下来，遍历输入字符串<code>s</code>，如果当前字符是空格，则在<code>res</code>字符串中添加<code>str</code>；否则，在<code>res</code>字符串中添加<code>s[i]</code>。</p><p>最后，返回替换后的结果字符串<code>res</code>。</p><p>该函数的时间复杂度为O(n)，其中n是字符串的长度。因为只需要遍历一次字符串，并且在每个空格处添加3个字符，所以时间复杂度为O(n)。<br>空间复杂度为O(1)，因为只需要额外使用常数级别的空间，不随字符串长度增加而变化。</p><h2 id="JZ39-数组中出现次数超过一半的数字"><a href="#JZ39-数组中出现次数超过一半的数字" class="headerlink" title="JZ39 数组中出现次数超过一半的数字"></a>JZ39 数组中出现次数超过一半的数字</h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>给一个长度为 n 的数组，数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。<br>例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个哈希表，用于记录每个数字出现的次数</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;map;</span><br><span class="line">        <span class="comment">//第一次遍历数组numbers，并在哈希表map中增加维护数字出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="type">int</span> val:numbers)&#123;</span><br><span class="line">            map[val]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二次遍历数组numbers，查找出现次数超过一半的数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="type">int</span> val:numbers)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map[val]&gt;numbers.<span class="built_in">size</span>()/<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">//如果当前数字val的出现次数大于n/2，则返回该数字val</span></span><br><span class="line">                <span class="keyword">return</span> val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有找到满足条件的数字，则返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-3"><a href="#算法思路-amp-步骤-amp-时空复杂度-3" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><ol><li>创建一个无序哈希表<code>（unordered_map）</code>，用于记录每个数字出现的次数。</li><li>遍历输入的数组<code>numbers</code>，对于每个数字<code>val</code>，将其作为键，增加在哈希表<code>map</code>中的值。</li><li>再次遍历数组<code>numbers</code>，对于每个数字<code>val</code>，如果它在<code>map</code>中的次数大于<code>numbers</code>数组长度的一半（即超过一半），则返回该数字<code>val</code>。</li><li>如果没有找到满足条件的数字，则返回0。</li></ol><p>时间复杂度分析：</p><ul><li>第一个循环遍历数组<code>numbers</code>，并在哈希表<code>map</code>中增加值，时间复杂度为<code>O(n)</code>，其中n是数组<code>numbers</code>的长度。</li><li>第二个循环遍历数组<code>numbers</code>，检查每个数字是否超过一半，时间复杂度也为<code>O(n)</code>。<br>因此，总的时间复杂度是<code>O(n)</code>。</li></ul><p>空间复杂度分析：</p><ul><li>哈希表<code>map</code>用来记录每个数字出现的次数，最坏情况下需要存储所有不同的数字和相应的出现次数，所以空间复杂度是<code>O(k)</code>，其中<code>k</code>是不同数字的个数。在最坏情况下，<code>k = n</code>，即数组中的每个数字都是不同的。因此，空间复杂度也可以表示为<code>O(n)</code>。</li></ul><p>综上所述，该算法的时间复杂度为<code>O(n)</code>，空间复杂度为<code>O(n)</code>。</p><h2 id="JZ81-调整数组顺序使奇数位于偶数前面-二"><a href="#JZ81-调整数组顺序使奇数位于偶数前面-二" class="headerlink" title="JZ81 调整数组顺序使奇数位于偶数前面(二)"></a>JZ81 调整数组顺序使奇数位于偶数前面(二)</h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>输入一个长度为 n 整数数组，数组里面可能含有相同的元素，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前面部分，所有的偶数位于数组的后面部分，对奇数和奇数，偶数和偶数之间的相对位置不做要求，但是时间复杂度和空间复杂度必须如下要求。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reOrderArrayTwo</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果数组为空或只有一个元素，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(array.<span class="built_in">size</span>()==<span class="number">0</span>||array.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用双指针left和right分别指向数组的首尾</span></span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=array.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="comment">// 如果左指针指向的是奇数，则继续向右移动左指针</span></span><br><span class="line">            <span class="keyword">if</span>(array[left]%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果右指针指向的是偶数，则继续向左移动右指针</span></span><br><span class="line">            <span class="keyword">if</span>(array[right]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                right--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当左指针指向偶数，右指针指向奇数时，交换两个数的位置，并同时向中间移动指针</span></span><br><span class="line">            <span class="type">int</span> temp=array[left];</span><br><span class="line">            array[left]=array[right];</span><br><span class="line">            array[right]=temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回重新排列后的数组</span></span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-4"><a href="#算法思路-amp-步骤-amp-时空复杂度-4" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><ol><li>首先对特殊情况进行处理，如果数组为空或只有一个元素，则直接返回原数组。</li><li>使用双指针<code>left</code>和<code>right</code>分别初始化为数组的首尾位置。</li><li>进入循环，循环条件为<code>left&lt;right</code>，即左指针小于右指针。</li><li>在循环中，判断左指针指向的数是否为奇数，如果是奇数，则左指针向右移动一位。</li><li>判断右指针指向的数是否为偶数，如果是偶数，则右指针向左移动一位。</li><li>当左指针指向偶数、右指针指向奇数时，交换两个数的位置，并同时向中间移动左右指针。</li><li>循环结束后，返回重新排列后的数组。</li></ol><p>时间复杂度分析：</p><ul><li>该算法使用了双指针，需要遍历整个数组一次，因此时间复杂度为O(n)，其中n是数组的长度。</li></ul><p>空间复杂度分析：</p><ul><li>该算法只使用了常数级别的额外空间，因此空间复杂度为O(1)。</li></ul><p>综上所述，该算法的时间复杂度为<code>O(n)</code>，空间复杂度为<code>O(1)</code>。</p><h2 id="JZ17-打印从1到最大的n位数"><a href="#JZ17-打印从1到最大的n位数" class="headerlink" title="JZ17 打印从1到最大的n位数"></a>JZ17 打印从1到最大的n位数</h2><h3 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h3><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><ol><li>用返回一个整数列表来代替打印</li><li>n 为正整数，0 &lt; n &lt;= 5</li></ol><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 计算最大值</span></span><br><span class="line">        <span class="type">int</span> len=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            len*=<span class="number">10</span>;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用循环遍历1到最大值之间的所有数字，并将其添加到结果数组中</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回结果数组</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-5"><a href="#算法思路-amp-步骤-amp-时空复杂度-5" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><ol><li>首先根据题目要求计算出最大值，最大值为<code>len = 10^n-1</code>。</li><li>使用循环从1开始遍历到最大值之间的所有数字，并将其添加到结果数组中。</li><li>循环结束后，返回结果数组。</li></ol><p>时间复杂度分析：</p><ul><li>该算法需要遍历从1到最大值之间的所有数字，因此时间复杂度为O(10^n)，其中n是最大位数。</li></ul><p>空间复杂度分析：</p><ul><li>该算法只使用了常数级别的额外空间，因此空间复杂度为O(1)。</li></ul><p>综上所述，该算法的时间复杂度为<code>O(10^n)</code>，空间复杂度为<code>O(1)</code>。</p><h1 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h1><p>期待下篇博客与你相见~</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stack and Queue of Sword Finger Offer</title>
      <link href="/2023/09/24/Stack-and-Queue-of-Sword-Finger-Offer/"/>
      <url>/2023/09/24/Stack-and-Queue-of-Sword-Finger-Offer/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>话不多说，直接开干！</p><h2 id="JZ9-用两个栈实现队列"><a href="#JZ9-用两个栈实现队列" class="headerlink" title="JZ9 用两个栈实现队列"></a>JZ9 用两个栈实现队列</h2><h3 id="desc"><a href="#desc" class="headerlink" title="desc."></a>desc.</h3><p>用两个栈来实现一个队列，使用n个元素来完成 n 次在队列尾部插入整数(push)和n次在队列头部删除整数(pop)的功能。<br>队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 向队列中添加元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.<span class="built_in">push</span>(node); <span class="comment">// 直接将元素压入 stack1 中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从队列中取出元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.<span class="built_in">empty</span>()) &#123; <span class="comment">// 如果 stack2 为空，则需要将 stack1 中的元素转移到 stack2</span></span><br><span class="line">            <span class="keyword">while</span> (!stack1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                stack2.<span class="built_in">push</span>(stack1.<span class="built_in">top</span>()); <span class="comment">// 将 stack1 栈顶元素压入 stack2</span></span><br><span class="line">                stack1.<span class="built_in">pop</span>(); <span class="comment">// 弹出 stack1 栈顶元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> temp = stack2.<span class="built_in">top</span>(); <span class="comment">// 弹出 stack2 栈顶元素</span></span><br><span class="line">        stack2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> temp; <span class="comment">// 返回弹出的元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack1; <span class="comment">// 模拟队列的尾部</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack2; <span class="comment">// 模拟队列的头部</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路-amp-步骤"><a href="#思路-amp-步骤" class="headerlink" title="思路&amp;步骤"></a>思路&amp;步骤</h4><p>这段代码实现了一个队列的功能，使用两个栈 <code>stack1</code> 和 <code>stack2</code> 来模拟。其中 <code>push</code> 函数用于向队列中添加元素，<code>pop</code> 函数用于从队列中取出元素。</p><ul><li><code>push</code> 函数直接将元素压入 <code>stack1</code> 中，作为队列的尾部。</li><li><code>pop</code> 函数实现了队列的出队操作。如果 <code>stack2</code> 为空，则需要将 <code>stack1</code> 中的元素依次压入 <code>stack2</code>，这样才能保证从 <code>stack2</code> 中顺序弹出元素，实现队列的先进先出特性。然后从 <code>stack2</code> 中弹出栈顶元素并返回。</li></ul><h4 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h4><p>该算法的时间复杂度为：</p><ul><li><code>push</code> 操作的时间复杂度为 O(1)，即常数时间。</li><li><code>pop</code> 操作的时间复杂度在最坏情况下为 O(n)，其中 n 是队列中的元素个数。需要将 <code>stack1</code> 中的所有元素转移到 <code>stack2</code> 中，但由于每个元素只会从 <code>stack1</code> 转移一次，所以平摊下来，每个操作的时间复杂度是均摊 O(1)。</li></ul><p>该算法的空间复杂度为 O(n)，需要使用额外的栈空间来存储元素。</p><h2 id="JZ30-包含min函数的栈"><a href="#JZ30-包含min函数的栈" class="headerlink" title="JZ30 包含min函数的栈"></a>JZ30 包含min函数的栈</h2><h3 id="desc-1"><a href="#desc-1" class="headerlink" title="desc."></a>desc.</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的 min 函数，输入操作时保证 pop、top 和 min 函数操作时，栈中一定有元素。</p><p>此栈包含的方法有：<br>push(value):将value压入栈中<br>pop():弹出栈顶元素<br>top():获取栈顶元素<br>min():获取栈中最小元素</p><h3 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;stack1; <span class="comment">// 第一个栈用于存储所有元素</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;stack2; <span class="comment">// 第二个栈用于存储每个元素对应的最小值</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        stack1.<span class="built_in">push</span>(value); <span class="comment">// 先将元素压入第一个栈中</span></span><br><span class="line">        <span class="keyword">if</span>(!stack2.<span class="built_in">empty</span>() &amp;&amp; value &gt; stack2.<span class="built_in">top</span>()) &#123; <span class="comment">// 如果当前新元素的值大于等于第二个栈的栈顶元素，则最小值不变，将第二个栈的栈顶元素再次压入栈中</span></span><br><span class="line">            stack2.<span class="built_in">push</span>(stack2.<span class="built_in">top</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则更新最小值，并将新的最小值压入栈中</span></span><br><span class="line">            stack2.<span class="built_in">push</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1.<span class="built_in">pop</span>(); <span class="comment">// 弹出第一个栈的栈顶元素</span></span><br><span class="line">        stack2.<span class="built_in">pop</span>(); <span class="comment">// 弹出第二个栈的栈顶元素，保证两个栈的元素数量相同</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.<span class="built_in">top</span>(); <span class="comment">// 返回第一个栈的栈顶元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack2.<span class="built_in">top</span>(); <span class="comment">// 返回第二个栈的栈顶元素，即栈中的最小值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路-amp-步骤-1"><a href="#思路-amp-步骤-1" class="headerlink" title="思路&amp;步骤"></a>思路&amp;步骤</h4><p>这段代码实现了一个特殊的栈，除了支持基本的 push、pop 和 top 操作之外，还支持在常数时间内返回栈中的最小元素。在这个栈中，每个元素都有自己对应的最小值。</p><ul><li><code>stack1</code> 存储所有的栈元素，用于支持基本的操作。</li><li><code>stack2</code> 存储栈中每个元素对应的最小值。当一个新元素压入栈时，需要判断当前栈中最小值是否被更新，如果被更新，则将新的最小值压入 <code>stack2</code> 中，否则，将当前栈顶元素对应的最小值再次压入 <code>stack2</code> 中，保证每个元素都有对应的最小值。</li><li><code>push</code> 操作首先将元素压入 <code>stack1</code> 中，然后根据当前元素的值是否比 <code>stack2</code> 中的栈顶元素大来决定是否更新最小值，然后将更新后的最小值压入 <code>stack2</code> 中。</li><li><code>pop</code> 操作直接弹出 <code>stack1</code> 和 <code>stack2</code> 的栈顶元素。</li><li><code>top</code> 操作返回 <code>stack1</code> 的栈顶元素。</li><li><code>min</code> 操作返回 <code>stack2</code> 的栈顶元素，即栈中的最小值。</li></ul><h4 id="时空复杂度-1"><a href="#时空复杂度-1" class="headerlink" title="时空复杂度"></a>时空复杂度</h4><p>该算法的时间复杂度为 O(1)，即常数时间，对于每个操作，最多只需要进行一个 push 或者 pop 操作，不会有额外的循环操作。</p><p>该算法的空间复杂度为 O(n)，需要使用两个栈来存储所有元素和每个元素对应的最小值。</p><h2 id="JZ31-栈的压入、弹出序列"><a href="#JZ31-栈的压入、弹出序列" class="headerlink" title="JZ31 栈的压入、弹出序列"></a>JZ31 栈的压入、弹出序列</h2><h3 id="desc-2"><a href="#desc-2" class="headerlink" title="desc."></a>desc.</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。<br>例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。<br>注：pushV 的所有数字均不相同</p><h3 id="solution-2"><a href="#solution-2" class="headerlink" title="solution"></a>solution</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsPopOrder</span><span class="params">(vector&lt;<span class="type">int</span>&gt; pushV, vector&lt;<span class="type">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = pushV.<span class="built_in">size</span>(); <span class="comment">// 获取 pushV 序列的长度，也可以使用 popV 序列的长度作为判断条件</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stack; <span class="comment">// 定义一个空栈用于模拟栈的操作</span></span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// 初始化指针 j，指向 pushV 序列的起始位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 遍历 pushV 序列</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; (stack.<span class="built_in">empty</span>() || stack.<span class="built_in">top</span>() != popV[i])) &#123;</span><br><span class="line">                <span class="comment">// 如果栈为空或者栈顶元素不等于 popV[i]，则将 pushV[j] 元素压入栈中，并将 j 指针后移一位，直到栈顶元素等于 popV[i] 或者 j 越界</span></span><br><span class="line">                stack.<span class="built_in">push</span>(pushV[j]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stack.<span class="built_in">top</span>() == popV[i]) &#123; <span class="comment">// 如果栈顶元素等于 popV[i]，说明可以进行弹出操作</span></span><br><span class="line">                stack.<span class="built_in">pop</span>(); <span class="comment">// 将栈顶元素弹出</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 栈顶元素不等于 popV[i]，栈的弹出顺序不符合要求，返回 false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.<span class="built_in">empty</span>(); <span class="comment">// 遍历结束后，如果栈为空，说明所有的弹出操作都是合法的，返回 true；否则，说明还有元素未被弹出，返回 false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路-amp-步骤-2"><a href="#思路-amp-步骤-2" class="headerlink" title="思路&amp;步骤"></a>思路&amp;步骤</h4><ul><li>首先，定义一个空栈 <code>stack</code> 用于模拟栈的操作。</li><li>使用两个指针 <code>i</code> 和 <code>j</code> 分别指向 <code>pushV</code> 和 <code>popV</code> 序列的起始位置。</li><li>遍历 <code>pushV</code> 序列，对于每个 <code>pushV[i]</code> 的元素，如果栈为空或者栈顶元素不等于 <code>popV[i]</code>，则将 <code>pushV[j]</code> 元素压入栈中，并将 <code>j</code> 指针后移一位，直到栈顶元素等于 <code>popV[i]</code> 或者 <code>j</code> 越界。</li><li>如果栈顶元素等于 <code>popV[i]</code>，说明可以进行弹出操作，将栈顶元素弹出。</li><li>如果栈顶元素不等于 <code>popV[i]</code>，说明栈的弹出顺序不符合要求，返回 <code>false</code>。</li><li>遍历结束后，如果栈为空，说明所有的弹出操作都是合法的，返回 <code>true</code>；否则，说明还有元素未被弹出，返回 <code>false</code>。</li></ul><h4 id="时空复杂度-2"><a href="#时空复杂度-2" class="headerlink" title="时空复杂度"></a>时空复杂度</h4><p>该算法的时间复杂度为 O(n)，其中 n 是 <code>pushV</code> 序列的长度。遍历一次 <code>pushV</code> 和 <code>popV</code> 序列，每个元素最多入栈一次和出栈一次。</p><p>该算法的空间复杂度为 O(n)，使用了一个辅助栈来模拟入栈和出栈的操作。</p><h2 id="JZ73-翻转单词序列"><a href="#JZ73-翻转单词序列" class="headerlink" title="JZ73 翻转单词序列"></a>JZ73 翻转单词序列</h2><h3 id="desc-3"><a href="#desc-3" class="headerlink" title="desc"></a>desc</h3><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。<br>同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“nowcoder. a am I”。<br>后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a nowcoder.”。Cat对一一的翻转这些单词顺序可不在行，<br>你能帮助他么？</p><h3 id="solution-1"><a href="#solution-1" class="headerlink" title="solution-1"></a>solution-1</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">ReverseSentence</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        string restr = <span class="string">&quot;&quot;</span>; <span class="comment">// 创建一个空字符串 restr 用于保存结果</span></span><br><span class="line">        <span class="keyword">if</span> (str.<span class="built_in">size</span>() == <span class="number">0</span>) &#123; <span class="comment">// 判断输入字符串是否为空</span></span><br><span class="line">            <span class="keyword">return</span> restr; <span class="comment">// 如果为空，则直接返回空字符串 restr</span></span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;string&gt; stack; <span class="comment">// 创建一个栈 stack 用于保存每个单词</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历输入字符串</span></span><br><span class="line">            <span class="keyword">if</span> (str[i] != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">// 如果当前字符不是空格</span></span><br><span class="line">                restr += str[i]; <span class="comment">// 将其添加到 restr 中，暂存当前单词</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果当前字符是空格，说明一个单词已经结束</span></span><br><span class="line">                stack.<span class="built_in">push</span>(restr); <span class="comment">// 将 restr 入栈，保存单词</span></span><br><span class="line">                restr = <span class="string">&quot;&quot;</span>; <span class="comment">// 将 restr 清空，准备保存下一个单词</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.<span class="built_in">push</span>(restr); <span class="comment">// 收尾操作，将最后一个单词入栈</span></span><br><span class="line">        restr = <span class="string">&quot;&quot;</span>; <span class="comment">// 将 restr 清空，准备拼接翻转后的结果</span></span><br><span class="line">        <span class="keyword">while</span> (stack.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; !stack.<span class="built_in">empty</span>()) &#123; <span class="comment">// 当栈中至少有两个元素时进行循环</span></span><br><span class="line">            restr += stack.<span class="built_in">top</span>() + <span class="string">&quot; &quot;</span>; <span class="comment">// 从栈顶取出一个单词，并将其与空格拼接到 restr 的末尾</span></span><br><span class="line">            stack.<span class="built_in">pop</span>(); <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        restr += stack.<span class="built_in">top</span>(); <span class="comment">// 单独处理最后一个单词，直接添加到 restr 的末尾</span></span><br><span class="line">        stack.<span class="built_in">pop</span>(); <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">        <span class="keyword">return</span> restr; <span class="comment">// 返回翻转后的结果字符串 restr</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路-amp-步骤-3"><a href="#思路-amp-步骤-3" class="headerlink" title="思路&amp;步骤"></a>思路&amp;步骤</h4><ol><li>创建一个空字符串 <code>restr</code> 用于保存最终的结果。</li><li>判断输入字符串是否为空，如果为空则直接返回空字符串 <code>restr</code>。</li><li>创建一个栈 <code>stack</code> 用于保存每个单词。</li><li>遍历输入字符串，循环中的操作主要如下：<ul><li>如果当前字符不是空格，则说明还在一个单词内部，将其添加到字符串 <code>restr</code> 中。</li><li>如果当前字符是空格，说明一个单词已经结束，将 <code>restr</code> 入栈，并清空 <code>restr</code> 以便保存下一个单词。</li></ul></li><li>最后一个单词后面没有空格分隔符，需要单独处理，将 <code>restr</code> 入栈。</li><li>创建一个空字符串 <code>restr</code> 用于保存翻转后的结果。</li><li>当栈中至少有两个元素时进行循环，循环中的操作主要如下：<ul><li>从栈顶取出一个单词，并将其与一个空格拼接到 <code>restr</code> 的末尾。</li><li>弹出栈顶元素。</li></ul></li><li>循环结束后，栈中只剩下最后一个单词，将其直接添加到 <code>restr</code> 的末尾。</li><li>返回翻转后的结果字符串 <code>restr</code>。</li></ol><h4 id="时空复杂度-3"><a href="#时空复杂度-3" class="headerlink" title="时空复杂度"></a>时空复杂度</h4><p>该算法的时间复杂度是 O(n)，其中 n 是输入字符串的长度。遍历输入字符串需要 O(n) 的时间，入栈和出栈操作的时间复杂度都是 O(1)，因此总的时间复杂度是 O(n)。<br>该算法的空间复杂度也是 O(n)，主要是使用了一个栈来保存每个单词，最坏情况下栈的大小和输入字符串的长度一样，因此空间复杂度是 O(n)。</p><h3 id="solution-2"><a href="#solution-2" class="headerlink" title="solution-2"></a>solution-2</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">ReverseSentence</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = str.<span class="built_in">length</span>();  <span class="comment">// 获取输入字符串的长度，用变量 n 表示</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>()); <span class="comment">// 第一次整体反转字符串 str，将字符串从头到尾进行反转</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">// 循环 i 从 0 开始递增，直到 i 大于等于 n 为止</span></span><br><span class="line">            <span class="type">int</span> j = i;  <span class="comment">// 定义临时变量 j 并将其初始化为 i</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; str[j] != <span class="string">&#x27; &#x27;</span>)  <span class="comment">// 在字符串中寻找一个完整的单词，条件是 j 小于 n 并且当前字符不是空格字符</span></span><br><span class="line">                j++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到一个完整的单词后，使用 reverse() 函数将该单词在字符串 str 中进行反转，反转范围为 [i, j)</span></span><br><span class="line">            <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>() + i, str.<span class="built_in">begin</span>() + j);</span><br><span class="line"></span><br><span class="line">            i = j;  <span class="comment">// 将 i 的值更新为 j，继续下一个单词的查找和反转</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str;  <span class="comment">// 返回反转完成的字符串 str</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路-amp-步骤-4"><a href="#思路-amp-步骤-4" class="headerlink" title="思路&amp;步骤"></a>思路&amp;步骤</h4><p>该代码实现了将输入字符串中的单词进行反转的功能。</p><ol><li>获取输入字符串 <code>str</code> 的长度，用变量 <code>n</code> 表示。</li><li>第一次整体反转字符串 <code>str</code>，使用 <code>reverse()</code> 函数实现，将字符串从头到尾进行反转。</li><li>进入循环，循环变量 <code>i</code> 从 0 开始递增，直到 <code>i</code> 大于等于 <code>n</code> 为止。循环中的操作主要如下：<ul><li>定义临时变量 <code>j</code> 并将其初始化为 <code>i</code>。</li><li>在字符串中寻找一个完整的单词，条件是 <code>j</code> 小于 <code>n</code> 并且当前字符 <code>str[j]</code> 不是空格字符。</li><li>找到一个完整的单词后，使用 <code>reverse()</code> 函数将该单词在字符串 <code>str</code> 中进行反转，反转范围为 [i, j]。</li><li>将 <code>i</code> 的值更新为 <code>j</code>，继续下一个单词的查找和反转。</li></ul></li><li>循环结束后，返回反转完成的字符串 <code>str</code>。</li></ol><h4 id="时空复杂度-4"><a href="#时空复杂度-4" class="headerlink" title="时空复杂度"></a>时空复杂度</h4><p>该算法的时间复杂度为 O(n)，其中 n 是输入字符串 <code>str</code> 的长度。算法中遍历字符串一次，每次遍历的时间复杂度为 O(n)，因此总的时间复杂度是 O(n)。<br>同时，算法只使用了常数个额外空间，空间复杂度为 O(1)。</p><h2 id="JZ59-滑动窗口的最大值"><a href="#JZ59-滑动窗口的最大值" class="headerlink" title="JZ59 滑动窗口的最大值"></a>JZ59 滑动窗口的最大值</h2><h3 id="desc-4"><a href="#desc-4" class="headerlink" title="desc."></a>desc.</h3><p>给定一个长度为 n 的数组 num 和滑动窗口的大小 size ，找出所有滑动窗口里数值的最大值。</p><p>例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}；<br>针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个：<br>{[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}，<br>{2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><p>窗口大于数组长度或窗口长度为0的时候，返回空。</p><h3 id="solution-3"><a href="#solution-3" class="headerlink" title="solution"></a>solution</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxInWindows</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; num, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;                                  <span class="comment">// 创建一个空的结果数组 res，用于保存每个窗口的最大值</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span> || size &gt; num.<span class="built_in">size</span>()) &#123;              <span class="comment">// 如果给定的窗口大小为 0 或者大于输入数组 num 的大小，直接返回空的结果数组 res</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; dq;                                    <span class="comment">// 创建一个双端队列 dq，用于保存当前窗口的可能成为最大值的元素索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;                   <span class="comment">// 遍历输入数组 num 的前 size 个元素</span></span><br><span class="line">            <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; num[i] &gt; num[dq.<span class="built_in">back</span>()]) &#123;  <span class="comment">// 如果双端队列 dq 不为空，并且当前元素 num[i] 大于双端队列中最后一个元素对应的 num 值</span></span><br><span class="line">                dq.<span class="built_in">pop_back</span>();                                 <span class="comment">// 将最后一个元素从双端队列中弹出，保证双端队列中的元素按照降序排列</span></span><br><span class="line">            &#125;</span><br><span class="line">            dq.<span class="built_in">push_back</span>(i);                             <span class="comment">// 将当前元素的索引 i 入队到双端队列 dq 中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = size; i &lt; num.<span class="built_in">size</span>(); i++) &#123;          <span class="comment">// 从第 size 个元素开始遍历输入数组 num</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(num[dq.<span class="built_in">front</span>()]);                   <span class="comment">// 将双端队列 dq 中的第一个元素所对应的 num 值添加到结果数组 res 中，表示当前窗口的最大值</span></span><br><span class="line">            <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">front</span>() &lt;= i - size) &#123;   <span class="comment">// 如果双端队列 dq 不为空，并且双端队列中第一个元素对应的索引小于等于 i - size</span></span><br><span class="line">                dq.<span class="built_in">pop_front</span>();                                <span class="comment">// 说明当前窗口已经不包含双端队列中的第一个元素了，需要将其从双端队列中弹出</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; num[i] &gt; num[dq.<span class="built_in">back</span>()]) &#123;   <span class="comment">// 如果双端队列 dq 不为空，并且当前元素 num[i] 大于双端队列中最后一个元素对应的 num 值</span></span><br><span class="line">                dq.<span class="built_in">pop_back</span>();                                 <span class="comment">// 将最后一个元素从双端队列中弹出，保证双端队列中的元素按照降序排列</span></span><br><span class="line">            &#125;</span><br><span class="line">            dq.<span class="built_in">push_back</span>(i);                             <span class="comment">// 将当前元素的索引 i 入队到双端队列 dq 中</span></span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(num[dq.<span class="built_in">front</span>()]);                    <span class="comment">// 循环结束后，将双端队列 dq 中的第一个元素所对应的 num 值添加到结果数组 res 中，表示最后一个窗口的最大值</span></span><br><span class="line">        <span class="keyword">return</span> res;                                       <span class="comment">// 返回结果数组 res</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路-amp-步骤-5"><a href="#思路-amp-步骤-5" class="headerlink" title="思路&amp;步骤"></a>思路&amp;步骤</h4><p>该代码实现了一个滑动窗口的最大值问题。</p><ol><li>创建一个空的结果数组 <code>res</code>，用于保存每个窗口的最大值。</li><li>如果给定的窗口大小为 0 或者大于输入数组 <code>num</code> 的大小，直接返回空的结果数组 <code>res</code>。</li><li>创建一个双端队列 <code>dq</code>，用于保存当前窗口的可能成为最大值的元素索引。</li><li>遍历输入数组 <code>num</code> 的前 <code>size</code> 个元素，循环中的操作主要如下：<ul><li>如果双端队列 <code>dq</code> 不为空，并且当前元素 <code>num[i]</code> 大于双端队列中最后一个元素对应的 <code>num</code> 值，则将最后一个元素从双端队列中弹出，保证双端队列中的元素按照降序排列。</li><li>将当前元素的索引 <code>i</code> 入队到双端队列 <code>dq</code> 中。</li></ul></li><li>从第 <code>size</code> 个元素开始遍历输入数组 <code>num</code>，循环中的操作主要如下：<ul><li>将双端队列 <code>dq</code> 中的第一个元素所对应的 <code>num</code> 值添加到结果数组 <code>res</code> 中，表示当前窗口的最大值。</li><li>如果双端队列 <code>dq</code> 不为空，并且双端队列中第一个元素对应的索引小于等于 <code>i - size</code>，说明当前窗口已经不包含双端队列中的第一个元素了，需要将其从双端队列中弹出。</li><li>如果双端队列 <code>dq</code> 不为空，并且当前元素 <code>num[i]</code> 大于双端队列中最后一个元素对应的 <code>num</code> 值，则将最后一个元素从双端队列中弹出，保证双端队列中的元素按照降序排列。</li><li>将当前元素的索引 <code>i</code> 入队到双端队列 <code>dq</code> 中。</li></ul></li><li>循环结束后，将双端队列 <code>dq</code> 中的第一个元素所对应的 <code>num</code> 值添加到结果数组 <code>res</code> 中，表示最后一个窗口的最大值。</li><li>返回结果数组 <code>res</code>。</li></ol><h4 id="时空复杂度-5"><a href="#时空复杂度-5" class="headerlink" title="时空复杂度"></a>时空复杂度</h4><p>该算法的时间复杂度为 O(n)，其中 $n$ 是输入数组 <code>num</code> 的大小。算法遍历了输入数组两次，每次遍历的时间复杂度为 O(n)，因此总的时间复杂度是 O(n)。<br>同时，双端队列 <code>dq</code> 的大小不会超过窗口的大小，因此空间复杂度也是 O(n)。</p><h1 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h1><p>期待下篇博客与你相见~</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 队列 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bit Operations of Sword Finger Offer</title>
      <link href="/2023/09/24/Bit-Operations-of-Sword-Finger-Offer/"/>
      <url>/2023/09/24/Bit-Operations-of-Sword-Finger-Offer/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>话不多说，直接开干！</p><h2 id="JZ65-不用加减乘除做加法"><a href="#JZ65-不用加减乘除做加法" class="headerlink" title="JZ65 不用加减乘除做加法"></a>JZ65 不用加减乘除做加法</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// add表示进位值</span></span><br><span class="line">        <span class="type">int</span> add = num2;</span><br><span class="line">        <span class="comment">// sum表示总和</span></span><br><span class="line">        <span class="type">int</span> sum = num1;</span><br><span class="line">        <span class="comment">// 当不再有进位的时候终止循环</span></span><br><span class="line">        <span class="keyword">while</span> (add != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 将每轮的无进位和与进位值做异或求和</span></span><br><span class="line">            <span class="type">int</span> temp = sum ^ add;</span><br><span class="line">            <span class="comment">// 进位值是用与运算产生的</span></span><br><span class="line">            add = (sum &amp; add) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 更新sum为新的和</span></span><br><span class="line">            sum = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤"><a href="#算法思路-amp-步骤" class="headerlink" title="算法思路&amp;步骤"></a>算法思路&amp;步骤</h4><p>这段代码实现了两个整数的加法，但是没有使用”+”运算符，而是通过位运算来实现。</p><ol><li><code>add</code>变量表示进位值，初始值为<code>num2</code>。</li><li><code>sum</code>变量表示总和，初始值为<code>num1</code>。</li><li>使用循环进行加法操作，直到没有进位为止。循环条件是<code>add</code>不等于0。</li><li>在每一轮循环中，将当前的无进位和与进位值做异或运算，得到新的和，并赋值给<code>temp</code>变量。</li><li>进位值通过将当前的和与进位值做与运算，并将结果左移1位得到。</li><li>更新<code>sum</code>为新的和<code>temp</code>。</li><li>当循环结束后，返回最终的和<code>sum</code>作为结果。</li></ol><h4 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h4><ul><li><p>时间复杂度：O(log(max(num1, num2)))，其中<code>num1</code>和<code>num2</code>中较大的数的位数决定了循环的次数。在每次循环中，需要进行与运算、异或运算和左移运算，这些操作都是常数时间复杂度的。因此，整体时间复杂度可以表示为O(log(max(num1, num2)))。</p></li><li><p>空间复杂度：O(1)，算法只使用了固定数量的额外变量，不随输入规模的增加而增加，因此空间复杂度是常数。</p></li></ul><h2 id="JZ15-二进制中1的个数"><a href="#JZ15-二进制中1的个数" class="headerlink" title="JZ15 二进制中1的个数"></a>JZ15 二进制中1的个数</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>输入一个整数 n ，输出该数32位二进制表示中1的个数。其中负数用补码表示。</p><h3 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历32位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 按位比较</span></span><br><span class="line">            <span class="keyword">if</span> ((n &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>)</span><br><span class="line">                res++; <span class="comment">// 如果当前位为1，计数器自增</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-1"><a href="#算法思路-amp-步骤-1" class="headerlink" title="算法思路&amp;步骤"></a>算法思路&amp;步骤</h4><p>这段代码的作用是计算一个整数 <code>n</code> 的二进制表示中 1 的个数。</p><ul><li><code>res</code> 变量用于记录二进制中 1 的个数，初始值为 0。</li><li>使用循环遍历整数 <code>n</code> 的每一位，共 32 位。<code>i</code> 表示当前遍历的位数，从 0 到 31。</li><li>在每一位上，通过将 <code>1</code> 左移 <code>i</code> 位，与 <code>n</code> 做按位与运算，来判断当前位是否为 1。如果结果不为 0，则表示当前位是 1，将 <code>res</code> 自增 1。</li><li>循环结束后，返回 <code>res</code> 即为 <code>n</code> 的二进制表示中 1 的个数。</li></ul><h4 id="时空复杂度-1"><a href="#时空复杂度-1" class="headerlink" title="时空复杂度"></a>时空复杂度</h4><p>该算法的时间复杂度是 O(1)，因为整数的位数是固定的 32 位。<br>空间复杂度是 O(1)，只使用了常数个额外变量。</p><h2 id="JZ16-数值的整数次方"><a href="#JZ16-数值的整数次方" class="headerlink" title="JZ16 数值的整数次方"></a>JZ16 数值的整数次方</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>实现函数 double Power(double base, int exponent)，求base的exponent次方。</p><p>注意：<br>1.保证base和exponent不同时为0。<br>2.不得使用库函数，同时不需要考虑大数问题<br>3.有特殊判题，不用考虑小数点后面0的位数。</p><h3 id="solution-2"><a href="#solution-2" class="headerlink" title="solution"></a>solution</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Power</span><span class="params">(<span class="type">double</span> base, <span class="type">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理负数次方</span></span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            base = <span class="number">1</span> / base; <span class="comment">// 取base的倒数</span></span><br><span class="line">            exponent = -exponent; <span class="comment">// 将exponent变为相反数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 累乘</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; exponent; i++)</span><br><span class="line">            res *= base; <span class="comment">// 每次将base乘以自身</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-2"><a href="#算法思路-amp-步骤-2" class="headerlink" title="算法思路&amp;步骤"></a>算法思路&amp;步骤</h4><p>这段代码的作用是计算一个实数 <code>base</code> 的整数次方 <code>exponent</code>，返回值为 <code>base</code> 的 <code>exponent</code> 次方。</p><ul><li>首先处理负数次方，将 <code>base</code> 变量的值取倒数，然后将 <code>exponent</code> 变量的值变为相反数，这样就可以统一处理负数次方。</li><li>初始化变量 <code>res</code> 为 <code>1.0</code>。</li><li>循环 <code>exponent</code> 次，每次将 <code>base</code> 乘以自身，最后得到 <code>base</code> 的 <code>exponent</code> 次方。</li><li>返回 <code>res</code> 即可得到 <code>base</code> 的 <code>exponent</code> 次方的值。</li></ul><h4 id="时空复杂度-2"><a href="#时空复杂度-2" class="headerlink" title="时空复杂度"></a>时空复杂度</h4><p>该算法的时间复杂度是 O(exponent)，即需要进行 exponent 次乘法运算。<br>空间复杂度是 O(1)，只使用了常数个额外变量。</p><h2 id="JZ56-数组中只出现一次的两个数字"><a href="#JZ56-数组中只出现一次的两个数字" class="headerlink" title="JZ56 数组中只出现一次的两个数字"></a>JZ56 数组中只出现一次的两个数字</h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。<br>提示：输出时按非降序排列。</p><h3 id="solution-3"><a href="#solution-3" class="headerlink" title="solution"></a>solution</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">FindNumsAppearOnce</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用unordered_map来存储数字出现的次数</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储最终结果的vector</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计每个数字出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            map[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出出现一次的数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[nums[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对结果进行排序</span></span><br><span class="line">        <span class="keyword">if</span> (res[<span class="number">0</span>] &lt; res[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;res[<span class="number">1</span>], res[<span class="number">0</span>]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-3"><a href="#算法思路-amp-步骤-3" class="headerlink" title="算法思路&amp;步骤"></a>算法思路&amp;步骤</h4><p>这段代码的作用是找出在一个整数数组中出现了一次的所有数字，并返回一个包含这些数字的 vector。</p><ul><li>定义一个 <code>unordered_map&lt;int, int&gt;</code> 类型的 <code>map</code> 变量，用于存储每个数字出现的次数。</li><li>定义一个 <code>vector&lt;int&gt;</code> 类型的 <code>res</code> 变量，用于存储最终结果。</li><li>遍历整数数组 <code>nums</code>，统计每个数字出现的次数并保存到 <code>map</code> 中。</li><li>再次遍历整数数组 <code>nums</code>，对于每个数字，如果它在 <code>map</code> 中出现的次数为 1，说明它是出现了一次的数字，将其加入到 <code>res</code> 中。</li><li>如果 <code>res</code> 中第一个数比第二个数小，则直接返回 <code>res</code>。否则，将 <code>res</code> 中的两个数调换位置后返回。</li></ul><h4 id="时空复杂度-3"><a href="#时空复杂度-3" class="headerlink" title="时空复杂度"></a>时空复杂度</h4><p>该算法的时间复杂度为 O(N)，其中 N 是整数数组的长度，需要遍历整数数组两次。<br>空间复杂度为 O(N)，需要使用哈希表来存储每个数字出现的次数。</p><h2 id="JZ64-求1-2-3-…-n"><a href="#JZ64-求1-2-3-…-n" class="headerlink" title="JZ64 求1+2+3+…+n"></a>JZ64 求1+2+3+…+n</h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><h3 id="solution-4"><a href="#solution-4" class="headerlink" title="solution"></a>solution</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用短路原理判断 n 是否为 0，如果为 0 则直接返回 0</span></span><br><span class="line">        n &amp;&amp; (n += <span class="built_in">Sum_Solution</span>(n - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-4"><a href="#算法思路-amp-步骤-4" class="headerlink" title="算法思路&amp;步骤"></a>算法思路&amp;步骤</h4><p>这段代码实现的功能是计算 1 到 n 的所有整数的和。</p><ul><li>当 n &gt; 0 时，对 n 进行与运算 (n &amp;&amp;)。因为只有两个操作数都为真时，结果才为真，所以当 n 为 0 时，(n&amp;&amp;) 将返回 0。</li><li>如果 n 不为 0，则执行递归 Sum_Solution(n−1) 并将其加到 n 中。</li><li>递归结束后，将 n 返回。</li></ul><h4 id="时空复杂度-4"><a href="#时空复杂度-4" class="headerlink" title="时空复杂度"></a>时空复杂度</h4><p>该算法的时间复杂度为 O(N)，其中 N 是求和范围内的整数总数。需要递归处理 N 次。<br>空间复杂度为 O(N)，递归深度达到 N 层。</p><p>需要注意的是，该算法使用了短路原理，即当 n 为 0 时，(n &amp;&amp;) 左边的表达式将不再继续计算。这也是递归停止的条件。</p><h1 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h1><p>期待下篇博客与你相见~</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 位运算 </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sequencing of &quot;Sword Finger Offer&quot;</title>
      <link href="/2023/09/24/Sequencing-of-Sword-Finger-Offer/"/>
      <url>/2023/09/24/Sequencing-of-Sword-Finger-Offer/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>话不多说，直接开干！</p><h2 id="JZ3-数组中重复的数字"><a href="#JZ3-数组中重复的数字" class="headerlink" title="JZ3 数组中重复的数字"></a>JZ3 数组中重复的数字</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。<br>数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。<br>例如，如果输入长度为7的数组[2,3,1,0,2,5,3]，那么对应的输出是2或者3。存在不合法的输入的话输出-1</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">duplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map; <span class="comment">// 创建一个无序哈希映射来记录数字出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] &gt;= numbers.<span class="built_in">size</span>()) &#123; <span class="comment">// 数字超出数组长度的范围，返回 -1 表示输入不合法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(map[numbers[i]] &lt; <span class="number">1</span>) &#123; <span class="comment">// 如果数字之前没有出现过，则在哈希映射中记录次数加1</span></span><br><span class="line">                map[numbers[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 数字已经出现过，说明是重复数字，直接返回该数字</span></span><br><span class="line">                <span class="keyword">return</span> numbers[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 数组中没有重复数字，返回 -1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤"><a href="#算法思路-amp-步骤" class="headerlink" title="算法思路&amp;步骤"></a>算法思路&amp;步骤</h4><p>该代码实现了使用哈希表的方法来查找重复数字。代码中的 <code>duplicate</code> 函数接受一个整数向量 <code>numbers</code> 作为输入，并返回重复的数字。</p><p>具体实现步骤如下：</p><ol><li>创建一个无序哈希表 <code>map</code>，用于记录数字的出现次数。</li><li>遍历输入的整数向量 <code>numbers</code>，对于每个数字：<ul><li>如果数字超出了向量长度的范围，表示输入不合法，直接返回-1。</li><li>如果数字在哈希表中的出现次数小于1，则将次数加1。</li><li>如果数字在哈希表中的出现次数已经大于等于1，说明是重复数字，直接返回该数字。</li></ul></li><li>如果数组中没有找到重复数字，则返回-1。</li></ol><p>注意，在代码中使用的是无序哈希表 <code>unordered_map</code>，并且在数字首次出现时将其次数初始化为0。这是因为 <code>unordered_map</code> 在查找一个不存在的键时会自动插入一个默认值，而我们需要判断数字是否是首次出现。</p><h4 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h4><p>该算法的时间复杂度分析：</p><ul><li>哈希映射的插入和查找操作平均情况下的时间复杂度为O(1)。</li><li>遍历整数向量需要线性的时间，即O(n)，其中n是向量的长度。</li></ul><p>因此，该算法的总时间复杂度是O(n)。</p><p>该算法的空间复杂度分析：</p><ul><li>需要使用一个哈希映射来存储数字的出现次数，最坏情况下，哈希映射中可能需要存储所有不同的数字，所以空间复杂度为O(n)。</li><li>不考虑输入向量本身的空间占用，只考虑额外的空间复杂度。</li></ul><p>综上所述，该算法的时间复杂度为<code>O(n)</code>，空间复杂度为<code>O(n)</code>。</p><h2 id="JZ51-数组中的逆序对"><a href="#JZ51-数组中的逆序对" class="headerlink" title="JZ51 数组中的逆序对"></a>JZ51 数组中的逆序对</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。<br>输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P mod 1000000007<br>题目保证输入的数组中没有的相同的数字</p><h3 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="comment">//定义递归函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, vector&lt;<span class="type">int</span>&gt;&amp; data, vector&lt;<span class="type">int</span>&gt;&amp; temp)</span></span>&#123;</span><br><span class="line">        <span class="comment">//停止划分</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)    </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//取中间</span></span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>; </span><br><span class="line">        <span class="comment">//左右划分合并</span></span><br><span class="line">        <span class="comment">//利用递归计算逆序对的数量之和</span></span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">mergeSort</span>(left, mid, data, temp) + <span class="built_in">mergeSort</span>(mid + <span class="number">1</span>, right, data, temp); </span><br><span class="line">        <span class="comment">//防止溢出，对结果取模mod</span></span><br><span class="line">        res %= mod;  </span><br><span class="line">        <span class="type">int</span> i = left, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//将需要排序的部分复制到临时数组temp中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = left; k &lt;= right; k++)</span><br><span class="line">            temp[k] = data[k];</span><br><span class="line">        <span class="comment">//使用双指针法对左右两部分进行合并排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = left; k &lt;= right; k++)&#123;</span><br><span class="line">            <span class="comment">//左半部分已经全部处理完毕，将剩余的右半部分直接复制到原数组。</span></span><br><span class="line">            <span class="keyword">if</span>(i == mid + <span class="number">1</span>)</span><br><span class="line">                data[k] = temp[j++];</span><br><span class="line">            <span class="comment">//右半部分已经全部处理完毕，将剩余的左半部分直接复制到原数组。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == right + <span class="number">1</span> || temp[i] &lt;= temp[j])</span><br><span class="line">                data[k] = temp[i++];</span><br><span class="line">            <span class="comment">//如果左半部分的元素大于右半部分的元素，将右半部分的元素复制到原数组，并统计逆序对数量。</span></span><br><span class="line">            <span class="keyword">else</span>&#123; </span><br><span class="line">                data[k] = temp[j++];</span><br><span class="line">                <span class="comment">//统计逆序对数量</span></span><br><span class="line">                res += mid - i + <span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回合并排序后的结果取模</span></span><br><span class="line">        <span class="keyword">return</span> res % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">InversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; data)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = data.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="comment">//对整个数组进行归并排序和计算逆序对数量</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeSort</span>(<span class="number">0</span>, n - <span class="number">1</span>, data, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度"><a href="#算法思路-amp-步骤-amp-时空复杂度" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>该代码实现了使用归并排序来计算逆序对数量的功能。代码中的 <code>InversePairs</code> 函数接受一个整数向量 <code>data</code> 作为输入，并返回逆序对的数量。</p><p>具体实现步骤如下：</p><ol><li>创建一个全局变量 <code>mod</code>，用于取模操作。</li><li>定义递归函数 <code>mergeSort</code>，该函数用于进行归并排序和计算逆序对数量：<ul><li>如果左右指针相等或者左指针超过右指针，表示停止划分，返回0。</li><li>计算中间位置 <code>mid</code>。</li><li>使用递归调用 <code>mergeSort</code> 对左右两部分进行排序并返回结果之和。</li><li>将结果取模，防止溢出。</li><li>将需要排序的部分复制到临时数组 <code>temp</code> 中。</li><li>使用双指针法对左右两部分进行合并排序：<ul><li>如果左指针 <code>i</code> 超过了中间位置 <code>mid + 1</code>，说明左半部分已经全部处理完毕，将剩余的右半部分直接复制到原数组。</li><li>如果右指针 <code>j</code> 超过了右边界 <code>right + 1</code>，说明右半部分已经全部处理完毕，将剩余的左半部分直接复制到原数组。</li><li>如果左半部分的元素小于等于右半部分的元素，将左半部分的元素复制到原数组。</li><li>如果左半部分的元素大于右半部分的元素，将右半部分的元素复制到原数组，并统计逆序对数量。</li></ul></li><li>返回合并排序后的结果取模。</li></ul></li><li>在 <code>InversePairs</code> 函数中，获取输入向量的长度 <code>n</code>，创建一个辅助数组 <code>res</code>，并通过调用 <code>mergeSort</code> 函数对整个数组进行归并排序和计算逆序对数量。</li></ol><p>该代码利用了归并排序的特性，通过不断地将数组进行划分和合并，最终得到有序的数组，并在合并的过程中统计逆序对的数量。同时通过取模操作防止溢出。</p><p>此代码的时间复杂度为O(nlogn)，空间复杂度为O(n)，其中n是输入向量的长度。</p><h2 id="JZ40-最小的K个数"><a href="#JZ40-最小的K个数" class="headerlink" title="JZ40 最小的K个数"></a>JZ40 最小的K个数</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>给定一个长度为 n 的可能有重复值的数组，找出其中不去重的最小的 k 个数。<br>例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4(任意顺序皆可)。</p><h3 id="solution-1"><a href="#solution-1" class="headerlink" title="solution-1"></a>solution-1</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; input, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个空的结果向量</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="comment">// 检查边界条件</span></span><br><span class="line">        <span class="keyword">if</span> (input.<span class="built_in">empty</span>() || k == <span class="number">0</span> || k &gt; input.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用STL的sort函数对输入向量进行排序</span></span><br><span class="line">        <span class="built_in">sort</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 将排序后的前k个元素添加到结果向量中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回结果向量</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-1"><a href="#算法思路-amp-步骤-amp-时空复杂度-1" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>这段代码实现了一个获取最小的k个数的解决方案，使用了排序算法来对输入向量进行排序，然后将排序后的前k个元素添加到结果向量中并返回结果向量。</p><ol><li>创建一个空的结果向量<code>res</code>。</li><li>检查边界条件，如果数组为空或<code>k</code>为0，或者<code>k</code>大于数组的大小，则返回空的结果向量<code>res</code>。</li><li>使用STL的<code>sort</code>函数对输入向量进行排序，将输入向量从小到大进行排序。</li><li>将排序后的前<code>k</code>个元素依次添加到结果向量<code>res</code>中。</li><li>返回结果向量<code>res</code>。</li></ol><p>该算法的时间复杂度取决于排序的时间复杂度，通常情况下排序算法的时间复杂度为O(nlogn)，其中n是输入向量的大小。空间复杂度则取决于结果向量的大小，为O(k)。</p><h3 id="solution-2"><a href="#solution-2" class="headerlink" title="solution-2"></a>solution-2</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; input, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个空的结果向量</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="comment">// 检查边界条件</span></span><br><span class="line">        <span class="keyword">if</span> (input.<span class="built_in">empty</span>() || k == <span class="number">0</span> || k &gt; input.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个小顶堆</span></span><br><span class="line">        <span class="comment">// 使用greater&lt;int&gt;作为模板参数，使其成为小顶堆</span></span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">        <span class="comment">// 将输入向量中的元素依次添加到小顶堆中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; input.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从小顶堆中取出k个最小值并添加到结果向量中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(pq.<span class="built_in">top</span>());</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回结果向量</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路-amp-步骤-amp-时空复杂度-2"><a href="#算法思路-amp-步骤-amp-时空复杂度-2" class="headerlink" title="算法思路&amp;步骤&amp;时空复杂度"></a>算法思路&amp;步骤&amp;时空复杂度</h4><p>这段代码实现了一个获取最小的k个数的解决方案，使用了小顶堆（优先队列）来维护当前的最小k个元素。</p><ol><li>创建一个空的结果向量<code>res</code>。</li><li>检查边界条件，如果数组为空或<code>k</code>为0，或者<code>k</code>大于数组的大小，则返回空的结果向量<code>res</code>。</li><li>创建一个小顶堆（优先队列），使用<code>greater&lt;int&gt;</code>作为模板参数，使其成为小顶堆。小顶堆将保证堆顶元素为当前堆中的最小值。</li><li>将输入向量中的元素依次添加到小顶堆中。</li><li>从小顶堆中取出k个最小值，并依次添加到结果向量<code>res</code>中。通过<code>pq.top()</code>获取堆顶元素（即最小值），然后使用<code>pq.pop()</code>将堆顶元素弹出。</li><li>返回结果向量<code>res</code>。</li></ol><p>该算法的时间复杂度主要取决于构建小顶堆和获取最小k个元素的操作。构建小顶堆的时间复杂度为O(nlogn)，获取最小k个元素的操作的时间复杂度为O(klogn)。<br>因此，总体的时间复杂度为O(nlogn)，其中n为输入向量的大小。空间复杂度则取决于小顶堆的大小，为O(k)。</p><h3 id="solution-3"><a href="#solution-3" class="headerlink" title="solution-3"></a>solution-3</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; input, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (input.<span class="built_in">empty</span>() || k == <span class="number">0</span> || k &gt; input.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = input.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">Partition</span>(input, left, right);  <span class="comment">// 使用快速选择算法找到第k小的元素的下标</span></span><br><span class="line">        <span class="keyword">while</span> (index != k - <span class="number">1</span>) &#123;  <span class="comment">// 当index等于k-1时，表示已找到最小的k个数</span></span><br><span class="line">            <span class="keyword">if</span> (index &lt; k - <span class="number">1</span>) &#123;  <span class="comment">// 当index小于k-1时，说明第k小的元素在右侧区间，更新左边界为index+1</span></span><br><span class="line">                left = index + <span class="number">1</span>;</span><br><span class="line">                index = <span class="built_in">Partition</span>(input, left, right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 当index大于k-1时，说明第k小的元素在左侧区间，更新右边界为index-1</span></span><br><span class="line">                right = index - <span class="number">1</span>;</span><br><span class="line">                index = <span class="built_in">Partition</span>(input, left, right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">assign</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">begin</span>() + k);  <span class="comment">// 将前k个元素赋值给结果向量res</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pivot = arr[left];  <span class="comment">// 选择左边界作为pivot</span></span><br><span class="line">        <span class="type">int</span> i = left + <span class="number">1</span>;  <span class="comment">// 左指针</span></span><br><span class="line">        <span class="type">int</span> j = right;  <span class="comment">// 右指针</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= j &amp;&amp; arr[i] &lt;= pivot) &#123;  <span class="comment">// 左指针向右移动，直到找到一个大于pivot的元素</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= j &amp;&amp; arr[j] &gt;= pivot) &#123;  <span class="comment">// 右指针向左移动，直到找到一个小于pivot的元素</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) &#123;  <span class="comment">// 如果左指针超过了右指针，表示已经完成一轮Partition</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[j]);  <span class="comment">// 交换arr[i]和arr[j]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(arr[left], arr[j]);  <span class="comment">// 将pivot放到正确的位置上</span></span><br><span class="line">        <span class="keyword">return</span> j;  <span class="comment">// 返回pivot的下标</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h4><ol><li>首先，检查输入是否为空或<code>k</code>为0，并且检查<code>k</code>是否超出了数组的大小，如果满足这些条件，返回空结果。</li><li>初始化左指针<code>left</code>为0，右指针<code>right</code>为数组<code>input</code>的最后一个索引值。</li><li>调用<code>Partition</code>函数，通过一系列的交换操作将数组分为两部分，左侧的元素小于等于<code>pivot</code>，右侧的元素大于等于<code>pivot</code>。函数返回<code>pivot</code>的最终位置<code>index</code>。</li><li>当<code>index</code>不等于<code>k - 1</code>时，根据<code>index</code>与<code>k - 1</code>的大小关系，更新<code>left</code>和<code>right</code>的值，并重新调用<code>Partition</code>函数，直到找到第<code>k</code>小的元素。</li><li>将前<code>k</code>个元素赋值给结果向量<code>res</code>。</li><li>返回结果向量<code>res</code>。</li></ol><h4 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a>算法步骤：</h4><ol><li>检查输入条件，初始化左指针<code>left</code>为0，右指针<code>right</code>为数组最后一个索引。</li><li>调用<code>Partition</code>函数，选择左指针作为<code>pivot</code>，进行一轮划分操作，返回<code>pivot</code>的最终位置<code>index</code>。</li><li>当<code>index</code>不等于<code>k - 1</code>时，根据<code>index</code>与<code>k - 1</code>的大小关系，更新<code>left</code>和<code>right</code>的值，并重新调用<code>Partition</code>函数，直到找到第<code>k</code>小的元素。</li><li>将前<code>k</code>个元素赋值给结果向量<code>res</code>。</li><li>返回结果向量<code>res</code>。</li></ol><h4 id="时空复杂度分析："><a href="#时空复杂度分析：" class="headerlink" title="时空复杂度分析："></a>时空复杂度分析：</h4><ul><li>时间复杂度：快速选择算法的平均时间复杂度为O(n)，其中<code>n</code>是输入数组的大小。这是因为每次划分操作都可以排除一半的元素（类似于快速排序的划分步骤），所以平均时间复杂度为线性时间。</li><li>空间复杂度：除了存储输入数组和结果向量外，算法的额外空间复杂度为O(1)，因为所有的操作都是在原地进行的，没有使用额外的数据结构。</li></ul><h2 id="JZ41-数据流中的中位数"><a href="#JZ41-数据流中的中位数" class="headerlink" title="JZ41 数据流中的中位数"></a>JZ41 数据流中的中位数</h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。<br>如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。<br>我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。<br>示例：<br>输入：  [5,2,3,4,1,6,7,0,8]<br>返回值：”5.00 3.50 3.00 3.50 3.00 3.50 4.00 3.50 4.00 “<br>说明：  数据流里面不断吐出的是5,2,3…,则得到的平均数分别为5,(5+2)/2,3…   </p><h3 id="solution-2"><a href="#solution-2" class="headerlink" title="solution"></a>solution</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 大顶堆，元素数值较小</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; min; </span><br><span class="line">    <span class="comment">// 小顶堆，元素数值都比大顶堆大</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; max;</span><br><span class="line">    <span class="comment">// 维护两个堆，取两个堆顶部即可</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;       </span><br><span class="line">        <span class="comment">// 先加入较小部分 </span></span><br><span class="line">        min.<span class="built_in">push</span>(num);</span><br><span class="line">        <span class="comment">// 将较小部分的最大值取出，送入到较大部分</span></span><br><span class="line">        max.<span class="built_in">push</span>(min.<span class="built_in">top</span>());  </span><br><span class="line">        min.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 平衡两个堆的数量</span></span><br><span class="line">        <span class="keyword">if</span>(min.<span class="built_in">size</span>() &lt; max.<span class="built_in">size</span>())&#123;  </span><br><span class="line">            min.<span class="built_in">push</span>(max.<span class="built_in">top</span>());</span><br><span class="line">            max.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 奇数个</span></span><br><span class="line">        <span class="keyword">if</span>(min.<span class="built_in">size</span>() &gt; max.<span class="built_in">size</span>())  </span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>)min.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 偶数个</span></span><br><span class="line">            <span class="built_in">return</span> (<span class="type">double</span>)(min.<span class="built_in">top</span>() + max.<span class="built_in">top</span>()) / <span class="number">2</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><p>这段代码实现了一个维护两个堆的解决方案，用于动态获取数据流的中位数。</p><ol><li><code>priority_queue</code>是C++标准库中的优先队列（堆），通过使用不同的模板参数可以实现大顶堆和小顶堆。</li><li><code>min</code>是大顶堆，用于存储较大的一半元素。</li><li><code>max</code>是小顶堆，用于存储较小的一半元素。</li><li><code>Insert</code>函数用于向数据流中插入一个元素。<ul><li>首先将元素加入到<code>min</code>堆中。</li><li>然后将<code>min</code>堆的最大值取出，并将其加入到<code>max</code>堆中，以保持<code>max</code>堆的元素都比<code>min</code>堆的元素大。</li><li>最后，如果<code>min</code>堆的大小小于<code>max</code>堆的大小，则将<code>max</code>堆的最小值取出，并将其加入到<code>min</code>堆中，以平衡两个堆的数量。</li></ul></li><li><code>GetMedian</code>函数用于获取当前数据流的中位数。<ul><li>如果<code>min</code>堆的大小大于<code>max</code>堆的大小，则中位数为<code>min</code>堆的堆顶元素。</li><li>否则，中位数为<code>min</code>堆的堆顶元素和<code>max</code>堆的堆顶元素的平均值。</li></ul></li></ol><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li>创建一个大顶堆<code>min</code>和一个小顶堆<code>max</code>，其中<code>min</code>用于存储较大的一半元素，而<code>max</code>用于存储较小的一半元素。</li><li>在插入数据时，先将元素加入到<code>min</code>堆中。</li><li>将<code>min</code>堆的最大值取出，并将其加入到<code>max</code>堆中。这样可以保证<code>max</code>堆的元素都比<code>min</code>堆的元素大。</li><li>如果<code>min</code>堆的大小小于<code>max</code>堆的大小，将<code>max</code>堆的最小值取出，并将其加入到<code>min</code>堆中，以平衡两个堆的数量。</li><li>在获取中位数时，若<code>min</code>堆的大小大于<code>max</code>堆的大小，则中位数为<code>min</code>堆的堆顶元素；否则，中位数为<code>min</code>堆的堆顶元素和<code>max</code>堆的堆顶元素的平均值。</li></ol><h4 id="时空复杂度分析"><a href="#时空复杂度分析" class="headerlink" title="时空复杂度分析"></a>时空复杂度分析</h4><p>该算法保持两个堆的元素数量平衡，插入一个元素的时间复杂度为O(logn)，获取中位数的时间复杂度为O(1)。空间复杂度取决于堆的大小，为O(n)，其中n为插入的元素数量。</p><h1 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h1><p>期待下篇博客与你相见~</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dynamic programming algorithm problem solution（2）</title>
      <link href="/2023/09/18/Dynamic-programming-algorithm-problem-solution-2/"/>
      <url>/2023/09/18/Dynamic-programming-algorithm-problem-solution-2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>篇接上回，继续开干！</p><h2 id="JZ70-矩形覆盖"><a href="#JZ70-矩形覆盖" class="headerlink" title="JZ70 矩形覆盖"></a>JZ70 矩形覆盖</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><img src="http://sc1goen2r.hn-bkt.clouddn.com/dp7.png"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rectCover</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number&lt;=<span class="number">3</span>)&#123; <span class="comment">// 如果number小于等于3，直接返回number本身，因为矩形覆盖方法的数量即为number</span></span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> dpi_2=<span class="number">2</span>,dpi_3=<span class="number">3</span>; <span class="comment">// 定义两个变量，用于保存前两个状态和前一个状态的矩形覆盖方法数量</span></span><br><span class="line">        <span class="type">int</span> result=<span class="number">0</span>; <span class="comment">// 用于保存当前计算得到的矩形覆盖方法数量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">4</span>;i&lt;=number;i++)&#123; <span class="comment">// 从4开始迭代到number</span></span><br><span class="line">            result=dpi_2+dpi_3; <span class="comment">// 当前状态的矩形覆盖方法数量等于前两个状态和前一个状态的数量之和</span></span><br><span class="line">            dpi_2=dpi_3; <span class="comment">// 更新前两个状态的矩形覆盖方法数量，往后移动一位</span></span><br><span class="line">            dpi_3=result; <span class="comment">// 更新前一个状态的矩形覆盖方法数量，往后移动一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回计算得到的结果，即为给定数字number的矩形覆盖方法数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>这段代码是一个经典的斐波那契数列问题的解决方案。函数<code>rectCover</code>用于计算给定数字<code>number</code>的矩形覆盖方法数量。</p><p>首先，代码中判断输入值<code>number</code>是否小于等于3，如果是则直接返回<code>number</code>本身，因为当<code>number</code>为1、2、3时，矩形覆盖方法的数量即为<code>number</code>本身。</p><p>接下来，定义两个变量<code>dpi_2</code>和<code>dpi_3</code>，初始值分别为2和3。之后定义一个结果变量<code>result</code>，用于保存当前计算得到的矩形覆盖方法数量。</p><p>通过循环从4开始迭代到<code>number</code>，在每一次循环中，计算<code>result</code>的值为<code>dpi_2</code>加上<code>dpi_3</code>，然后更新<code>dpi_2</code>和<code>dpi_3</code>的值，使其往后移动一位。</p><p>最后，返回计算得到的<code>result</code>值，即为给定数字<code>number</code>的矩形覆盖方法数量。</p><p>该算法的时间复杂度为O(n)，空间复杂度为O(1)。由于使用了迭代的方式避免了递归带来的额外开销，因此效率较高。</p><h2 id="JZ47-礼物的最大价值"><a href="#JZ47-礼物的最大价值" class="headerlink" title="JZ47 礼物的最大价值"></a>JZ47 礼物的最大价值</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p><img src="http://sc1goen2r.hn-bkt.clouddn.com/dpgift.png"></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(); <span class="comment">// 获取二维数组的行数</span></span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>(); <span class="comment">// 获取二维数组的列数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理第一列，路径只能来自上方</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">            grid[i][<span class="number">0</span>] += grid[i - <span class="number">1</span>][<span class="number">0</span>]; <span class="comment">// 当前位置的值加上上方位置的值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理第一行，路径只能来自左边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            grid[<span class="number">0</span>][i] += grid[<span class="number">0</span>][i - <span class="number">1</span>]; <span class="comment">// 当前位置的值加上左边位置的值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历后续每一个位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 增加来自左边的与上边的之间的较大值</span></span><br><span class="line">                grid[i][j] += <span class="built_in">max</span>(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> grid[m - <span class="number">1</span>][n - <span class="number">1</span>]; <span class="comment">// 返回右下角位置的值，即为最大路径和</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><p>此段代码通过动态规划求解矩阵中从左上角到右下角的路径，使得路径上数字之和最大。</p><p>首先，获取矩阵的行数 <code>m</code> 和列数 <code>n</code>。</p><p>然后，通过两层循环分别处理第一列和第一行的元素。对于第一列来说，路径只能来自上方，因此将当前位置的值加上上方位置的值；对于第一行来说，路径只能来自左边，因此将当前位置的值加上左边位置的值。</p><p>接下来，通过两层循环遍历剩余的位置（不包括第一行和第一列）。对于每一个位置，路径的值等于当前位置的值加上左边位置和上方位置中的较大值。</p><p>最后，返回矩阵右下角位置的值，即为从左上角到右下角路径上数字之和的最大值。</p><p>这段代码使用动态规划的思想，通过逐步计算每个位置的最优解，最终得到整个问题的最优解。时间复杂度为 O(mn)，空间复杂度为 O(1)。</p><h2 id="JZ48-最长不含重复字符的子字符串"><a href="#JZ48-最长不含重复字符的子字符串" class="headerlink" title="JZ48 最长不含重复字符的子字符串"></a>JZ48 最长不含重复字符的子字符串</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p><img src="http://sc1goen2r.hn-bkt.clouddn.com/dp8.png"></p><h3 id="代码–滑动窗口"><a href="#代码–滑动窗口" class="headerlink" title="代码–滑动窗口"></a>代码–滑动窗口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp; <span class="comment">// 哈希表记录窗口内非重复的字符</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">// 最长子串的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; s.<span class="built_in">length</span>(); right++) &#123; <span class="comment">// 设置窗口左右边界</span></span><br><span class="line">            mp[s[right]]++; <span class="comment">// 窗口右移进入哈希表统计字符出现次数</span></span><br><span class="line">            <span class="keyword">while</span>(mp[s[right]] &gt; <span class="number">1</span>) &#123; <span class="comment">// 出现次数大于1，说明窗口内有重复字符</span></span><br><span class="line">                mp[s[left++]]--; <span class="comment">// 窗口左移，同时减去该字符的出现次数</span></span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, right - left + <span class="number">1</span>); <span class="comment">// 维护子串长度的最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="滑动窗口–解析"><a href="#滑动窗口–解析" class="headerlink" title="滑动窗口–解析"></a>滑动窗口–解析</h3><p>此段代码用于计算给定字符串<code>s</code>中的最长无重复字符子串的长度。</p><p>首先，使用一个哈希表<code>mp</code>来记录窗口内的非重复字符及其出现次数。</p><p>然后，通过两个指针<code>left</code>和<code>right</code>设置窗口的左右边界。初始化时，两个指针均指向字符串<code>s</code>的起始位置。</p><p>接下来，通过循环将窗口右移，每次将右指针<code>right</code>向右移动一位。在移动过程中，将当前字符<code>s[right]</code>加入到哈希表<code>mp</code>中，并增加其出现次数。</p><p>如果当前字符<code>s[right]</code>的出现次数大于1，说明窗口内有重复字符。此时，需要将窗口左边界<code>left</code>向右移动，并逐步减少左边界指向的字符的出现次数，直到窗口内没有重复字符为止。</p><p>在每次移动窗口过程中，维护一个变量<code>res</code>，用来记录最长无重复字符子串的长度。通过比较当前子串的长度<code>right - left + 1</code>与<code>res</code>的大小，更新<code>res</code>的值。</p><p>最后，返回<code>res</code>即为最长无重复字符子串的长度。</p><p>该算法使用滑动窗口的思想，通过遍历字符串并维护窗口内的字符出现次数，找到最长的无重复字符子串的长度。<br>时间复杂度为 O(n)，其中 n 为字符串的长度。空间复杂度：O(n)，最坏情况下整个字符串都是不重复的，哈希表长度就为字符串长度n。</p><h3 id="代码–动态规划"><a href="#代码–动态规划" class="headerlink" title="代码–动态规划"></a>代码–动态规划</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 计算最长不重复子串的长度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 哈希表，用于记录字符最后一次出现的位置</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;mp;</span><br><span class="line">        <span class="comment">// 动态规划数组，记录以每个位置结尾的最长不重复子串的长度</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(s.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 结果变量，最长不重复子串的长度</span></span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历字符串中的每个字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(s[i<span class="number">-1</span>])==mp.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="comment">// 如果字符在哈希表中不存在，可以加入到上一个位置结尾的最长不重复子串中</span></span><br><span class="line">                dp[i]=dp[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 如果字符已经出现过，则判断是否在当前位置的最长不重复子串中</span></span><br><span class="line">                <span class="comment">// 距离 = 当前位置 - 上一次出现的位置</span></span><br><span class="line">                <span class="type">int</span> distance = i - mp[s[i<span class="number">-1</span>]];</span><br><span class="line">                <span class="keyword">if</span>(distance &gt; dp[i<span class="number">-1</span>])&#123;</span><br><span class="line">                    <span class="comment">// 距离大于当前位置结尾最长不重复子串的长度，可以将新的子串延伸到当前位置</span></span><br><span class="line">                    dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 距离小于等于当前位置结尾最长不重复子串的长度，剔除掉之前的字符，更新为新的不重复子串</span></span><br><span class="line">                    dp[i] = distance;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新哈希表中字符的位置为当前位置</span></span><br><span class="line">            mp[s[i<span class="number">-1</span>]] = i;</span><br><span class="line">            <span class="comment">// 更新结果，记录最长不重复子串的长度</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="动态规划–解析"><a href="#动态规划–解析" class="headerlink" title="动态规划–解析"></a>动态规划–解析</h3><p>这段代码是一个用于计算最长不重复子串长度的函数。函数的输入参数是一个字符串 <code>s</code>，输出结果是一个整数表示最长不重复子串的长度。</p><p>该函数使用动态规划的思想来解决问题。具体来说，它使用了一个哈希表 <code>mp</code> 和一个动态规划数组 <code>dp</code> 来辅助计算。</p><ul><li><code>mp</code> 是一个哈希表，用于记录字符串中每个字符最后一次出现的位置。</li><li><code>dp</code> 是一个长度为 <code>s.size()+1</code> 的动态规划数组，用于记录以每个位置结尾的最长不重复子串的长度。</li><li>变量 <code>res</code> 用于记录最终的结果，即最长不重复子串的长度。</li></ul><p>接下来，该函数通过遍历字符串 <code>s</code> 中的每个字符来计算最长不重复子串的长度。具体流程如下：</p><ol><li>对于第一个字符，它是第一个出现的字符，所以 <code>dp[0] = 0</code>。</li><li>然后从第二个字符开始遍历，对于每个字符 <code>s[i-1]</code>：<ul><li>如果字符 <code>s[i-1]</code> 在 <code>mp</code> 中不存在（即之前没有出现过），则说明它可以加入到上一个位置结尾的最长不重复子串中，因此 <code>dp[i] = dp[i-1] + 1</code>。</li><li>如果字符 <code>s[i-1]</code> 在 <code>mp</code> 中存在（即之前已经出现过），则说明它与之前的某个字符重复，我们需要判断两种情况：<ul><li>如果距离 <code>i - mp[s[i-1]]</code> 大于当前以第 <code>i-1</code> 个字符结尾的最长不重复子串的长度 <code>dp[i-1]</code>，则说明字符 <code>s[i-1]</code> 不在以第 <code>i-1</code> 个字符结尾的最长不重复子串中，此时可以将新的不重复子串延伸到第 <code>i</code> 个字符处，长度为 <code>dp[i-1] + 1</code>。</li><li>如果距离 <code>i - mp[s[i-1]]</code> 小于等于当前以第 <code>i-1</code> 个字符结尾的最长不重复子串的长度 <code>dp[i-1]</code>，则说明字符 <code>s[i-1]</code> 在以第 <code>i-1</code> 个字符结尾的最长不重复子串中，此时需要剔除掉字符 <code>s[i-1]</code> 所在的位置及其之前的字符，从而得到新的不重复子串。</li></ul></li><li>更新哈希表 <code>mp</code> 中字符 <code>s[i-1]</code> 的位置为 <code>i</code>。</li><li>更新结果 <code>res</code> 为当前的最长不重复子串长度 <code>dp[i]</code> 和之前的结果 <code>res</code> 中的较大值。</li></ul></li><li>最后返回结果 <code>res</code>。</li></ol><p>这段代码使用动态规划的思想，在遍历过程中通过哈希表和动态规划数组来记录和计算每个位置结尾的最长不重复子串的长度。<br>时间复杂度为 O(n) ，其中 n 是字符串的长度。空间复杂度：O(n)，辅助数组dp的大小为字符串长度，哈希表的最大空间为字符串长度。</p><h2 id="JZ46-把数字翻译成字符串"><a href="#JZ46-把数字翻译成字符串" class="headerlink" title="JZ46 把数字翻译成字符串"></a>JZ46 把数字翻译成字符串</h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p><img src="http://sc1goen2r.hn-bkt.clouddn.com/dpnumtostr.png"></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(string nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 排除特殊情况：只有一个字符且为0，无法解码，返回0</span></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="string">&quot;0&quot;</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 排除特殊情况：只有两个字符且为&quot;10&quot;或&quot;20&quot;，只有一种解码方式，返回1</span></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="string">&quot;10&quot;</span> || nums == <span class="string">&quot;20&quot;</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当0的前面不是1或2时，无法进行解码，返回0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">length</span>(); i++)&#123;  </span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span>(nums[i - <span class="number">1</span>] != <span class="string">&#x27;1&#x27;</span> &amp;&amp; nums[i - <span class="number">1</span>] != <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 辅助数组初始化为1</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.length() + <span class="number">1</span>, <span class="number">1</span>)</span></span>;  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 动态规划计算解码方式数量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= nums.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">// 在11-19，21-26之间的情况，可以解码为一个字母</span></span><br><span class="line">            <span class="keyword">if</span>((nums[i - <span class="number">2</span>] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; nums[i - <span class="number">1</span>] != <span class="string">&#x27;0&#x27;</span>) || </span><br><span class="line">               (nums[i - <span class="number">2</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; nums[i - <span class="number">1</span>] &gt; <span class="string">&#x27;0&#x27;</span> &amp;&amp; nums[i - <span class="number">1</span>] &lt; <span class="string">&#x27;7&#x27;</span>))</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>]; <span class="comment">// 当前位置只能作为独立的数字进行解码，解码方式数量与之前相同</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回辅助数组的最后一个元素，即为总的解码方式数量</span></span><br><span class="line">        <span class="keyword">return</span> dp[nums.<span class="built_in">length</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h3><p>在这个解码问题中，我们需要计算给定字符串 <code>nums</code> 的解码方式数量。为了找到状态方程，我们可以考虑以下几点：</p><p>【1】. 问题的最优子结构特性：问题的解可以通过子问题的解来构造。</p><p>   假设当前字符为 <code>nums[i]</code>，我们可以根据前面的字符来进行解码。对于每个位置 i，我们有两种情况：</p><ul><li>如果 <code>nums[i-1]</code> 和 <code>nums[i]</code> 可以组成一个有效的字母（即处于 11-19 或 21-26 的范围内），我们可以选择将其作为一个字母进行解码。那么，总的解码方式数量为 <code>dp[i-1]</code> 加上之前的位置 <code>dp[i-2]</code>。</li><li>如果 <code>nums[i-1]</code> 和 <code>nums[i]</code> 不组成一个有效的字母，那么我们只能将 <code>nums[i]</code> 视为一个独立的数字进行解码。此时，解码方式数量与之前相同，即为 <code>dp[i-1]</code>。</li></ul><p>   因此，我们可以得出状态方程：<code>dp[i] = dp[i-1] + dp[i-2]</code>。</p><p>【2】. 边界条件：我们需要确定初始的状态。</p><p>   对于字符串长度为 1 的情况，只有一个字符，且不能为 ‘0’，因为 ‘0’ 无法进行解码。所以，初始状态为 <code>dp[1] = 1</code>。</p><p>   对于字符串长度为 2 的情况，我们需要考虑特殊情况。如果字符串为 “10” 或 “20”，只有一种解码方式。所以，初始状态为 <code>dp[2] = 1</code>。</p><p>【3】. 最终的解：我们需要找到问题的最终解。</p><p>   最终解就是到达字符串的最后一个字符时的解码方式数量，即 <code>dp[nums.length()]</code>。</p><p>基于上述分析，我们得到了状态方程 <code>dp[i] = dp[i-1] + dp[i-2]</code>，并且确定了边界条件和最终解。这样，我们可以使用动态规划来计算解码方式的数量。</p><p>具体流程如下：</p><ol><li><p>首先，排除一些特殊情况：</p><ul><li>如果输入字符串为 “0”，表示无法进行解码，返回解码方式数量为 0。</li><li>如果输入字符串为 “10” 或 “20”，这两种情况只有一种解码方式，返回解码方式数量为 1。</li></ul></li><li><p>然后，对于其余情况，判断是否存在无法进行解码的场景：</p><ul><li>遍历字符串中的每个字符（从第二个字符开始），如果某个字符是 ‘0’，并且它前面的字符不是 ‘1’ 或 ‘2’，那么无法进行解码，返回解码方式数量为 0。</li></ul></li><li><p>初始化辅助数组 <code>dp</code>，长度为 <code>nums.length() + 1</code>，并将所有元素初始化为 1。这个数组用于记录到达每个位置 <code>i</code> 的解码方式数量。</p></li><li><p>接下来，从第三个字符开始遍历字符串：</p><ul><li>对于字符 <code>nums[i-2]</code> 和 <code>nums[i-1]</code>，判断它们组成的数字是否在 11-19 或者 21-26 的范围内（即可以解码为一个字母）：<ul><li>如果是，则表示在当前位置可以组成一个字母和之前的所有解码方式数量，即 <code>dp[i] = dp[i-1] + dp[i-2]</code>。</li><li>如果不是，则表示当前位置只能作为一个独立的数字进行解码，解码方式数量与之前相同，即 <code>dp[i] = dp[i-1]</code>。</li></ul></li></ul></li><li><p>最后，返回辅助数组 <code>dp</code> 的最后一个元素，即为总的解码方式数量。</p></li></ol><p>这段代码使用动态规划的思想，通过遍历字符串并根据不同情况更新辅助数组来计算解码方式的数量。<br>实现了时间复杂度为 O(n) 的解法，其中 n 是字符串的长度。空间复杂度：O(n)，辅助数组dp。</p><h2 id="JZ19-正则表达式匹配"><a href="#JZ19-正则表达式匹配" class="headerlink" title="JZ19 正则表达式匹配"></a>JZ19 正则表达式匹配</h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p><img src="http://sc1goen2r.hn-bkt.clouddn.com/dp9.png"></p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">match</span><span class="params">(string str, string pattern)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> strlen = str.<span class="built_in">size</span>();  <span class="comment">// 字符串长度</span></span><br><span class="line">        <span class="type">int</span> patlen = pattern.<span class="built_in">size</span>();  <span class="comment">// 正则表达式长度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建二维动态规划数组，初始值都为 false</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(strlen + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(patlen + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;  <span class="comment">// 空字符串和空正则表达式是匹配的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理边界条件，如果 pattern[k-1] 是 *，则 dp[0][k] 的值与 dp[0][k-2] 相同</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">2</span>; k &lt;= patlen; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pattern[k - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][k] = dp[<span class="number">0</span>][k - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字符串和正则表达式，使用动态规划更新 dp 数组中的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= strlen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= patlen; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pattern[j - <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span> &amp;&amp; (pattern[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span> || pattern[j - <span class="number">1</span>] == str[i - <span class="number">1</span>])) &#123;</span><br><span class="line">                    <span class="comment">// 当前字符直接匹配，根据状态转移方程更新 dp[i][j]</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt;= <span class="number">2</span> &amp;&amp; pattern[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 当前字符是 *，存在两种情况</span></span><br><span class="line">                    <span class="keyword">if</span> (pattern[j - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span> || pattern[j - <span class="number">2</span>] == str[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                        <span class="comment">// 前一个字符可以与当前字符匹配或者是 . ，根据状态转移方程更新 dp[i][j]</span></span><br><span class="line">                        dp[i][j] = dp[i][j - <span class="number">2</span>] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 前一个字符不能与当前字符匹配，只能忽略前面的字符和 *，此时 dp[i][j] 的值与 dp[i][j-2] 相同</span></span><br><span class="line">                        dp[i][j] = dp[i][j - <span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[strlen][patlen];  <span class="comment">// 返回最终的匹配结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h3><p>当我们要判断一个字符串 <code>str</code> 是否匹配一个正则表达式 <code>pattern</code> 时，可以使用动态规划的思想。我们可以定义一个二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 表示 <code>str</code> 的前 <code>i</code> 个字符和 <code>pattern</code> 的前 <code>j</code> 个字符是否匹配。</p><p>我们要找到一个状态转移方程来更新 <code>dp</code> 数组中的值，使得 <code>dp[strlen][patlen]</code> 最终代表 <code>str</code> 是否与 <code>pattern</code> 匹配。</p><p>首先，我们考虑边界条件，也就是空字符串与空正则表达式是匹配的，所以我们将 <code>dp[0][0]</code> 初始化为 <code>true</code>。</p><p>然后，我们考虑字符串 <code>str</code> 为空的情况下，如何与正则表达式 <code>pattern</code> 进行匹配。如果 <code>pattern</code> 的第 <code>j</code> 个字符是 <code>*</code>，则它可以使前面的字符重复 0 次，即可以忽略前面的字符，所以 <code>dp[0][j]</code> 的值与 <code>dp[0][j-2]</code> 的值相同。</p><p>接下来，我们遍历字符串 <code>str</code> 和正则表达式 <code>pattern</code> 的所有字符，从第一个字符开始：</p><ol><li><p>如果当前字符 <code>pattern[j-1]</code> 不是 <code>*</code> 并且能够直接匹配或者是 <code>.</code>（可以匹配任意字符），则说明当前位置的字符匹配，只需要看前面的字符是否匹配，即 <code>dp[i][j] = dp[i-1][j-1]</code>。</p></li><li><p>如果当前字符 <code>pattern[j-1]</code> 是 <code>*</code>：</p><ul><li>如果前一个字符 <code>pattern[j-2]</code> 可以与当前字符 <code>str[i-1]</code> 匹配或者是 <code>.</code>，则可以有两种情况：<ul><li>一种情况是忽略前面的字符 <code>pattern[j-2]</code> 和 <code>*</code>，此时 <code>dp[i][j]</code> 取决于 <code>dp[i][j-2]</code> 的值，即 <code>dp[i][j] = dp[i][j-2]</code>。</li><li>另一种情况是重复前面的字符 <code>pattern[j-2]</code>，此时 <code>dp[i][j]</code> 取决于 <code>dp[i-1][j]</code> 的值，即 <code>dp[i][j] = dp[i-1][j]</code>。</li></ul></li><li>如果前一个字符 <code>pattern[j-2]</code> 不能与当前字符 <code>str[i-1]</code> 匹配，则只能忽略前面的字符 <code>pattern[j-2]</code> 和 <code>*</code>，此时 <code>dp[i][j]</code> 取决于 <code>dp[i][j-2]</code> 的值，即 <code>dp[i][j] = dp[i][j-2]</code>。</li></ul></li><li><p>如果以上情况都不满足，说明当前位置的字符无法匹配，直接将 <code>dp[i][j]</code> 设置为 <code>false</code>。</p></li></ol><p>最后，返回 <code>dp[strlen][patlen]</code> 的值，即表示最终的匹配结果。</p><p>时间复杂度：</p><ul><li>遍历字符串和正则表达式的两个嵌套循环需要 <code>O(strlen * patlen)</code> 的时间。</li><li>在循环中进行的判断操作都是常数时间的操作（如字符比较、赋值等）。</li><li>因此，总的时间复杂度为 <code>O(strlen * patlen)</code>。</li></ul><p>空间复杂度：</p><ul><li>创建了一个二维数组 <code>dp</code>，其大小为 (strlen + 1) x (patlen + 1)，因此需要 <code>O(strlen * patlen)</code> 的空间。</li><li>其他的变量占用的空间是常数级别的。</li><li>因此，总的空间复杂度为 <code>O(strlen * patlen)</code>。</li></ul><p>需要注意的是，由于上述的正则表达式匹配算法中使用了一个二维数组来保存中间状态，因此空间复杂度较高。如果希望进行空间优化，可以使用滚动数组或者只使用一维数组来保存中间状态，从而将空间复杂度优化到 <code>O(patlen)</code>。</p><p>一种优化思路是使用状态压缩，将二维的动态规划数组压缩成一维数组，减少空间复杂度。具体优化如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">match</span><span class="params">(string str, string pattern)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> strlen = str.<span class="built_in">size</span>();  <span class="comment">// 字符串长度</span></span><br><span class="line">        <span class="type">int</span> patlen = pattern.<span class="built_in">size</span>();  <span class="comment">// 正则表达式长度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一维动态规划数组，初始值都为 false</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(patlen + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;  <span class="comment">// 空字符串和空正则表达式是匹配的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理边界条件，如果 pattern[k-1] 是 *，则 dp[k] 的值与 dp[k-2] 相同</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">2</span>; k &lt;= patlen; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pattern[k - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                dp[k] = dp[k - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字符串和正则表达式，使用动态规划更新 dp 数组中的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= strlen; i++) &#123;</span><br><span class="line">            <span class="type">bool</span> pre = dp[<span class="number">0</span>];  <span class="comment">// 保存前一个状态</span></span><br><span class="line">            dp[<span class="number">0</span>] = <span class="literal">false</span>;  <span class="comment">// 更新 dp[0] 的值为 false，因为当前字符不可能匹配空正则表达式</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= patlen; j++) &#123;</span><br><span class="line">                <span class="type">bool</span> temp = dp[j];  <span class="comment">// 保存原始 dp[j] 的值</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pattern[j - <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span> &amp;&amp; (pattern[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span> || pattern[j - <span class="number">1</span>] == str[i - <span class="number">1</span>])) &#123;</span><br><span class="line">                    <span class="comment">// 当前字符直接匹配，根据状态转移方程更新 dp[j]</span></span><br><span class="line">                    dp[j] = pre;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt;= <span class="number">2</span> &amp;&amp; pattern[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 当前字符是 *，存在两种情况</span></span><br><span class="line">                    <span class="keyword">if</span> (pattern[j - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span> || pattern[j - <span class="number">2</span>] == str[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                        <span class="comment">// 前一个字符可以与当前字符匹配或者是 . ，根据状态转移方程更新 dp[j]</span></span><br><span class="line">                        dp[j] = dp[j - <span class="number">2</span>] || dp[j];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 前一个字符不能与当前字符匹配，只能忽略前面的字符和 *，此时 dp[j] 的值与 dp[j-2] 相同</span></span><br><span class="line">                        dp[j] = dp[j - <span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 当前字符不匹配且不是 *，dp[j] 的值应为 false</span></span><br><span class="line">                    dp[j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                pre = temp;  <span class="comment">// 更新前一个状态</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[patlen];  <span class="comment">// 返回最终的匹配结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>优化后的算法思路与步骤如下：</p><ol><li>定义一个一维动态规划数组 <code>dp</code>，大小为正则表达式的长度加一：<code>dp[patlen+1]</code>。</li><li>初始时将 <code>dp[0]</code> 设为 <code>true</code>，表示空字符串和空正则表达式是匹配的。</li><li>处理边界条件，如果正则表达式的第 <code>k-1</code> 位是 <code>*</code>，则 <code>dp[k]</code> 的值与 <code>dp[k-2]</code> 相同。遍历 <code>k</code> 从 2 到正则表达式的长度。</li><li>遍历字符串和正则表达式，使用动态规划更新 <code>dp</code> 数组中的值：<ul><li>对于字符串的每个字符 <code>str[i-1]</code>，从正则表达式的第一位开始遍历，依次处理正则表达式的每个字符 <code>pattern[j-1]</code>。</li><li>在更新 <code>dp[j]</code> 之前，先将 <code>dp[j]</code> 的值保存到一个临时变量 <code>temp</code> 中。</li><li>如果 <code>pattern[j-1]</code> 不是 <code>*</code> 并且可以直接匹配当前字符（即 <code>pattern[j-1]</code> 是 <code>.</code> 或者与 <code>str[i-1]</code> 相等），则根据状态转移方程，更新 <code>dp[j]</code> 的值为前一个状态 <code>pre</code>。</li><li>如果 <code>pattern[j-1]</code> 是 <code>*</code>，则存在两种情况：<ul><li>前一个字符可以与当前字符匹配或者是 <code>.</code>，根据状态转移方程，更新 <code>dp[j]</code> 的值为 <code>dp[j-2] || dp[j]</code>。</li><li>前一个字符不能与当前字符匹配，只能忽略前面的字符和 <code>*</code>，此时 <code>dp[j]</code> 的值与 <code>dp[j-2]</code> 相同。</li></ul></li><li>如果以上条件都不满足，则说明当前字符不匹配且不是 <code>*</code>，将 <code>dp[j]</code> 的值设为 <code>false</code>。</li><li>更新前一个状态 <code>pre</code> 为 <code>temp</code>，进行下一轮循环。</li></ul></li><li>返回 <code>dp[patlen]</code> 的值，即最终的匹配结果。</li></ol><p>通过使用一维动态规划数组和状态压缩的技巧，优化后的算法在空间复杂度上得到了降低。同时，时间复杂度仍然保持为 O(strlen x patlen)。</p><h1 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h1><p>啊┭┮﹏┭┮动态规划是尊嘟U点难┭┮﹏┭┮狠话时间的一个模块/(ㄒoㄒ)/~~我们下篇博客见~</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Recursion and Backtracking</title>
      <link href="/2023/09/17/Recursion-and-Backtracking/"/>
      <url>/2023/09/17/Recursion-and-Backtracking/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>话不多说，直接开干！</p><h2 id="JZ12-矩阵中的路径"><a href="#JZ12-矩阵中的路径" class="headerlink" title="JZ12 矩阵中的路径"></a>JZ12 矩阵中的路径</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><img src="http://sc1goen2r.hn-bkt.clouddn.com/cursion1.png"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix, <span class="type">int</span> k, string&amp; word, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rows = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cols = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前位置不符合要求，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols || visited[i][j] || matrix[i][j] != word[k]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果已经匹配到目标字符串的最后一个字符，返回true</span></span><br><span class="line">        <span class="keyword">if</span> (k == word.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> temp = matrix[i][j];</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在上下左右四个方向进行递归查找</span></span><br><span class="line">        <span class="type">bool</span> found = <span class="built_in">dfs</span>(i - <span class="number">1</span>, j, matrix, k + <span class="number">1</span>, word, visited)</span><br><span class="line">                  || <span class="built_in">dfs</span>(i + <span class="number">1</span>, j, matrix, k + <span class="number">1</span>, word, visited)</span><br><span class="line">                  || <span class="built_in">dfs</span>(i, j - <span class="number">1</span>, matrix, k + <span class="number">1</span>, word, visited)</span><br><span class="line">                  || <span class="built_in">dfs</span>(i, j + <span class="number">1</span>, matrix, k + <span class="number">1</span>, word, visited);</span><br><span class="line"></span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPath</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix, string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>()) &#123;  <span class="comment">// 检查矩阵是否为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rows = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cols = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(rows, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(cols, <span class="literal">false</span>));  <span class="comment">// 记录已访问的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历矩阵中的每一个元素，以其为起始点进行深度优先搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(i, j, matrix, <span class="number">0</span>, word, visited)) &#123;  <span class="comment">// 如果找到了匹配的路径，立即返回true</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 循环结束后仍未找到匹配的路径，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>这是一个使用深度优先搜索（DFS）算法来判断矩阵中是否存在与给定字符串相匹配的路径的问题。</p><p>首先，定义了一个 <code>dfs</code> 函数。该函数的参数包括当前位置的行索引 <code>i</code>、列索引 <code>j</code>，矩阵 <code>matrix</code>，目标字符串的当前匹配位置 <code>k</code>，目标字符串 <code>word</code>，以及一个二维数组 <code>visited</code> 用于记录已经访问过的位置。</p><p>在 <code>dfs</code> 函数中，首先判断当前位置是否符合要求。如果当前位置不在矩阵范围内、已经被访问过或者当前位置的字符与目标字符串的当前字符不匹配，那么说明从当前位置无法匹配目标字符串的路径，直接返回 false。</p><p>然后，判断是否已经匹配到目标字符串的最后一个字符。如果是，则说明已经找到了匹配的路径，返回 true。</p><p>接下来，保存当前位置的字符，并将当前位置设置为已访问状态，避免重复访问。</p><p>然后，分别在当前位置的上、下、左、右四个方向上进行递归搜索。对于每个方向，递归调用 <code>dfs</code> 函数，并将当前位置的行索引、列索引更新为相应的值，目标字符串的当前匹配位置 <code>k</code> 更新为 <code>k+1</code>。如果任意一个方向上找到了匹配路径，返回 true。</p><p>最后，恢复当前位置的字符，并将当前位置重新设置为未访问状态。最终返回 false，表示没有找到匹配的路径。</p><p>在主函数 <code>hasPath</code> 中，首先检查矩阵是否为空。如果为空，则直接返回 false。</p><p>然后，根据矩阵的行数和列数，创建一个二维数组 <code>visited</code> 用于记录每个位置的访问状态。</p><p>接下来，使用两层循环遍历矩阵中的每一个元素。对于每个元素，调用 <code>dfs</code> 函数进行深度优先搜索。如果找到了匹配的路径，立即返回 true。</p><p>循环结束后仍未找到匹配的路径，返回 false。</p><p>时间复杂度分析：</p><ul><li>假设矩阵的行数为 <code>m</code>，列数为 <code>n</code>，字符串的长度为 <code>k</code>，则遍历矩阵需要 O(m*n) 的时间复杂度。</li><li>在 <code>dfs</code> 函数中，最坏情况下，每个位置都需要进行深度优先搜索，时间复杂度为 O(k)。</li><li>因此，总的时间复杂度为 O(m<em>n</em>k)。</li></ul><p>空间复杂度分析：</p><ul><li>使用了一个二维数组 <code>visited</code> 来记录访问状态，其空间复杂度为 O(m*n)。</li><li>递归调用的空间复杂度取决于递归的深度，最坏情况下为字符串的长度 <code>k</code>。</li><li>所以总的空间复杂度为 O(m*n+k)。</li></ul><h2 id="JZ13-机器人的运动范围"><a href="#JZ13-机器人的运动范围" class="headerlink" title="JZ13 机器人的运动范围"></a>JZ13 机器人的运动范围</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p><img src="http://sc1goen2r.hn-bkt.clouddn.com/recursion2.png"></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;  <span class="comment">// 定义上、下、左、右四个方向的偏移量</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;  <span class="comment">// 记录机器人能够到达的格子数量的变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算数字的数位之和</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calcu</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num) &#123;</span><br><span class="line">            sum += num % <span class="number">10</span>;  <span class="comment">// 将 num 的个位加到 sum 中</span></span><br><span class="line">            num /= <span class="number">10</span>;  <span class="comment">// 将 num 右移一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 深度优先搜索函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> rows, <span class="type">int</span> cols, <span class="type">int</span> threshold, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; vis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols || vis[i][j] || <span class="built_in">calcu</span>(i) + <span class="built_in">calcu</span>(j) &gt; threshold) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;  <span class="comment">// 越界或者已访问过或者数位之和大于阈值，停止搜索</span></span><br><span class="line">        &#125;</span><br><span class="line">        res++;  <span class="comment">// 增加机器人能够到达的格子数量</span></span><br><span class="line">        vis[i][j] = <span class="literal">true</span>;  <span class="comment">// 设置当前位置为已访问状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(i + dir[k][<span class="number">0</span>], j + dir[k][<span class="number">1</span>], rows, cols, threshold, vis);  <span class="comment">// 递归搜索上、下、左、右四个方向</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算机器人能够到达的格子数量的函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">movingCount</span><span class="params">(<span class="type">int</span> threshold, <span class="type">int</span> rows, <span class="type">int</span> cols)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (threshold &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 阈值小于等于0时，返回 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">vis</span>(rows, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(cols, <span class="literal">false</span>));  <span class="comment">// 记录访问状态的二维数组</span></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, rows, cols, threshold, vis);  <span class="comment">// 进行深度优先搜索</span></span><br><span class="line">        <span class="keyword">return</span> res;  <span class="comment">// 返回机器人能够到达的格子数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><p>首先，我们需要明确题目中给出的信息，即机器人每次只能移动一格，四个方向均可，并且只能进入数位之和不大于 <code>k</code> 的格子。</p><p>接下来，我们可以考虑使用深度优先搜索算法来遍历整个矩阵，从而统计机器人能够到达的格子数量。具体步骤如下：</p><ol><li><p>定义一个记录机器人能够到达的格子数量的变量<code>res</code>，初始化为 0。</p></li><li><p>定义一个二维数组 <code>vis</code>，用于标记矩阵中每个格子是否被访问过，初始化为 <code>false</code>。</p></li><li><p>调用深度优先搜索函数 <code>dfs(0, 0, rows, cols, threshold, vis)</code>。</p></li><li><p>在 <code>dfs</code> 函数中，首先判断当前格子是否越界、是否已经被访问过以及数位之和是否大于阈值。如果是，则直接返回；否则，将当前格子标记为已访问状态，并将机器人能够到达的格子数量 <code>res</code> 加 1。</p></li><li><p>然后，递归搜索当前格子的上、下、左、右四个邻居格子，直到搜索完所有能够到达的格子。</p></li><li><p>最后，返回机器人能够到达的格子数量 <code>res</code>。</p></li></ol><p>总体来说，这个算法就是基于深度优先搜索的。该算法的时间复杂度为 <code>O(rows * cols)</code>，因为我们需要遍历整个矩阵来统计能够到达的格子数量。同时，我们需要使用一个二维数组 <code>vis</code> 来记录每个格子是否被访问过，因此该算法的空间复杂度也为 <code>O(rows * cols)</code>。</p><h1 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h1><p>期待下篇博客与你相见~</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 递归回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dynamic programming algorithm problem solution（1）</title>
      <link href="/2023/09/17/dynamic-programming-algorithm/"/>
      <url>/2023/09/17/dynamic-programming-algorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>话不多说，直接开干！</p><h2 id="JZ42-连续子数组的最大和"><a href="#JZ42-连续子数组的最大和" class="headerlink" title="JZ42 连续子数组的最大和"></a>JZ42 连续子数组的最大和</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><img src="http://sc1goen2r.hn-bkt.clouddn.com/dp1.png"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化当前位置的最大子数组和和全局最大子数组和为第一个元素</span></span><br><span class="line">        <span class="type">int</span> dp = array[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> maxsum = dp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从第二个元素开始遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; array.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 计算当前位置的最大子数组和</span></span><br><span class="line">            dp = <span class="built_in">max</span>(dp + array[i], array[i]);</span><br><span class="line">            <span class="comment">// 更新全局最大子数组和</span></span><br><span class="line">            maxsum = <span class="built_in">max</span>(maxsum, dp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回全局最大子数组和</span></span><br><span class="line">        <span class="keyword">return</span> maxsum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>这段代码是一个求解最大连续子数组和的函数。函数的输入是一个整数数组 <code>array</code>，输出是最大连续子数组的和。</p><p>代码中使用了动态规划的思想来解决这个问题。具体步骤如下：</p><ol><li>初始化两个变量 <code>dp</code> 和 <code>maxsum</code>，分别表示当前位置的最大子数组和和全局最大子数组和，初始值都为第一个元素 <code>array[0]</code>。</li><li>从数组的第二个元素开始遍历，对于每一个位置 <code>i</code>：<ul><li>计算当前位置的最大子数组和：<code>dp = max(dp + array[i], array[i])</code>。这里的含义是，如果将当前元素加入之前的最大子数组中，得到的和更大，就保留加入后的和作为当前位置的最大子数组和；否则，重新开始一个新的子数组。</li><li>更新全局最大子数组和：<code>maxsum = max(maxsum, dp)</code>。将当前位置的最大子数组和与全局最大子数组和进行比较，更新为较大的值。</li></ul></li><li>遍历结束后，返回全局最大子数组和 <code>maxsum</code>。</li></ol><p>这段代码的时间复杂度为 O(N)，其中 N 是数组的长度，因为只需要遍历一次数组。空间复杂度为 O(1)，因为只使用了常数个变量来保存状态。</p><h2 id="JZ85-连续子数组的最大和-二"><a href="#JZ85-连续子数组的最大和-二" class="headerlink" title="JZ85 连续子数组的最大和(二)"></a>JZ85 连续子数组的最大和(二)</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p><img src="http://sc1goen2r.hn-bkt.clouddn.com/dp2.png"></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">FindGreatestSumOfSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> array; <span class="comment">// 如果数组只有一个元素，则直接返回该元素作为结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res; <span class="comment">// 用于存储最大和的子数组</span></span><br><span class="line">        <span class="type">int</span> dp = array[<span class="number">0</span>]; <span class="comment">// 当前子数组的最大和</span></span><br><span class="line">        <span class="type">int</span> maxsum = dp; <span class="comment">// 最大和</span></span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>; <span class="comment">// 当前子数组的起始位置和结束位置</span></span><br><span class="line">        <span class="type">int</span> rstart = <span class="number">0</span>, rend = <span class="number">0</span>; <span class="comment">// 最大和的子数组的起始位置和结束位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; array.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            end++; <span class="comment">// 扩展当前子数组的结束位置</span></span><br><span class="line">            <span class="keyword">if</span> (dp + array[i] &lt; array[i]) &#123; <span class="comment">// 如果加上当前元素后的和比当前元素本身还小</span></span><br><span class="line">                dp = array[i]; <span class="comment">// 更新当前子数组的最大和为当前元素</span></span><br><span class="line">                start = i; <span class="comment">// 更新当前子数组的起始位置为当前元素的索引</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp += array[i]; <span class="comment">// 加上当前元素更新当前子数组的最大和</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dp &gt; maxsum || (dp == maxsum &amp;&amp; (end - start + <span class="number">1</span> &gt; rend - rstart + <span class="number">1</span>))) &#123;</span><br><span class="line">                <span class="comment">// 如果当前子数组的最大和大于最大和的子数组的最大和</span></span><br><span class="line">                <span class="comment">// 或者当前子数组的最大和等于最大和的子数组的最大和，但当前子数组的长度更长</span></span><br><span class="line">                maxsum = dp; <span class="comment">// 更新最大和为当前子数组的最大和</span></span><br><span class="line">                rstart = start; <span class="comment">// 更新最大和的子数组的起始位置为当前子数组的起始位置</span></span><br><span class="line">                rend = end; <span class="comment">// 更新最大和的子数组的结束位置为当前子数组的结束位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = rstart; i &lt;= rend; i++) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(array[i]); <span class="comment">// 将最大和的子数组的元素添加到结果向量中</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回最大和的子数组作为结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><p>这段代码是一个求解最大子数组和的问题，采用的是动态规划的思路。代码中定义了一个 <code>Solution</code> 类，其中有一个名为 <code>FindGreatestSumOfSubArray</code> 的方法，接受一个整型向量 <code>array</code> 作为输入。</p><p>首先，检查数组的长度是否为1，如果是的话，直接将该元素作为结果返回。</p><p>然后，定义了一些变量，包括 <code>res</code>（用于存储最大和的子数组）、<code>dp</code>（当前子数组的最大和）、<code>maxsum</code>（最大和）、<code>start</code> 和 <code>end</code>（当前子数组的起始位置和结束位置）、<code>rstart</code> 和 <code>rend</code>（最大和的子数组的起始位置和结束位置）。</p><p>之后，通过一个循环遍历数组，从第二个元素开始。在循环中，不断扩展当前子数组的结束位置，并根据当前元素的值更新 <code>dp</code> 和 <code>start</code>。如果加上当前元素后的和比当前元素本身还小，则说明当前子数组的最大和已经达到极限，需要从当前元素开始重新计算。每次更新 <code>dp</code> 的值时，同时更新 <code>start</code> 的值。</p><p>同时，检查当前子数组的最大和是否大于最大和，或者当前子数组的最大和等于最大和，但当前子数组的长度更长。如果满足条件，则更新最大和、<code>rstart</code> 和 <code>rend</code> 的值。</p><p>最后，通过一个循环，将最大和的子数组的元素添加到结果向量 <code>res</code> 中，并将其作为结果返回。</p><p>这段代码的时间复杂度为O(n)，其中n是数组的长度。空间复杂度为O(1)。</p><h2 id="JZ69-跳台阶"><a href="#JZ69-跳台阶" class="headerlink" title="JZ69 跳台阶"></a>JZ69 跳台阶</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p><img src="http://sc1goen2r.hn-bkt.clouddn.com/dp3.png"></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> prev1 = <span class="number">1</span>; <span class="comment">// 前一个台阶的跳法数</span></span><br><span class="line">        <span class="type">int</span> prev2 = <span class="number">2</span>; <span class="comment">// 前两个台阶的跳法数</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= number; i++) &#123;</span><br><span class="line">            result = prev1 + prev2;</span><br><span class="line">            prev1 = prev2;</span><br><span class="line">            prev2 = result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h3><p>这段代码是一个经典的求解青蛙跳台阶问题的动态规划解法实现。函数 <code>jumpFloor</code> 返回了到达第 <code>number</code> 个台阶的跳法数。</p><p>在这段代码中：</p><ul><li>如果 <code>number</code> 小于等于 2，表示只有一个台阶或者两个台阶时，跳法数是固定的，直接返回 <code>number</code>。</li><li>初始化 <code>prev1</code> 为1（前一个台阶的跳法数）和 <code>prev2</code> 为2（前两个台阶的跳法数）。</li><li>通过循环从第 3 个台阶开始计算每个台阶的跳法数。</li><li>在循环中，使用 <code>result</code> 来保存当前台阶的跳法数，计算方法是前一个台阶的跳法数 <code>prev1</code> 和前两个台阶的跳法数 <code>prev2</code> 的和。</li><li>更新 <code>prev1</code> 和 <code>prev2</code> 的值，将 <code>prev2</code> 的值赋给 <code>prev1</code>，将 <code>result</code> 的值赋给 <code>prev2</code>，以便下一轮循环使用。</li><li>循环结束后，返回最终的结果 <code>result</code>，即到达第 <code>number</code> 个台阶的跳法数。</li></ul><p>总结起来，这段代码使用了动态规划的思想，通过遍历计算得到每个台阶的跳法数，并逐步更新变量的值，最终得到目标台阶的跳法数。这种实现方式的时间复杂度为 O(n)，空间复杂度为 O(1)。</p><h2 id="JZ10-斐波那契数列"><a href="#JZ10-斐波那契数列" class="headerlink" title="JZ10 斐波那契数列"></a>JZ10 斐波那契数列</h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p><img src="http://sc1goen2r.hn-bkt.clouddn.com/dp4.png"></p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 当 n 小于等于 2 时，直接返回 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> pren1=<span class="number">1</span>,pren2=<span class="number">1</span>; <span class="comment">// 初始化前两个斐波那契数为1</span></span><br><span class="line">        <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123; <span class="comment">// 从第3个斐波那契数开始计算</span></span><br><span class="line">            result=pren1+pren2; <span class="comment">// 计算当前斐波那契数的值，为前两个斐波那契数之和</span></span><br><span class="line">            pren1=pren2; <span class="comment">// 更新前一个斐波那契数为当前斐波那契数</span></span><br><span class="line">            pren2=result; <span class="comment">// 更新前两个斐波那契数为当前斐波那契数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回第 n 个斐波那契数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h3><p>这段代码实现了计算斐波那契数列第 <code>n</code> 个数的功能。函数 <code>Fibonacci</code> 返回第 <code>n</code> 个斐波那契数。</p><p>在这段代码中：</p><ul><li>如果 <code>n</code> 小于等于 2，直接返回 1。</li><li>初始化 <code>pren1</code> 为1（表示前一个斐波那契数）和 <code>pren2</code> 为1（表示前两个斐波那契数）。</li><li>通过循环从第 3 个斐波那契数开始计算每个数。</li><li>在循环中，使用 <code>result</code> 来保存当前斐波那契数的值，计算方法是前一个斐波那契数 <code>pren1</code> 和前两个斐波那契数 <code>pren2</code> 的和。</li><li>更新 <code>pren1</code> 和 <code>pren2</code> 的值，将 <code>pren2</code> 的值赋给 <code>pren1</code>，将 <code>result</code> 的值赋给 <code>pren2</code>，以便下一轮循环使用。</li><li>循环结束后，返回最终的结果 <code>result</code>，即第 <code>n</code> 个斐波那契数。</li></ul><p>这段代码使用了动态规划的思想，通过遍历计算得到每个斐波那契数，并逐步更新变量的值，最终得到目标斐波那契数。这种实现方式的时间复杂度为 O(n)，空间复杂度为 O(1)。</p><h2 id="JZ71-跳台阶扩展问题"><a href="#JZ71-跳台阶扩展问题" class="headerlink" title="JZ71 跳台阶扩展问题"></a>JZ71 跳台阶扩展问题</h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p><img src="http://sc1goen2r.hn-bkt.clouddn.com/dp5.png"></p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, number - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h3><p>在这个代码中，函数 <code>jumpFloorII</code> 接受台阶数 <code>number</code> 作为输入，并返回跳上一个 <code>n</code> 级台阶的总跳法数，使用 <code>pow</code> 函数计算 <code>2</code> 的 <code>number - 1</code> 次方。</p><p>以下是对于如何归纳推导的说明：</p><p>当青蛙跳上一个 <code>n</code> 级的台阶时，它可以从 <code>n-1</code> 级或者 <code>n-2</code> 级跳过来，因为青蛙每次可以跳任意级台阶。</p><p>假设在台阶数为 <code>n-1</code> 时，青蛙跳上这个台阶的总跳法数为 <code>f(n-1)</code>；在台阶数为 <code>n-2</code> 时，青蛙跳上这个台阶的总跳法数为 <code>f(n-2)</code>。那么，在台阶数为 <code>n</code> 时，青蛙跳上这个台阶的总跳法数为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n-1) + f(n-2) + ... + f(2) + f(1)</span><br></pre></td></tr></table></figure><p>因为青蛙可以从任意一级台阶跳上来，所以我们把所有可能情况的跳法数加起来即可。同时，由于青蛙一次可以跳任意级台阶，所以当跳上 <code>n-1</code> 级台阶时，青蛙只能从 <code>n-2</code> 级跳上来，所以此时 <code>f(n-1)=f(n-2)+...+f(2)+f(1)</code>，将其代入上面的公式中可得：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = 2 * f(n-1)</span><br></pre></td></tr></table></figure><p>这个递推公式的意义是：跳上 <code>n</code> 级台阶的总跳法数等于跳上 <code>n-1</code> 级台阶的总跳法数乘以 2。</p><p>因此，我们就可以使用递归或者迭代的方法来实现这个算法了。<br><strong>递归解法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归基：当台阶数为 1 时，只有一种跳法</span></span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 跳上 n 阶台阶的总跳法数等于跳上 n-1 阶台阶的总跳法数乘以 2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">jumpFloorII</span>(number - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个递归解法中，我们首先设置了递归基，即当台阶数为 1 时，只有一种跳法。然后，对于其他台阶数 <code>number</code>，我们使用递归调用函数本身来计算跳法数，并乘以 2，即 <code>2 * jumpFloorII(number - 1)</code>。递归解法的时间复杂度为 O(2^n)，空间复杂度为 O(n)。</p><p><strong>迭代解法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个数组用来保存每个台阶的跳法数</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(number + <span class="number">1</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始条件：当台阶数为 1 时，只有一种跳法</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 2 台阶开始，依次计算每个台阶的跳法数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= number; i++) &#123;</span><br><span class="line">            <span class="comment">// 跳上 i 阶台阶的总跳法数等于跳上 i-1 阶台阶的总跳法数乘以 2</span></span><br><span class="line">            dp[i] = <span class="number">2</span> * dp[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回跳上 number 阶台阶的跳法数</span></span><br><span class="line">        <span class="keyword">return</span> dp[number];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个迭代解法中，我们使用一个数组 <code>dp</code> 来保存每个台阶的跳法数。首先，我们设置初始条件，即当台阶数为 1 时，只有一种跳法。然后，从 2 台阶开始，使用循环依次计算每个台阶的跳法数，计算方法和递归解法相同。最后，返回跳上 <code>number</code> 阶台阶的跳法数 <code>dp[number]</code>。迭代解法的时间复杂度和空间复杂度均为 O(n)。<br>我们可以将上述迭代解法改写成如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; number; i++) &#123;</span><br><span class="line">            ans *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个迭代解法的思路是，使用一个变量 <code>ans</code> 来保存跳上上一个台阶时的跳法数，然后依次计算跳上当前台阶时的跳法数，并将结果累乘给 <code>ans</code>。最后返回 <code>ans</code> 即为跳上 <code>number</code> 阶台阶的跳法数。<br>这个迭代解法的时间复杂度为 O(n)，空间复杂度为 O(1)，与前面的迭代解法相同。</p><h2 id="JZ63-买卖股票的最好时机-一"><a href="#JZ63-买卖股票的最好时机-一" class="headerlink" title="JZ63 买卖股票的最好时机(一)"></a>JZ63 买卖股票的最好时机(一)</h2><h3 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h3><p><img src="http://sc1goen2r.hn-bkt.clouddn.com/dp6.png"></p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));  <span class="comment">// 创建一个二维数组dp，保存状态转移结果</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// 初始条件：第一天不持有股票时的最大利润为0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];  <span class="comment">// 初始条件：第一天持有股票时的最大利润为第一天的股价的相反数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i]);  <span class="comment">// 状态转移方程：不持有股票的最大利润</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], -prices[i]);  <span class="comment">// 状态转移方程：持有股票的最大利润</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">0</span>];  <span class="comment">// 返回最后一天不持有股票时的最大利润</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h3><p>当解决股票买卖问题时，我们可以使用动态规划来找到最优解。这个问题可以看作是在每一天选择是否进行买入或者卖出操作，从而获得最大的收益。</p><p>为了使用动态规划求解，我们需要定义状态和状态转移方程。</p><p>在这个问题中，我们可以定义两个状态：</p><ol><li><code>dp[i][0]</code>：表示第 <code>i</code> 天结束后不持有股票时的最大收益。</li><li><code>dp[i][1]</code>：表示第 <code>i</code> 天结束后持有股票时的最大收益。</li></ol><p>接下来，我们推导状态转移方程。</p><p>对于 <code>dp[i][0]</code>，可以有两种情况：</p><ol><li><p>如果第 <code>i</code> 天结束时不持有股票，则可能是前一天就没有持有股票，即 <code>dp[i-1][0]</code>；或者是前一天持有股票并在当前第 <code>i</code> 天卖出，即 <code>dp[i-1][1] + prices[i]</code>。我们需要取两者中的较大值，因为我们希望获得最大的收益。因此，我们可以得到 <code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</code>。</p></li><li><p>如果第 <code>i</code> 天结束时持有股票，则可能是前一天就已经持有股票，即 <code>dp[i-1][1]</code>；或者是在当前第 <code>i</code> 天购买了股票。由于购买股票需要花费价格为 <code>prices[i]</code>，因此我们的收益是负的，即 <code>-prices[i]</code>。我们同样取两者中的较大值，得到 <code>dp[i][1] = max(dp[i-1][1], -prices[i])</code>。</p></li></ol><p>最终，我们只需要返回最后一天不持有股票时的最大收益 <code>dp[n-1][0]</code>，其中 <code>n</code> 是股价数组的长度。</p><p>这个状态方程的推导基于以下理论：</p><ul><li>第 <code>i</code> 天不持有股票的最大收益，要么是前一天就没有持有股票的收益，要么是前一天持有股票并在当前第 <code>i</code> 天卖出。</li><li>第 <code>i</code> 天持有股票的最大收益，要么是前一天就已经持有股票的收益，要么是在当前第 <code>i</code> 天购买了股票。</li></ul><p>通过这个动态规划的状态方程，我们可以逐步计算每一天的最大收益，最终得到最后一天的最大收益。</p><h1 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h1><p>我们下篇博客见~</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Simulation topic of Sword Point Offer</title>
      <link href="/2023/09/11/Simulation-topic-of-Sword-Point-Offer/"/>
      <url>/2023/09/11/Simulation-topic-of-Sword-Point-Offer/</url>
      
        <content type="html"><![CDATA[<h2 id="No-1-顺时针打印矩阵（JZ29）"><a href="#No-1-顺时针打印矩阵（JZ29）" class="headerlink" title="No.1-顺时针打印矩阵（JZ29）"></a>No.1-顺时针打印矩阵（JZ29）</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><img src="http://sc1goen2r.hn-bkt.clouddn.com/monit1.png"></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; matrix)</span> </span>&#123;   <span class="comment">// 定义函数，输入二维数组</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;   <span class="comment">// 定义结果数组</span></span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;   <span class="comment">// 判断二维数组是否为空</span></span><br><span class="line">            <span class="keyword">return</span> res;   <span class="comment">// 空数组直接返回结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> up = <span class="number">0</span>, down = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;   <span class="comment">// 定义上下边界</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;   <span class="comment">// 定义左右边界</span></span><br><span class="line">        <span class="keyword">while</span>(up &lt;= down &amp;&amp; left &lt;= right) &#123;   <span class="comment">// 如果上下左右四个边界没有重合，就继续遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt;= right; i++) &#123;   <span class="comment">// 遍历上边界</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[up][i]);   <span class="comment">// 将当前元素（即matrix[up][i]）添加到结果数组</span></span><br><span class="line">            &#125;</span><br><span class="line">            up++;   <span class="comment">// 上边界下移一行</span></span><br><span class="line">            <span class="keyword">if</span>(up &gt; down) &#123;   <span class="comment">// 如果上边界已经超过下边界，结束循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = up; i &lt;= down; i++) &#123;   <span class="comment">// 遍历右边界</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            right--;   <span class="comment">// 右边界向左移动一列</span></span><br><span class="line">            <span class="keyword">if</span>(left &gt; right) &#123;   <span class="comment">// 如果左边界已经超过右边界，结束循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = right; i &gt;= left; i--) &#123;   <span class="comment">// 遍历下边界</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[down][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            down--;   <span class="comment">// 下边界上移一行</span></span><br><span class="line">            <span class="keyword">if</span>(up &gt; down) &#123;   <span class="comment">// 如果上边界已经超过下边界，结束循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = down; i &gt;= up; i--) &#123;   <span class="comment">// 遍历左边界</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;   <span class="comment">// 左边界向右移动一列</span></span><br><span class="line">            <span class="keyword">if</span>(left &gt; right) &#123;   <span class="comment">// 如果左边界已经超过右边界，结束循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;   <span class="comment">// 返回结果数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个算法的思路是按照顺时针方向遍历二维数组，从外部向内部逐层遍历。具体步骤如下：</p><ol><li>首先，定义一个结果数组res用于存储遍历结果。如果输入的二维数组matrix为空，则直接返回空的结果数组。</li><li>定义四个边界变量up、down、left、right，分别表示当前层的上边界、下边界、左边界和右边界。初始化时，上边界up为0，下边界down为matrix的行数减1，左边界left为0，右边界right为matrix的列数减1。</li><li>当上边界up小于等于下边界down且左边界left小于等于右边界right时，进行循环遍历。</li><li>在循环中，首先从左到右遍历上边界，将遍历到的元素添加到结果数组res中。</li><li>然后，上边界上移一行（up++），并判断上边界是否已经超过了下边界，如果超过，则跳出循环。</li><li>接着，从上到下遍历右边界，将遍历到的元素添加到结果数组res中。</li><li>然后，右边界左移一列（right–），并判断左边界是否已经超过了右边界，如果超过，则跳出循环。</li><li>接下来，从右到左遍历下边界，将遍历到的元素添加到结果数组res中。</li><li>然后，下边界上移一行（down–），并判断上边界是否已经超过了下边界，如果超过，则跳出循环。</li><li>最后，从下到上遍历左边界，将遍历到的元素添加到结果数组res中。</li><li>然后，左边界右移一列（left++），并判断左边界是否已经超过了右边界，如果超过，则跳出循环。</li><li>循环结束后，返回结果数组res。</li></ol><p>整个算法通过不断缩小边界来逐层遍历二维数组，直到所有层都被遍历完毕。<br>时间复杂度为O(m*n)，其中m和n分别是二维数组的行数和列数。空间复杂度为O(1)。</p><h2 id="No-2-扑克牌顺子（JZ61）"><a href="#No-2-扑克牌顺子（JZ61）" class="headerlink" title="No.2-扑克牌顺子（JZ61）"></a>No.2-扑克牌顺子（JZ61）</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p><img src="http://sc1goen2r.hn-bkt.clouddn.com/monit2.png"></p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsContinuous</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个无序哈希表，用于存储数字及其索引</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化最大值和最小值</span></span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>, min = <span class="number">13</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历数组中的每个元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">// 如果当前数字大于0，则继续执行以下操作</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 判断当前数字是否已存在于哈希表中，如果存在，直接返回false</span></span><br><span class="line">                <span class="keyword">if</span>(hash.<span class="built_in">find</span>(numbers[i]) != hash.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将当前数字添加到哈希表中，并将其索引存储为对应的值</span></span><br><span class="line">                hash[numbers[i]] = i;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 更新最大值和最小值</span></span><br><span class="line">                <span class="keyword">if</span>(numbers[i] &gt;= max)&#123;</span><br><span class="line">                    max = numbers[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(numbers[i] &lt;= min)&#123;</span><br><span class="line">                    min = numbers[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断最大值和最小值的差是否大于等于5，如果是，则无法构成顺子，返回false</span></span><br><span class="line">        <span class="keyword">if</span>(max - min &gt;= <span class="number">5</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最大值和最小值的差小于5，可以构成顺子，返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>具体步骤如下：</p><ol><li><p>首先，定义一个无序哈希表（unordered_map）hash，用于存储数组中的数字以及它们在数组中的索引。同时，初始化最大值max为0、最小值min为13（这里的数字范围是1~13）。</p></li><li><p>使用 for 循环遍历数组 numbers 中的每个元素，如下所示：</p><ul><li>如果当前数字 numbers[i] 大于0，则继续执行以下操作。</li><li>首先，判断当前数字 numbers[i] 是否已经存在于哈希表 hash 中，如果存在，说明数组中有重复的数字，直接返回 false。</li><li>如果当前数字不存在于哈希表中，则将其添加到哈希表中，并将其索引 i 存储为对应的值。</li><li>同时，更新最大值和最小值，如果当前数字大于等于最大值 max，则将其赋值给 max；如果当前数字小于等于最小值 min，则将其赋值给 min。</li></ul></li><li><p>在遍历完成后，判断最大值和最小值的差是否大于等于5。如果满足条件，说明无法构成连续的序列（顺子），直接返回 false。</p></li><li><p>如果最大值和最小值的差小于5，则说明可以构成连续的序列（顺子），返回 true。</p></li></ol><p>整个代码的思路是利用哈希表存储数字，并通过比较最大值和最小值判断是否满足顺子的条件。注意，这里假设数字范围是1~13，可以根据实际需求进行调整。</p><h2 id="No-3-JZ67-把字符串转换成整数-atoi"><a href="#No-3-JZ67-把字符串转换成整数-atoi" class="headerlink" title="No.3-JZ67 把字符串转换成整数(atoi)"></a>No.3-JZ67 把字符串转换成整数(atoi)</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p><img src="http://sc1goen2r.hn-bkt.clouddn.com/monit3.png"></p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">StrToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化变量 res（用于存储最终结果）、index（用于表示当前遍历到的字符索引）、n（字符串的长度），并初始化为零。</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, index = <span class="number">0</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用 while 循环跳过字符串开头的空格，如果遇到空格，则将索引 index 向后移动一位。直到遇到非空格字符或遍历完整个字符串。</span></span><br><span class="line">        <span class="keyword">while</span>(index&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[index]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断索引 index 是否已经达到了字符串的末尾。如果是，说明字符串为空，直接返回结果 res。</span></span><br><span class="line">        <span class="keyword">if</span>(index==n)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断字符串中的符号位。如果当前字符是 &#x27;+&#x27;，则将索引 index 向后移动一位；如果当前字符是 &#x27;-&#x27;，则将结果 res 乘以 -1，并将索引 index 向后移动一位。</span></span><br><span class="line">        <span class="type">int</span> sign=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[index]==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[index]==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            sign=<span class="number">-1</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 进入一个循环，从当前索引 index 开始遍历字符串中的每个字符，直到遍历完整个字符串。</span></span><br><span class="line">        <span class="keyword">while</span>(index&lt;n)&#123;</span><br><span class="line">            <span class="type">char</span> c=s[index];</span><br><span class="line">            <span class="comment">// 判断当前字符 c 是否为数字字符。如果不是，跳出循环。这里使用 ASCII 码的范围进行判断，&#x27;0&#x27; 对应 ASCII 码为 48，&#x27;9&#x27; 对应 ASCII 码为 57。</span></span><br><span class="line">            <span class="keyword">if</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前字符 c 是数字字符，进入判断条件。首先，判断当前的结果是否超出了整数类型 int 的范围。如果 res 大于 INT_MAX/10 或者等于 INT_MAX/10 且当前字符转换为数字后大于 INT_MAX 的个位数，则返回 INT_MAX。同样的，如果 res 小于 INT_MIN/10 或者等于 INT_MIN/10 且当前字符转换为数字后小于 INT_MIN 的个位数，则返回 INT_MIN。</span></span><br><span class="line">            <span class="keyword">if</span>(res&gt;INT_MAX/<span class="number">10</span>||(res==INT_MAX/<span class="number">10</span>&amp;&amp;(c-<span class="string">&#x27;0&#x27;</span>)&gt;INT_MAX%<span class="number">10</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(res&lt;INT_MIN/<span class="number">10</span>||(res==INT_MIN/<span class="number">10</span>&amp;&amp;(c-<span class="string">&#x27;0&#x27;</span>&lt;INT_MIN%<span class="number">10</span>)))&#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前结果没有超出 int 范围，执行数值的更新操作。将 res 乘以 10 并加上当前字符 c 减去字符 &#x27;0&#x27; 的结果，同时乘以符号位 sign，在第一次进入循环时，默认 sign 为 1。</span></span><br><span class="line">            res=res*<span class="number">10</span>+sign*(c-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 循环结束后，返回最终的结果 res。</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>具体步骤如下：</p><ol><li><p>首先，定义变量 res（用于存储最终结果）、index（用于表示当前遍历到的字符索引）、n（字符串的长度），并初始化为零。</p></li><li><p>使用 while 循环跳过字符串开头的空格，如果遇到空格，则将索引 index 向后移动一位。直到遇到非空格字符或遍历完整个字符串。</p></li><li><p>在上一步结束后，判断索引 index 是否已经达到了字符串的末尾。如果是，说明字符串为空，直接返回结果 res。</p></li><li><p>接下来，判断字符串中的符号位。如果当前字符是 ‘+’，则将索引 index 向后移动一位；如果当前字符是 ‘-‘，则将结果 res 乘以 -1，并将索引 index 向后移动一位。</p></li><li><p>进入一个循环，从当前索引 index 开始遍历字符串中的每个字符，直到遍历完整个字符串。</p></li><li><p>判断当前字符 c 是否为数字字符。如果不是，跳出循环。这里使用 ASCII 码的范围进行判断，’0’ 对应 ASCII 码为 48，’9’ 对应 ASCII 码为 57。</p></li><li><p>如果当前字符 c 是数字字符，进入判断条件。首先，判断当前的结果是否超出了整数类型 int 的范围。如果 res 大于 INT_MAX/10 或者等于 INT_MAX/10 且当前字符转换为数字后大于 INT_MAX 的个位数，则返回 INT_MAX。同样的，如果 res 小于 INT_MIN/10 或者等于 INT_MIN/10 且当前字符转换为数字后小于 INT_MIN 的个位数，则返回 INT_MIN。</p></li><li><p>如果当前结果没有超出 int 范围，执行数值的更新操作。将 res 乘以 10 并加上当前字符 c 减去字符 ‘0’ 的结果，同时乘以符号位 sign，在第一次进入循环时，默认 sign 为 1。</p></li><li><p>更新索引 index，并继续下一轮循环。</p></li><li><p>循环结束后，返回最终的结果 res。</p></li></ol><p>整个代码的思路是根据字符串的规则将字符转换为整数，并进行边界检查。INT_MAX 和 INT_MIN 是 C++ 中定义的整数最大值和最小值常量。</p><h2 id="No-4-JZ20-表示数值的字符串"><a href="#No-4-JZ20-表示数值的字符串" class="headerlink" title="No.4-JZ20 表示数值的字符串"></a>No.4-JZ20 表示数值的字符串</h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p><img src="http://sc1goen2r.hn-bkt.clouddn.com/monit4.png"></p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>这段代码是一个用于判断字符串是否表示数字的函数。下面是对代码的逐行注释解释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> index=<span class="number">0</span>; <span class="comment">// 初始化一个全局变量 index，用于记录当前遍历到的字符索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助函数 integer，用于判断正负符号后是否为非负整数</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">integer</span><span class="params">(string&amp; str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;str.<span class="built_in">size</span>()&amp;&amp;str[index]==<span class="string">&#x27;+&#x27;</span>||str[index]==<span class="string">&#x27;-&#x27;</span>)&#123; <span class="comment">// 如果当前字符是+或者-，则将索引向后移动一位</span></span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">unsigned_integer</span>(str); <span class="comment">// 调用 unsigned_integer 函数判断是否为非负整数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助函数 unsigned_integer，用于判断是否为非负整数</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unsigned_integer</span><span class="params">(string&amp; str)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> temp=index; <span class="comment">// 记录当前索引，用于判断是否存在数字字符</span></span><br><span class="line">        <span class="keyword">while</span>(index&lt;str.<span class="built_in">size</span>()&amp;&amp;str[index]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;str[index]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123; <span class="comment">// 如果当前字符是数字字符，则将索引向后移动一位</span></span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index&gt;temp; <span class="comment">// 判断是否存在数字字符</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主函数 isNumeric，用于判断字符串是否表示数字</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNumeric</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(str.<span class="built_in">size</span>()==<span class="number">0</span>)&#123; <span class="comment">// 如果字符串为空，返回 false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> n=str.<span class="built_in">size</span>()<span class="number">-1</span>; <span class="comment">// 字符串的长度减一</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(index&lt;=n&amp;&amp;str[index]==<span class="string">&#x27; &#x27;</span>)&#123; <span class="comment">// 跳过字符串开头的空格</span></span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(index&lt;=n&amp;&amp;str[n]==<span class="string">&#x27; &#x27;</span>)&#123; <span class="comment">// 跳过字符串末尾的空格</span></span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(index&gt;n)&#123; <span class="comment">// 如果索引超过了字符串的末尾，返回 false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n++; <span class="comment">// 为了后续判断方便，将字符串长度加一</span></span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> flag=<span class="built_in">integer</span>(str); <span class="comment">// 判断是否为整数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(index&lt;n&amp;&amp;str[index]==<span class="string">&#x27;.&#x27;</span>)&#123; <span class="comment">// 如果当前字符是小数点</span></span><br><span class="line">            index++;</span><br><span class="line">            flag=<span class="built_in">integer</span>(str)||flag; <span class="comment">// 判断是否为小数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(index&lt;n&amp;&amp;(str[index]==<span class="string">&#x27;e&#x27;</span>||str[index]==<span class="string">&#x27;E&#x27;</span>))&#123; <span class="comment">// 如果当前字符是 e 或 E</span></span><br><span class="line">            index++;</span><br><span class="line">            flag=flag&amp;&amp;<span class="built_in">integer</span>(str); <span class="comment">// 判断是否为科学计数法表示的数值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag&amp;&amp;(index==n); <span class="comment">// 判断是否满足数字表示的条件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用有限状态自动机（Finite-state automaton）的思想，根据数字的合法性设计一个状态转移图。下面是具体步骤：</p><ol><li><p>初始化全局变量 index，用于记录当前遍历到的字符索引。</p></li><li><p>定义两个辅助函数 integer 和 unsigned_integer，用于判断是否为整数或非负整数。</p></li><li><p>主函数 isNumeric 中，首先判断字符串是否为空，如果为空则返回 false，并将字符串长度减一。</p></li><li><p>使用 while 循环跳过字符串开头和末尾的空格，并在每次循环后更新字符索引和字符串长度。</p></li><li><p>如果索引超过了字符串的末尾，返回 false。</p></li><li><p>调用 integer 函数判断正负符号后是否为非负整数，并将结果保存在 flag 变量中。</p></li><li><p>如果当前字符是小数点，则将索引向后移动一位，并调用 integer 函数判断是否为小数，并用或运算将结果保存在 flag 变量中。</p></li><li><p>如果当前字符是 e 或 E，则将索引向后移动一位，并调用 integer 函数判断是否为科学计数法表示的数值，并用与运算将结果保存在 flag 变量中。</p></li><li><p>最后判断是否满足数字表示的条件：flag 为 true，并且字符索引等于字符串长度。</p></li><li><p>如果满足条件则返回 true，否则返回 false。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据结构算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Search Algorithm for the Special Topic of &quot;Sword Finger Offer&quot;</title>
      <link href="/2023/09/11/Search-Algorithm-for-the-Special-Topic-of-Sword-Finger-Offer/"/>
      <url>/2023/09/11/Search-Algorithm-for-the-Special-Topic-of-Sword-Finger-Offer/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>搜索算法是计算机科学中的核心概念之一，它可以帮助我们高效地在大规模数据集中查找目标，解决实际问题。《剑指offer》中包含了许多关于搜索算法的具体题目。通过学习和思考这些题目，并结合详细的解题思路和代码实现，我们可以提高自己的算法设计和编程能力。在本篇博客中，我将分享5道在《剑指offer》中出现的搜索算法题目，并给出相应的解题思路和代码示例，希望能够对读者有所启发。</p><h2 id="No-1-数字在升序数组中出现的次数-JZ53"><a href="#No-1-数字在升序数组中出现的次数-JZ53" class="headerlink" title="No.1-数字在升序数组中出现的次数(JZ53)"></a>No.1-数字在升序数组中出现的次数(JZ53)</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个长度为 n 的非降序数组和一个非负数整数 k ，要求统计 k 在数组中出现的次数</p><p>数据范围:0&lt;=n&lt;=1000,0&lt;=k&lt;=100，数组中每个素的值满足0&lt;= val&lt;= 100<br>要求: 空间复杂度0(1)，时间复杂度 O（logn）</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bisearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; data, <span class="type">float</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = data.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 初始化左右指针，分别指向数组的首尾位置</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 使用二分查找进行循环，直到左右指针相遇</span></span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>; <span class="comment">// 计算中间位置</span></span><br><span class="line">            <span class="keyword">if</span> (data[mid] &lt; k) &#123; <span class="comment">// 如果中间值小于目标值</span></span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// 更新左指针为中间位置的右侧一位</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data[mid] &gt; k) &#123; <span class="comment">// 如果中间值大于目标值</span></span><br><span class="line">                right = mid - <span class="number">1</span>; <span class="comment">// 更新右指针为中间位置的左侧一位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left; <span class="comment">// 返回左指针，即第一个大于等于目标值的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetNumberOfK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bisearch</span>(nums, k + <span class="number">0.5</span>) - <span class="built_in">bisearch</span>(nums, k - <span class="number">0.5</span>); <span class="comment">// 查找第一个大于等于 k+1 的元素位置减去第一个大于等于 k 的元素位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>bisearch</code> 函数使用二分查找算法，在有序数组 <code>data</code> 中查找第一个大于等于目标值 <code>k</code> 的元素的位置。</li><li><code>left</code> 和 <code>right</code> 变量分别初始化为数组的首尾位置。</li><li>在 <code>while</code> 循环中，通过计算数组的中间位置 <code>mid</code>，更新左右指针的位置。</li><li>如果中间值小于目标值 <code>k</code>，则将左指针 <code>left</code> 更新为中间位置 <code>mid+1</code>，查找范围缩小为右半边。</li><li>如果中间值大于目标值 <code>k</code>，则将右指针 <code>right</code> 更新为中间位置 <code>mid-1</code>，查找范围缩小为左半边。</li><li>当左指针 <code>left</code> 和右指针 <code>right</code> 相遇时，跳出循环，返回左指针 <code>left</code> 的值，即第一个大于等于目标值的位置。</li><li><code>GetNumberOfK</code> 函数是主要的解题函数，在有序数组 <code>nums</code> 中查找目标值 <code>k</code> 的个数。</li><li>首先判断数组是否为空，如果为空，则直接返回 0。</li><li>调用 <code>bisearch(nums, k + 0.5)</code> 查找第一个大于等于 <code>k+1</code> 的元素位置，再调用 <code>bisearch(nums, k - 0.5)</code> 查找第一个大于等于 <code>k</code> 的元素位置。</li><li>返回这两个位置的差值，即目标值 <code>k</code> 在数组中出现的次数。</li></ul><h2 id="No-2-二维数组中的查找（JZ4）"><a href="#No-2-二维数组中的查找（JZ4）" class="headerlink" title="No.2-二维数组中的查找（JZ4）"></a>No.2-二维数组中的查找（JZ4）</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>在一个二维数组array中(每个一维数组的长度相同)，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数<br>[<br>[1,2,8,9],<br>[2,4,9,12],<br>[4,7,10,13],<br>[6,8,11,15]<br>]<br>给定 target= 7，返回 true。<br>给定 target = 3，返回 false.<br>数据范围: 短阵的长宽满足0&lt;=n,m&lt;=500，矩阵中的值满足0&lt;= val&lt;= 10^9<br>进阶:空间复杂度O(1)，时间复杂度 O(n +m)</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>算法思路：</p><ol><li>首先对输入进行判断，如果二维数组为空或者其中一行为空，则直接返回 <code>false</code>。</li><li>初始化两个指针 <code>i</code> 和 <code>j</code>，分别指向数组的最后一行和第一列。</li><li>进入循环，循环条件为 <code>i &gt;= 0 &amp;&amp; j &lt;= column</code>，即当指针 <code>i</code> 没有越界并且指针 <code>j</code> 没有越界时进行循环。</li><li>在循环中，通过比较目标值 <code>target</code> 与当前元素 <code>array[i][j]</code> 的大小，来决定指针的移动方向。</li><li>如果 <code>target</code> 小于当前元素，则应该向上移动，将指针 <code>i</code> 减 1。</li><li>如果 <code>target</code> 大于当前元素，则应该向右移动，将指针 <code>j</code> 加 1。</li><li>如果 <code>target</code> 等于当前元素，表示找到了目标值，直接返回 <code>true</code>。</li><li>当循环结束时，说明二维数组中没有找到目标值，返回 <code>false</code>。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> target, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;&amp; array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.<span class="built_in">size</span>() == <span class="number">0</span>) &#123; <span class="comment">// 判断二维数组是否为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (array[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) &#123; <span class="comment">// 判断二维数组的第一行是否为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> row = array.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 获取二维数组的行数</span></span><br><span class="line">    <span class="type">int</span> column = array[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 获取二维数组的列数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row, j = <span class="number">0</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt;= column;) &#123; <span class="comment">// 初始化两个指针，分别指向二维数组的最后一行和第一列，并进入循环</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; array[i][j]) &#123; <span class="comment">// 如果目标值小于当前元素</span></span><br><span class="line">            i--; <span class="comment">// 向上移动指针 i</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; array[i][j]) &#123; <span class="comment">// 如果目标值大于当前元素</span></span><br><span class="line">            j++; <span class="comment">// 向右移动指针 j</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果目标值等于当前元素，找到目标值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 循环结束，未找到目标值，返回 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上所述，通过初始化两个指针，利用二维有序数组特性，在遍历过程中逐行逐列缩小查找范围，最终找到目标值或者确定不存在目标值。时间复杂度为 O(m + n)，其中 m 和 n 分别为二维数组的行数和列数。</p><h2 id="No-3-旋转数组的最小数字-JZ11"><a href="#No-3-旋转数组的最小数字-JZ11" class="headerlink" title="No.3-旋转数组的最小数字(JZ11)"></a>No.3-旋转数组的最小数字(JZ11)</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>有一个长度为n 的非降序数组，比如[1,2,3,4,5],将它进行旋转，即把一个数组最开始的若干个元素搬到数组的未尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。<br>数据范围:1&lt;=n&lt;=10000，数组中任意元素的值:0&lt;= val&lt;= 10000<br>要求: 空间复杂度:O(1)，时间复杂度: (logn)</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="comment">// 计算中间位置</span></span><br><span class="line">        <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&gt;nums[right])&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>; <span class="comment">// 如果中间元素大于右边界元素，则最小值一定在 mid 右侧</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]==nums[right])&#123;</span><br><span class="line">            right--; <span class="comment">// 如果中间元素等于右边界元素，则无法判断最小值位于哪一侧，将右边界左移</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right=mid; <span class="comment">// 如果中间元素小于右边界元素，则最小值可能为 mid 或在 mid 的左侧</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left]; <span class="comment">// 循环结束时，左指针指向最小值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法思路：</p><ol><li>使用二分查找的思想，在循环中不断缩小搜索范围。</li><li>初始时，左指针 <code>left</code> 指向数组的第一个元素，右指针 <code>right</code> 指向数组的最后一个元素。</li><li>进入循环，循环条件为 <code>left &lt; right</code>，即左指针小于右指针时进行循环。</li><li>在循环中，首先计算中间位置 <code>mid</code>，避免溢出的方式是使用 <code>left + (right - left) / 2</code>。</li><li>接下来根据中间位置元素和右边界元素的比较，更新左指针和右指针的位置：<ul><li>如果中间元素大于右边界元素，则最小值一定在右侧，将左指针移到中间元素的右侧 <code>mid + 1</code>。</li><li>如果中间元素等于右边界元素，则无法判断最小值位于哪一侧，将右指针左移 <code>right--</code>。</li><li>如果中间元素小于右边界元素，则最小值可能为中间元素或者在中间元素的左侧，将右指针移到中间元素位置 <code>right = mid</code>。</li></ul></li><li>当循环结束时，左指针 <code>left</code> 指向最小值，返回 <code>nums[left]</code>。</li></ol><p>综上所述，利用二分查找的思想在旋转有序数组中寻找最小值，并通过不断更新左右指针的位置逐渐缩小搜索范围，最终找到最小值。时间复杂度为 O(logn)，其中 n 是数组的长度。</p><h2 id="No-4-字符串的排列-JZ38"><a href="#No-4-字符串的排列-JZ38" class="headerlink" title="No.4-字符串的排列(JZ38)"></a>No.4-字符串的排列(JZ38)</h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>输入一个长度为 n 字符串，打印出该字符串中字符的所有排列，你可以以任意顺序返回这个字符串数组例如输入字符串ABC,则输出由字符ABC所能排列出来的所有字符串ABC，ACB,BAC，BCA，CBA和CAB.<br>数据范围:n&lt;10<br>要求: 空间复杂度:O(n!)，时间复杂度: O(n!)</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param str string字符串 </span></span><br><span class="line"><span class="comment">     * @return string字符串vector</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归函数，用于生成字符串的全排列</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recursion</span><span class="params">(vector&lt;string&gt;&amp; res, string&amp; str, string&amp; temp, vector&lt;<span class="type">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.<span class="built_in">size</span>() == str.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp); <span class="comment">// 如果临时字符串的长度等于输入字符串的长度，则将临时字符串加入结果集</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 如果字符已经使用过，则跳过该字符</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; str[i - <span class="number">1</span>] == str[i] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 如果当前字符和前一个字符相等，并且前一个字符未被使用，则跳过该字符</span></span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="literal">true</span>; <span class="comment">// 标记当前字符为已使用</span></span><br><span class="line">            temp.<span class="built_in">push_back</span>(str[i]); <span class="comment">// 将当前字符加入临时字符串</span></span><br><span class="line">            <span class="built_in">recursion</span>(res, str, temp, used); <span class="comment">// 递归调用生成字符串的全排列</span></span><br><span class="line">            used[i] = <span class="literal">false</span>; <span class="comment">// 恢复当前字符为未使用状态</span></span><br><span class="line">            temp.<span class="built_in">pop_back</span>(); <span class="comment">// 移除临时字符串的最后一个字符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符串排列函数</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">Permutation</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先，如果输入字符串为空，则返回空结果容器</span></span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (str.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sort</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>()); <span class="comment">// 对字符串进行排序，确保相同字符相邻</span></span><br><span class="line">        string temp; <span class="comment">// 定义一个临时字符串，用于存储正在排列的字符串</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(str.size(), <span class="literal">false</span>)</span></span>; <span class="comment">// 定义一个容器，初始化为false，表示各个字符是否使用过</span></span><br><span class="line">        <span class="built_in">recursion</span>(res, str, temp, used); <span class="comment">// 递归调用生成字符串的全排列</span></span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回结果容器，不包含重复的排列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>算法思路如下：</p><ol><li>首先检查输入的字符串是否为空，如果为空，则直接返回空的结果容器。</li><li>对输入的字符串进行排序，确保相同字符相邻。这一步是为了在后面生成排列时避免生成重复的结果。</li><li>定义一个递归函数<code>recursion</code>，该函数用于生成字符串的全排列。</li><li>在递归函数中，首先判断临时字符串的长度是否等于输入字符串的长度，如果是，则将临时字符串加入结果容器。</li><li>接下来，使用一个循环遍历输入字符串的每个字符。对于每个字符，进行以下判断：<ul><li>如果字符已经被使用过（在标记数组<code>used</code>中为<code>true</code>），则跳过该字符。</li><li>如果当前字符与它前面的字符相等，并且前一个字符未被使用过，则跳过该字符。这是为了避免生成重复的排列。</li></ul></li><li>如果当前字符可以使用，则将其标记为已使用（在标记数组<code>used</code>中设为<code>true</code>），并将其加入临时字符串。</li><li>递归调用<code>recursion</code>函数，继续生成剩余字符的排列。</li><li>在递归调用后，恢复当前字符的状态（在标记数组<code>used</code>中设为<code>false</code>），并从临时字符串中移除最后一个字符。</li><li>返回结果容器。<br>总结来说，通过递归生成字符串的全排列，通过标记数组记录字符的使用情况，并在生成过程中进行判断和剪枝，避免生成重复的排列。最后返回生成的结果容器。</li></ol><h2 id="No-5-数字序列中某一位的数字-JZ44"><a href="#No-5-数字序列中某一位的数字-JZ44" class="headerlink" title="No.5-数字序列中某一位的数字(JZ44)"></a>No.5-数字序列中某一位的数字(JZ44)</h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>数字以0123456789101112131415… 的格式作为一个字符序列，在这个序列中第 2位(从下标0开始计算)是2,第 10 位是 1，第 13 位是 1，以此类题，请你输出第 n 位对应的数字<br>数据范围: 0 &lt;= n &lt;= 10^9</p><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> digit = <span class="number">1</span>; <span class="comment">// 定义位数</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> start = <span class="number">1</span>; <span class="comment">// 定义起始数字，这里使用long long类型，是为了避免start平方后溢出</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">9</span>; <span class="comment">// 定义当前位数下所有数字的总位数</span></span><br><span class="line">        <span class="keyword">while</span> (n &gt; sum) &#123; <span class="comment">// 循环，直到n小于等于当前位数下所有数字的总位数</span></span><br><span class="line">            n -= sum; <span class="comment">// 将n减去当前位数下所有数字的总位数</span></span><br><span class="line">            digit++; <span class="comment">// 位数加1</span></span><br><span class="line">            start *= <span class="number">10</span>; <span class="comment">// 起始数字乘以10</span></span><br><span class="line">            sum = <span class="number">9</span> * digit * start; <span class="comment">// 重新计算当前位数下所有数字的总位数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num=start+(n<span class="number">-1</span>)/digit; <span class="comment">// 求出第n个数字所在的数字</span></span><br><span class="line">        <span class="type">int</span> index=(n<span class="number">-1</span>)%digit; <span class="comment">// 求出第n个数字在该数字中的下标</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">to_string</span>(num)[index])-<span class="string">&#x27;0&#x27;</span>; <span class="comment">// 将第n个数字转换为字符，并返回其对应的整数值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>算法思路如下：</p><ol><li>首先定义变量 <code>digit</code>（位数）初始化为1，变量 <code>start</code>（起始数字）初始化为1，变量 <code>sum</code>（当前位数下所有数字的总位数）初始化为9。</li><li>使用循环，直到 <code>n</code> 小于等于当前位数下所有数字的总位数：<ul><li>在循环开始时，将 <code>n</code> 减去 <code>sum</code>。</li><li>将 <code>digit</code> 增加1。</li><li>将 <code>start</code> 乘以10。</li><li>计算新的 <code>sum</code> 值为 9 * <code>digit</code> * <code>start</code>。</li></ul></li><li>当循环结束后，表示 <code>n</code> 在当前位数范围内找到了对应的数字。此时， <code>n</code> 表示相对于起始数字 <code>start</code> 的偏移值。</li><li>计算第 <code>n</code> 个数字所在的具体数字：<ul><li>将 <code>num</code> 设为 <code>start + (n - 1) / digit</code>。其中 <code>(n - 1) / digit</code> 表示找到的数字在当前位数范围内的偏移量，加上起始数字 <code>start</code> 即可得到具体数字。</li></ul></li><li>计算第 <code>n</code> 个数字在该数字中的位置：<ul><li>将 <code>index</code> 设为 <code>(n - 1) % digit</code>。其中 <code>(n - 1) % digit</code> 表示找到的数字在当前数字中的下标。</li></ul></li><li>将第 <code>n</code> 个数字转换为字符，并返回其对应的整数值：<ul><li>将 <code>num</code> 转换为字符串，取第 <code>index</code> 个字符，并将其转换为整数类型。</li><li>返回转换后的整数值。<br>总结来说，通过计算每个数字长度和总位数之和，快速定位第 <code>n</code> 个数字所在的区间，然后再通过简单的计算求出第 <code>n</code> 个数字所在的数字以及它在该数字中的位置，并返回该数字对应的整数值。</li></ul></li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>通过本篇博客，读者可以了解到《剑指offer》中与搜索算法相关的题目，并通过详细的解题思路和代码实现，掌握各种常见的搜索算法。搜索算法是计算机科学中的重要内容，它不仅在面试和算法竞赛中起到关键作用，也可以在实际工程项目中发挥重要作用。希望本文能够帮助读者提高算法设计和编程能力，并在实际问题中运用搜索算法解决难题。</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据结构算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI Tools</title>
      <link href="/2023/09/08/AI-Tools/"/>
      <url>/2023/09/08/AI-Tools/</url>
      
        <content type="html"><![CDATA[<h2 id="1-AI-应用"><a href="#1-AI-应用" class="headerlink" title="1. AI 应用"></a>1. AI 应用</h2><h3 id="文心一言-https-yiyan-baidu-com"><a href="#文心一言-https-yiyan-baidu-com" class="headerlink" title="文心一言: https://yiyan.baidu.com/"></a>文心一言: <a href="https://yiyan.baidu.com/">https://yiyan.baidu.com/</a></h3><p>百度出品的人工智能语言模型</p><h3 id="ChatGPT-https-chat-openai-com"><a href="#ChatGPT-https-chat-openai-com" class="headerlink" title="ChatGPT: https://chat.openai.com/"></a>ChatGPT: <a href="https://chat.openai.com/">https://chat.openai.com/</a></h3><p>一款功能丰富、智能化、易用性强的人工智能工具，适用于各种内容创作者</p><h3 id="Notion-AI-https-www-notion-so"><a href="#Notion-AI-https-www-notion-so" class="headerlink" title="Notion AI: https://www.notion.so/"></a>Notion AI: <a href="https://www.notion.so/">https://www.notion.so/</a></h3><p>这是真人工智能，不是人工智障</p><h3 id="Stable-Diffusion-WebUI-https-github-com-AUTOMATIC1111-stable-diffusion-webui"><a href="#Stable-Diffusion-WebUI-https-github-com-AUTOMATIC1111-stable-diffusion-webui" class="headerlink" title="Stable Diffusion WebUI: https://github.com/AUTOMATIC1111/stable-diffusion-webui"></a>Stable Diffusion WebUI: <a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui">https://github.com/AUTOMATIC1111/stable-diffusion-webui</a></h3><p>Github 源码，可以自己搭建一个 Stable Diffusion 算法的 Web 版</p><h3 id="头像生成卡通-https-toonme-com"><a href="#头像生成卡通-https-toonme-com" class="headerlink" title="头像生成卡通: https://toonme.com/"></a>头像生成卡通: <a href="https://toonme.com/">https://toonme.com/</a></h3><p>把头像交给 AI，实现你的卡通梦</p><h2 id="2-AI-写作"><a href="#2-AI-写作" class="headerlink" title="2. AI 写作"></a>2. AI 写作</h2><h3 id="FlowUs-https-flowus-cn-login"><a href="#FlowUs-https-flowus-cn-login" class="headerlink" title="FlowUs: https://flowus.cn/login"></a>FlowUs: <a href="https://flowus.cn/login">https://flowus.cn/login</a></h3><p>一款具有特色的、 Notion 类的 All in One 生产力工具</p><h3 id="Compose-AI-https-www-compose-ai"><a href="#Compose-AI-https-www-compose-ai" class="headerlink" title="Compose AI: https://www.compose.ai/"></a>Compose AI: <a href="https://www.compose.ai/">https://www.compose.ai/</a></h3><p>AI写作工具</p><h3 id="Jasper-https-www-jasper-ai"><a href="#Jasper-https-www-jasper-ai" class="headerlink" title="Jasper: https://www.jasper.ai/"></a>Jasper: <a href="https://www.jasper.ai/">https://www.jasper.ai/</a></h3><p>文本生成器，使用 AI 制作出令人惊叹的文案</p><h3 id="Elephas-https-elephas-app"><a href="#Elephas-https-elephas-app" class="headerlink" title="Elephas: https://elephas.app/"></a>Elephas: <a href="https://elephas.app/">https://elephas.app/</a></h3><p>适用于Mac的个人AI写作助手</p><h3 id="Everylead-https-www-everylead-ai"><a href="#Everylead-https-www-everylead-ai" class="headerlink" title="Everylead: https://www.everylead.ai/"></a>Everylead: <a href="https://www.everylead.ai/">https://www.everylead.ai/</a></h3><p>个性化每条线索</p><h2 id="3-AI-编程"><a href="#3-AI-编程" class="headerlink" title="3. AI 编程"></a>3. AI 编程</h2><h3 id="autobackend-https-www-autobackend-dev"><a href="#autobackend-https-www-autobackend-dev" class="headerlink" title="autobackend: https://www.autobackend.dev/"></a>autobackend: <a href="https://www.autobackend.dev/">https://www.autobackend.dev/</a></h3><p>在几秒钟内创建一个后端</p><h3 id="BerriAI-https-berri-ai"><a href="#BerriAI-https-berri-ai" class="headerlink" title="BerriAI: https://berri.ai/"></a>BerriAI: <a href="https://berri.ai/">https://berri.ai/</a></h3><p>连接您的数据并在几分钟内建立生产就绪的chatGPT应用程序</p><h3 id="AutoRegex-https-www-autoregex-xyz"><a href="#AutoRegex-https-www-autoregex-xyz" class="headerlink" title="AutoRegex: https://www.autoregex.xyz/"></a>AutoRegex: <a href="https://www.autoregex.xyz/">https://www.autoregex.xyz/</a></h3><p>使用人工智能更容易创建正则表达式</p><h3 id="Tabnine-https-www-tabnine-com"><a href="#Tabnine-https-www-tabnine-com" class="headerlink" title="Tabnine: https://www.tabnine.com/"></a>Tabnine: <a href="https://www.tabnine.com/">https://www.tabnine.com/</a></h3><p>是一个AI代码助手</p><h3 id="Code-Snippets-https-codesnippets-ai"><a href="#Code-Snippets-https-codesnippets-ai" class="headerlink" title="Code Snippets: https://codesnippets.ai/"></a>Code Snippets: <a href="https://codesnippets.ai/">https://codesnippets.ai/</a></h3><p>GPT-4驱动的VSCode的代码片段</p><h2 id="4-AI-设计"><a href="#4-AI-设计" class="headerlink" title="4. AI 设计"></a>4. AI 设计</h2><h3 id="Adobe-Firefly-https-firefly-adobe-com"><a href="#Adobe-Firefly-https-firefly-adobe-com" class="headerlink" title="Adobe Firefly: https://firefly.adobe.com/"></a>Adobe Firefly: <a href="https://firefly.adobe.com/">https://firefly.adobe.com/</a></h3><p>用Firefly做出无限的创作</p><h3 id="Fiction-https-www-fiction-com"><a href="#Fiction-https-www-fiction-com" class="headerlink" title="Fiction: https://www.fiction.com/"></a>Fiction: <a href="https://www.fiction.com/">https://www.fiction.com/</a></h3><p>AI照片和头像生成器</p><h3 id="Uizard-https-uizard-io-autodesigner"><a href="#Uizard-https-uizard-io-autodesigner" class="headerlink" title="Uizard: https://uizard.io/autodesigner/"></a>Uizard: <a href="https://uizard.io/autodesigner/">https://uizard.io/autodesigner/</a></h3><p>使用简单的文本来生成应用程序和网站的多屏幕模拟图</p><h3 id="Contentinator-https-contentinator-com"><a href="#Contentinator-https-contentinator-com" class="headerlink" title="Contentinator: https://contentinator.com/"></a>Contentinator: <a href="https://contentinator.com/">https://contentinator.com/</a></h3><p>为您的 Figma 设计生成逼真的内容</p><h3 id="Galileo-AI-https-www-usegalileo-ai"><a href="#Galileo-AI-https-www-usegalileo-ai" class="headerlink" title="Galileo AI: https://www.usegalileo.ai/"></a>Galileo AI: <a href="https://www.usegalileo.ai/">https://www.usegalileo.ai/</a></h3><p>界面设计的副手</p><h2 id="5-AI-作图"><a href="#5-AI-作图" class="headerlink" title="5. AI 作图"></a>5. AI 作图</h2><h3 id="PicWish-https-picwish-com"><a href="#PicWish-https-picwish-com" class="headerlink" title="PicWish: https://picwish.com/"></a>PicWish: <a href="https://picwish.com/">https://picwish.com/</a></h3><p>一个多功能的图像创意平台</p><h3 id="Stable-Diffusion-https-stability-ai"><a href="#Stable-Diffusion-https-stability-ai" class="headerlink" title="Stable Diffusion: https://stability.ai/"></a>Stable Diffusion: <a href="https://stability.ai/">https://stability.ai/</a></h3><p>AI 绘画，输入关键字生成图片</p><h3 id="Civitai-https-civitai-com"><a href="#Civitai-https-civitai-com" class="headerlink" title="Civitai: https://civitai.com/"></a>Civitai: <a href="https://civitai.com/">https://civitai.com/</a></h3><p>训练好的模型分享网站</p><h3 id="文心一格-https-yige-baidu-com-creation"><a href="#文心一格-https-yige-baidu-com-creation" class="headerlink" title="文心一格: https://yige.baidu.com/creation"></a>文心一格: <a href="https://yige.baidu.com/creation">https://yige.baidu.com/creation</a></h3><p>百度 AI 产品，创意和艺术辅助产品</p><h3 id="Nijijourney-https-nijijourney-com-zh"><a href="#Nijijourney-https-nijijourney-com-zh" class="headerlink" title="Nijijourney: https://nijijourney.com/zh/"></a>Nijijourney: <a href="https://nijijourney.com/zh/">https://nijijourney.com/zh/</a></h3><p>魔法般的二次元绘画生成</p><h2 id="6-AI-训练模型"><a href="#6-AI-训练模型" class="headerlink" title="6. AI 训练模型"></a>6. AI 训练模型</h2><h3 id="Codex-https-openai-com-blog-openai-codex"><a href="#Codex-https-openai-com-blog-openai-codex" class="headerlink" title="Codex: https://openai.com/blog/openai-codex"></a>Codex: <a href="https://openai.com/blog/openai-codex">https://openai.com/blog/openai-codex</a></h3><p>OpenAI 旗下 AI 代码生成训练模型，AI 系统可以将自然语言翻译成代码，</p><h3 id="Imagen-https-imagen-research-google"><a href="#Imagen-https-imagen-research-google" class="headerlink" title="Imagen: https://imagen.research.google/"></a>Imagen: <a href="https://imagen.research.google/">https://imagen.research.google/</a></h3><p>文本到图像扩散模型</p><h3 id="LLaMA-https-github-com-facebookresearch-llama"><a href="#LLaMA-https-github-com-facebookresearch-llama" class="headerlink" title="LLaMA: https://github.com/facebookresearch/llama"></a>LLaMA: <a href="https://github.com/facebookresearch/llama">https://github.com/facebookresearch/llama</a></h3><p>火焰模型推理代码</p><h3 id="Lobe-https-www-lobe-ai"><a href="#Lobe-https-www-lobe-ai" class="headerlink" title="Lobe: https://www.lobe.ai/"></a>Lobe: <a href="https://www.lobe.ai/">https://www.lobe.ai/</a></h3><p>一个免费、易于使用的工具来训练机器学习模型</p><h3 id="Scale-https-scale-com"><a href="#Scale-https-scale-com" class="headerlink" title="Scale: https://scale.com/"></a>Scale: <a href="https://scale.com/">https://scale.com/</a></h3><p>加快人工智能应用的发展</p><h2 id="7-AI-效率助手"><a href="#7-AI-效率助手" class="headerlink" title="7. AI 效率助手"></a>7. AI 效率助手</h2><h3 id="Tome-AI-https-beta-tome-app"><a href="#Tome-AI-https-beta-tome-app" class="headerlink" title="Tome AI: https://beta.tome.app/"></a>Tome AI: <a href="https://beta.tome.app/">https://beta.tome.app/</a></h3><p>由AI驱动的讲故事形式</p><h3 id="IngestAI-https-ingestai-io"><a href="#IngestAI-https-ingestai-io" class="headerlink" title="IngestAI: https://ingestai.io/"></a>IngestAI: <a href="https://ingestai.io/">https://ingestai.io/</a></h3><p>把你的知识库变成一个类似于ChatGPT的上下文感知机器人</p><h3 id="Resume-Worded-https-resumeworded-com-index-php"><a href="#Resume-Worded-https-resumeworded-com-index-php" class="headerlink" title="Resume Worded: https://resumeworded.com/index.php"></a>Resume Worded: <a href="https://resumeworded.com/index.php">https://resumeworded.com/index.php</a></h3><p>是一个在线简历改进工具</p><h3 id="ChatExcel-https-chatexcel-com"><a href="#ChatExcel-https-chatexcel-com" class="headerlink" title="ChatExcel: https://chatexcel.com/"></a>ChatExcel: <a href="https://chatexcel.com/">https://chatexcel.com/</a></h3><p>仅通过聊天来操控您的Excel表格</p><h3 id="ChatBCG-https-www-chatbcg-com"><a href="#ChatBCG-https-www-chatbcg-com" class="headerlink" title="ChatBCG: https://www.chatbcg.com/"></a>ChatBCG: <a href="https://www.chatbcg.com/">https://www.chatbcg.com/</a></h3><p>一个通过AI生成PPT的工具</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI工具分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Terminal Commands</title>
      <link href="/2023/09/08/Linux-Terminal-Commands/"/>
      <url>/2023/09/08/Linux-Terminal-Commands/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux终端命令，让你的工作更高效"><a href="#Linux终端命令，让你的工作更高效" class="headerlink" title="Linux终端命令，让你的工作更高效"></a>Linux终端命令，让你的工作更高效</h1><h2 id="目录导航"><a href="#目录导航" class="headerlink" title="目录导航"></a>目录导航</h2><ol><li><a href="#1-linux%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F">Linux终端命令格式</a></li><li><a href="#2-%E6%9F%A5%E9%98%85%E5%91%BD%E4%BB%A4%E5%B8%AE%E5%8A%A9%E4%BF%A1%E6%81%AF">查阅命令帮助信息</a></li><li><a href="#3-%E5%B8%B8%E7%94%A8linux%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%94%A8">常用Linux命令的基本实用</a></li><li><a href="#4-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">文件和目录常用命令</a></li><li><a href="#5-%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4">系统信息相关命令</a></li><li><a href="#6-%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4">用户权限相关命令</a></li><li><a href="#7-%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">远程管理常用命令</a></li><li><a href="#8-%E7%BB%93%E8%AF%AD">结语</a></li></ol><h2 id="1-Linux终端命令格式"><a href="#1-Linux终端命令格式" class="headerlink" title="1. Linux终端命令格式"></a>1. Linux终端命令格式</h2><p>在学习Linux终端命令之前，我们需要先了解它们的基本结构和格式。通常情况下，每个终端命令由命令名称、选项和参数组成。命令名称表示要执行的操作，选项用于修改命令的行为，参数指定操作的对象。</p><p>命令格式示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> -option argument</span><br></pre></td></tr></table></figure><h2 id="2-查阅命令帮助信息"><a href="#2-查阅命令帮助信息" class="headerlink" title="2. 查阅命令帮助信息"></a>2. 查阅命令帮助信息</h2><p>当我们遇到一个新的命令时，我们往往需要查阅其帮助文档来了解其功能和使用方法。Linux系统提供了多种方式来获取命令的帮助信息。</p><ul><li><code>command --help</code>：使用该选项可以查看命令的简要帮助信息。</li><li><code>man command</code>：使用该命令可以查看命令的详细帮助文档。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> --<span class="built_in">help</span></span><br><span class="line">man <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><h2 id="3-常用Linux命令的基本实用"><a href="#3-常用Linux命令的基本实用" class="headerlink" title="3. 常用Linux命令的基本实用"></a>3. 常用Linux命令的基本实用</h2><p>下面列举了一些常用的Linux命令，这些命令可以帮助你在终端中更高效地操作文件和目录、获取系统信息以及管理用户权限等。</p><h3 id="3-1-查看当前目录下的文件和文件夹"><a href="#3-1-查看当前目录下的文件和文件夹" class="headerlink" title="3.1 查看当前目录下的文件和文件夹"></a>3.1 查看当前目录下的文件和文件夹</h3><ul><li><code>ls</code>：列出当前目录下的文件和文件夹。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure><h3 id="3-2-切换目录"><a href="#3-2-切换目录" class="headerlink" title="3.2 切换目录"></a>3.2 切换目录</h3><ul><li><code>cd</code>：切换到指定目录。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/directory</span><br></pre></td></tr></table></figure><h3 id="3-3-查看文本文件内容"><a href="#3-3-查看文本文件内容" class="headerlink" title="3.3 查看文本文件内容"></a>3.3 查看文本文件内容</h3><ul><li><code>cat</code>：显示文本文件的内容。</li><li><code>less</code>：分页显示文本文件的内容。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> filename.txt</span><br><span class="line">less filename.txt</span><br></pre></td></tr></table></figure><h3 id="3-4-查找文件"><a href="#3-4-查找文件" class="headerlink" title="3.4 查找文件"></a>3.4 查找文件</h3><ul><li><code>find</code>：在指定路径下查找文件。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/search -name <span class="string">&quot;filename&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3-5-拷贝和移动文件"><a href="#3-5-拷贝和移动文件" class="headerlink" title="3.5 拷贝和移动文件"></a>3.5 拷贝和移动文件</h3><ul><li><code>cp</code>：拷贝文件或目录。</li><li><code>mv</code>：移动文件或目录。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /path/to/source /path/to/destination</span><br><span class="line"><span class="built_in">mv</span> /path/to/source /path/to/destination</span><br></pre></td></tr></table></figure><h3 id="3-6-创建和删除文件-目录"><a href="#3-6-创建和删除文件-目录" class="headerlink" title="3.6 创建和删除文件/目录"></a>3.6 创建和删除文件/目录</h3><ul><li><code>touch</code>：创建空文件。</li><li><code>mkdir</code>：创建目录。</li><li><code>rm</code>：删除文件或目录。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> filename.txt</span><br><span class="line"><span class="built_in">mkdir</span> directory</span><br><span class="line"><span class="built_in">rm</span> filename.txt</span><br></pre></td></tr></table></figure><h3 id="3-7-其他命令"><a href="#3-7-其他命令" class="headerlink" title="3.7 其他命令"></a>3.7 其他命令</h3><ul><li><code>pwd</code>：显示当前工作目录。</li><li><code>clear</code>：清除终端屏幕。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br><span class="line">clear</span><br></pre></td></tr></table></figure><h2 id="4-文件和目录常用命令"><a href="#4-文件和目录常用命令" class="headerlink" title="4. 文件和目录常用命令"></a>4. 文件和目录常用命令</h2><h3 id="4-1-ls-命令说明"><a href="#4-1-ls-命令说明" class="headerlink" title="4.1 ls 命令说明"></a>4.1 ls 命令说明</h3><p><code>ls</code>命令用于列出指定目录下的文件和子目录。</p><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /path/to/directory</span><br></pre></td></tr></table></figure><h3 id="4-2-Linux下文件和目录的特点"><a href="#4-2-Linux下文件和目录的特点" class="headerlink" title="4.2 Linux下文件和目录的特点"></a>4.2 Linux下文件和目录的特点</h3><p>在Linux系统中，所有文件和目录都具有以下特点：</p><ul><li>文件和目录都是以字符序列组成的。</li><li>所有内容都被保存在文件中。</li><li>所有文件都包含一个inode，它保存了与该文件相关的元数据。</li></ul><h3 id="4-3-ls-常用选项"><a href="#4-3-ls-常用选项" class="headerlink" title="4.3 ls 常用选项"></a>4.3 ls 常用选项</h3><ul><li><code>-l</code>：以长格式显示文件和目录的详细信息。</li><li><code>-a</code>：显示所有文件和目录，包括隐藏文件。</li><li><code>-h</code>：以人类可读的方式显示文件大小。</li><li><code>-r</code>：以相反的顺序显示文件和目录。</li><li><code>-t</code>：按修改时间排序文件和目录。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line"><span class="built_in">ls</span> -a</span><br><span class="line"><span class="built_in">ls</span> -lh</span><br></pre></td></tr></table></figure><h3 id="4-4-ls通配符的使用"><a href="#4-4-ls通配符的使用" class="headerlink" title="4.4 ls通配符的使用"></a>4.4 ls通配符的使用</h3><p>在ls命令中，可以使用通配符来匹配文件和目录的名称。</p><ul><li><code>*</code>：匹配任意字符序列。</li><li><code>?</code>：匹配单个字符。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> *.txt</span><br><span class="line"><span class="built_in">ls</span> file?.txt</span><br></pre></td></tr></table></figure><h3 id="4-5-相对路径和绝对路径"><a href="#4-5-相对路径和绝对路径" class="headerlink" title="4.5 相对路径和绝对路径"></a>4.5 相对路径和绝对路径</h3><p>在Linux系统中，可以使用相对路径和绝对路径来指定文件和目录的位置。</p><ul><li>相对路径：相对于当前工作目录的路径。</li><li>绝对路径：完整的路径，从根目录开始。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> directory</span><br><span class="line"><span class="built_in">ls</span>        <span class="comment"># 使用相对路径</span></span><br><span class="line"><span class="built_in">ls</span> /path  <span class="comment"># 使用绝对路径</span></span><br></pre></td></tr></table></figure><h2 id="5-系统信息相关命令"><a href="#5-系统信息相关命令" class="headerlink" title="5. 系统信息相关命令"></a>5. 系统信息相关命令</h2><h3 id="5-1-时间和日期"><a href="#5-1-时间和日期" class="headerlink" title="5.1 时间和日期"></a>5.1 时间和日期</h3><ul><li><code>date</code>：显示当前的日期和时间。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span></span><br></pre></td></tr></table></figure><h3 id="5-2-磁盘信息"><a href="#5-2-磁盘信息" class="headerlink" title="5.2 磁盘信息"></a>5.2 磁盘信息</h3><ul><li><code>df</code>：显示磁盘使用情况。</li><li><code>du</code>：显示指定目录或文件的磁盘使用情况。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br><span class="line"><span class="built_in">du</span> -sh directory</span><br></pre></td></tr></table></figure><h3 id="5-3-进程信息"><a href="#5-3-进程信息" class="headerlink" title="5.3 进程信息"></a>5.3 进程信息</h3><ul><li><code>ps</code>：查看运行中的进程。</li><li><code>top</code>：动态显示系统的资源占用情况和进程状态。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br><span class="line">top</span><br></pre></td></tr></table></figure><h2 id="6-用户权限相关命令"><a href="#6-用户权限相关命令" class="headerlink" title="6. 用户权限相关命令"></a>6. 用户权限相关命令</h2><h3 id="6-1-组管理"><a href="#6-1-组管理" class="headerlink" title="6.1 组管理"></a>6.1 组管理</h3><ul><li><code>groupadd</code>：创建新的用户组。</li><li><code>groupdel</code>：删除用户组。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd groupname</span><br><span class="line">groupdel groupname</span><br></pre></td></tr></table></figure><h3 id="6-2-用户管理"><a href="#6-2-用户管理" class="headerlink" title="6.2 用户管理"></a>6.2 用户管理</h3><ul><li><code>useradd</code>：创建新用户。</li><li><code>userdel</code>：删除用户。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd username</span><br><span class="line">userdel username</span><br></pre></td></tr></table></figure><h3 id="6-3-创建用户-设置密码-删除用户"><a href="#6-3-创建用户-设置密码-删除用户" class="headerlink" title="6.3 创建用户/设置密码/删除用户"></a>6.3 创建用户/设置密码/删除用户</h3><ul><li><code>adduser</code>：创建新用户。</li><li><code>passwd</code>：设置用户密码。</li><li><code>deluser</code>：删除用户。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adduser username</span><br><span class="line">passwd username</span><br><span class="line">deluser username</span><br></pre></td></tr></table></figure><h3 id="6-4-查看用户信息"><a href="#6-4-查看用户信息" class="headerlink" title="6.4 查看用户信息"></a>6.4 查看用户信息</h3><ul><li><code>id</code>：显示用户的UID和GID。</li><li><code>whoami</code>：显示当前登录用户的用户名。</li><li><code>finger</code>：显示用户信息。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span> username</span><br><span class="line"><span class="built_in">whoami</span></span><br><span class="line">finger username</span><br></pre></td></tr></table></figure><h3 id="6-5-which（重要）"><a href="#6-5-which（重要）" class="headerlink" title="6.5 which（重要）"></a>6.5 which（重要）</h3><ul><li><code>which</code>：查找给定命令的可执行文件的路径。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> <span class="built_in">command</span></span><br></pre></td></tr></table></figure><h3 id="6-6-切换用户"><a href="#6-6-切换用户" class="headerlink" title="6.6 切换用户"></a>6.6 切换用户</h3><ul><li><code>su</code>：切换到其他用户。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su username</span><br></pre></td></tr></table></figure><h3 id="6-7-修改文件权限"><a href="#6-7-修改文件权限" class="headerlink" title="6.7 修改文件权限"></a>6.7 修改文件权限</h3><ul><li><code>chmod</code>：修改文件或目录的权限。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> permissions filename</span><br></pre></td></tr></table></figure><h2 id="7-远程管理常用命令"><a href="#7-远程管理常用命令" class="headerlink" title="7. 远程管理常用命令"></a>7. 远程管理常用命令</h2><h3 id="7-1-关机-重启"><a href="#7-1-关机-重启" class="headerlink" title="7.1 关机/重启"></a>7.1 关机/重启</h3><ul><li><code>shutdown</code>：关机或重启系统。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h now   <span class="comment"># 立即关机</span></span><br><span class="line">shutdown -r now   <span class="comment"># 立即重启</span></span><br></pre></td></tr></table></figure><h3 id="7-2-查看配置网卡信息"><a href="#7-2-查看配置网卡信息" class="headerlink" title="7.2 查看配置网卡信息"></a>7.2 查看配置网卡信息</h3><ul><li><code>ifconfig</code>：显示网络接口的配置信息。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><h3 id="7-3-ping"><a href="#7-3-ping" class="headerlink" title="7.3 ping"></a>7.3 ping</h3><ul><li><code>ping</code>：测试网络连接。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping hostname</span><br></pre></td></tr></table></figure><h3 id="7-4-远程登录和赋值文件"><a href="#7-4-远程登录和赋值文件" class="headerlink" title="7.4 远程登录和赋值文件"></a>7.4 远程登录和赋值文件</h3><ul><li><code>ssh</code>：远程登录到另一台计算机。</li><li><code>scp</code>：将文件从本地复制到远程计算机或者从远程计算机复制到本地。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh username@hostname</span><br><span class="line">scp localfile username@hostname:remotefile</span><br><span class="line">scp username@hostname:remotefile localfile</span><br></pre></td></tr></table></figure><h2 id="8-结语"><a href="#8-结语" class="headerlink" title="8. 结语"></a>8. 结语</h2><p>本篇博客介绍了一些常用的Linux终端命令，这些命令可以帮助你在终端中更高效地操作文件和目录、获取系统信息以及管理用户权限等。通过熟练掌握这些命令，你可以提高工作效率，更好地利用Linux系统的强大功能。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 终端命令 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stack and Queue</title>
      <link href="/2023/09/02/Stack-and-Queue/"/>
      <url>/2023/09/02/Stack-and-Queue/</url>
      
        <content type="html"><![CDATA[<h1 id="栈和队列：数据结构与应用"><a href="#栈和队列：数据结构与应用" class="headerlink" title="栈和队列：数据结构与应用"></a>栈和队列：数据结构与应用</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>栈（Stack）和队列（Queue）是计算机科学中常用的数据结构。它们在许多应用中发挥着重要作用。本篇博客将详细介绍栈和队列的概念、特性以及C++ STL中的实现。</p><h2 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h2><p>栈是一种遵循后进先出（Last-In-First-Out，LIFO）原则的数据结构。最后插入栈的元素，第一个被移除。栈可以用数组或链表等不同的数据结构来实现。</p><h3 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h3><p>在C++中，我们可以使用数组或链表来实现栈。以下是栈的基本操作：</p><ul><li><code>push(element)</code>：将元素压入栈顶</li><li><code>pop()</code>：弹出栈顶元素</li><li><code>top()</code>：访问栈顶元素</li><li><code>empty()</code>：判断栈是否为空</li><li><code>size()</code>：获取栈的大小</li></ul><h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><p>栈在编程中有着广泛的应用。以下是一些常见的栈的应用场景：</p><ul><li>表达式求值：栈可以用于中缀表达式转后缀表达式，然后再对后缀表达式进行求值。在这个过程中，运算符可以按照优先级依次入栈和出栈，从而实现表达式的计算。</li><li>括号匹配：栈可以用于检查表达式中的括号是否匹配。当遇到左括号时，将其入栈；当遇到右括号时，检查栈顶元素是否为相应的左括号，如果是则弹出栈顶元素，否则说明括号不匹配。</li><li>函数调用时的局部变量存储：函数调用时，局部变量通常存储在栈中。每当进入一个函数，函数的局部变量会被入栈；当函数执行完毕后，局部变量会被弹出栈。</li><li>浏览器的返回功能：浏览器的返回按钮通常使用栈来记录访问页面的历史。每当用户访问一个新页面时，当前页面的URL会被入栈；当用户点击返回按钮时，栈顶的URL会被弹出栈，然后浏览器跳转到该URL对应的页面。</li></ul><h3 id="栈的实现示例"><a href="#栈的实现示例" class="headerlink" title="栈的实现示例"></a>栈的实现示例</h3><p>下面是使用<code>链表</code>实现栈的代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义栈类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Stack</span>() : <span class="built_in">top</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 压入栈顶元素</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> element)</span> </span>&#123;</span><br><span class="line">    Node* newNode = <span class="keyword">new</span> Node;</span><br><span class="line">    newNode-&gt;data = element;</span><br><span class="line">    newNode-&gt;next = top;</span><br><span class="line">    top = newNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;栈已为空，无法执行弹出操作&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* temp = top;</span><br><span class="line">    top = top-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 访问栈顶元素</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;栈为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> top-&gt;data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断栈是否为空</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> top == <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取栈的大小</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Node* current = top;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      count++;</span><br><span class="line">      current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Node* top;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试栈的使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Stack myStack;</span><br><span class="line"></span><br><span class="line">  myStack.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">  myStack.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">  myStack.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;栈顶元素：&quot;</span> &lt;&lt; myStack.<span class="built_in">peek</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  myStack.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;栈是否为空：&quot;</span> &lt;&lt; (myStack.<span class="built_in">isEmpty</span>() ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;栈的大小：&quot;</span> &lt;&lt; myStack.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是使用<code>数组</code>实现栈的代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* stack; <span class="comment">// 存储栈元素的数组</span></span><br><span class="line">    <span class="type">int</span> capacity; <span class="comment">// 栈的容量</span></span><br><span class="line">    <span class="type">int</span> top; <span class="comment">// 栈顶指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，初始化栈</span></span><br><span class="line">    <span class="built_in">ArrayStack</span>(<span class="type">int</span> size) &#123;</span><br><span class="line">        capacity = size;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="type">int</span>[capacity];</span><br><span class="line">        top = <span class="number">-1</span>; <span class="comment">// 初始时栈为空，栈顶指针为-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top == capacity - <span class="number">1</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Stack Overflow!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack[++top] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈操作</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Stack is empty!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> stack[top--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取栈顶元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Stack is empty!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> stack[top];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取栈的大小</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ArrayStack <span class="title">stack</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    stack.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    stack.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    stack.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Stack size: &quot;</span> &lt;&lt; stack.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top element: &quot;</span> &lt;&lt; stack.<span class="built_in">peek</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; stack.<span class="built_in">pop</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码使用数组实现了栈。其中，<code>ArrayStack</code>类使用数组来存储栈元素，并提供了入栈、出栈、获取栈顶元素、判断栈是否为空以及获取栈的大小等基本操作。</p><p>在<code>main()</code>函数中，我们对栈进行了一些测试操作，包括入栈、出栈、获取栈顶元素以及判断栈是否为空等。</p><h2 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h2><p>队列是一种遵循先进先出（First-In-First-Out，FIFO）原则的数据结构。最先插入队列的元素，最先被移除。队列可以用数组或链表等不同的数据结构来实现。</p><h3 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h3><p>与栈类似，队列也有一些基本操作：</p><ul><li><code>push(element)</code>：将元素插入队列尾部</li><li><code>pop()</code>：移除队列头部元素</li><li><code>front()</code>：访问队列头部元素</li><li><code>back()</code>：访问队列尾部元素</li><li><code>empty()</code>：判断队列是否为空</li><li><code>size()</code>：获取队列的大小</li></ul><h3 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h3><p>队列在编程中也有着广泛的应用。以下是一些常见的队列的应用场景：</p><ul><li>等待队列：用于处理并发请求，按照请求顺序进行处理。</li><li>进程调度：操作系统使用队列来管理进程的执行顺序。</li><li>缓存队列：用于缓存数据，如网络数据包的传输（TCP/IP协议中的滑动窗口）。</li></ul><h3 id="队列的实现示例"><a href="#队列的实现示例" class="headerlink" title="队列的实现示例"></a>队列的实现示例</h3><p>下面是使用<code>链表</code>实现队列的代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义队列类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Queue</span>() : <span class="built_in">front</span>(<span class="literal">nullptr</span>), <span class="built_in">rear</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入元素到队列尾部</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> element)</span> </span>&#123;</span><br><span class="line">    Node* newNode = <span class="keyword">new</span> Node;</span><br><span class="line">    newNode-&gt;data = element;</span><br><span class="line">    newNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rear == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      front = rear = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      rear-&gt;next = newNode;</span><br><span class="line">      rear = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除队列头部元素</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;队列已为空，无法执行移除操作&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* temp = front;</span><br><span class="line">    front = front-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (front == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      rear = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 访问队列头部元素</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;队列为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> front-&gt;data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 访问队列尾部元素</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;队列为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rear-&gt;data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断队列是否为空</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> front == <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取队列的大小</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Node* current = front;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      count++;</span><br><span class="line">      current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Node* front;</span><br><span class="line">  Node* rear;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试队列的使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Queue myQueue;</span><br><span class="line"></span><br><span class="line">  myQueue.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">  myQueue.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">  myQueue.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;队列头部元素：&quot;</span> &lt;&lt; myQueue.<span class="built_in">peek</span>() &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;队列尾部元素：&quot;</span> &lt;&lt; myQueue.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  myQueue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;队列是否为空：&quot;</span> &lt;&lt; (myQueue.<span class="built_in">isEmpty</span>() ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;队列的大小：&quot;</span> &lt;&lt; myQueue.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是使用<code>数组</code>实现队列的代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* queue; <span class="comment">// 存储队列元素的数组</span></span><br><span class="line">    <span class="type">int</span> capacity; <span class="comment">// 队列的容量</span></span><br><span class="line">    <span class="type">int</span> front; <span class="comment">// 队头指针</span></span><br><span class="line">    <span class="type">int</span> rear; <span class="comment">// 队尾指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，初始化队列</span></span><br><span class="line">    <span class="built_in">ArrayQueue</span>(<span class="type">int</span> size) &#123;</span><br><span class="line">        capacity = size;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="type">int</span>[capacity];</span><br><span class="line">        front = <span class="number">-1</span>; <span class="comment">// 初始时队列为空，队头指针为-1</span></span><br><span class="line">        rear = <span class="number">-1</span>; <span class="comment">// 初始时队列为空，队尾指针为-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isFull</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Queue is full!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">                front = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rear++;</span><br><span class="line">            queue[rear] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队操作</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Queue is empty!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> value = queue[front];</span><br><span class="line">            front++;</span><br><span class="line">            <span class="keyword">if</span> (front &gt; rear) &#123;</span><br><span class="line">                front = <span class="number">-1</span>;</span><br><span class="line">                rear = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队头元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Queue is empty!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue[front];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front == <span class="number">-1</span> &amp;&amp; rear == <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队列是否已满</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == capacity - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列的大小</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rear - front + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ArrayQueue <span class="title">queue</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    queue.<span class="built_in">enqueue</span>(<span class="number">1</span>);</span><br><span class="line">    queue.<span class="built_in">enqueue</span>(<span class="number">2</span>);</span><br><span class="line">    queue.<span class="built_in">enqueue</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Queue size: &quot;</span> &lt;&lt; queue.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Front element: &quot;</span> &lt;&lt; queue.<span class="built_in">peek</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; queue.<span class="built_in">dequeue</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码使用数组实现了栈。<code>ArrayQueue</code>类使用数组来存储队列元素，并提供了入队、出队、获取队头元素、判断队列是否为空以及获取队列的大小等基本操作。</p><p>在<code>main()</code>函数中，我们对队列进行了一些测试操作，包括入队、出队、获取队头元素以及判断队列是否为空等。</p><h2 id="STL（Standard-Template-Library）中提供的stack（堆栈）和queue（队列）"><a href="#STL（Standard-Template-Library）中提供的stack（堆栈）和queue（队列）" class="headerlink" title="STL（Standard Template Library）中提供的stack（堆栈）和queue（队列）"></a>STL（Standard Template Library）中提供的stack（堆栈）和queue（队列）</h2><h3 id="stack（堆栈）："><a href="#stack（堆栈）：" class="headerlink" title="stack（堆栈）："></a>stack（堆栈）：</h3><ul><li>堆栈是一种后进先出（Last In First Out，LIFO）的数据结构，类似于现实生活中的一叠盘子。最后放入堆栈的元素首先被取出。</li><li>STL中的stack模板类定义在<stack>头文件中，可以存储任意类型的元素。</li><li>stack提供以下常用操作：<ul><li>push(value)：将元素value压入堆栈的顶部。</li><li>pop()：删除堆栈顶部的元素。</li><li>top()：返回堆栈顶部的元素，但不删除它。</li><li>empty()：检查堆栈是否为空。</li><li>size()：返回堆栈中的元素数量。</li></ul></li></ul><p>   示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; myStack; <span class="comment">// 创建一个int类型的堆栈</span></span><br><span class="line"></span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">1</span>); <span class="comment">// 入栈操作，将元素1压入堆栈</span></span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">2</span>); <span class="comment">// 入栈操作，将元素2压入堆栈</span></span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">3</span>); <span class="comment">// 入栈操作，将元素3压入堆栈</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Stack size: &quot;</span> &lt;&lt; myStack.<span class="built_in">size</span>() &lt;&lt; std::endl; <span class="comment">// 打印堆栈的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!myStack.<span class="built_in">empty</span>()) &#123; <span class="comment">// 当堆栈不为空时</span></span><br><span class="line">        std::cout &lt;&lt; myStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 获取并打印堆栈顶部的元素</span></span><br><span class="line">        myStack.<span class="built_in">pop</span>(); <span class="comment">// 删除堆栈顶部的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="queue（队列）："><a href="#queue（队列）：" class="headerlink" title="queue（队列）："></a>queue（队列）：</h3><ul><li>队列是一种先进先出（First In First Out，FIFO）的数据结构，类似于现实生活中的排队。最先放入队列的元素首先被取出。</li><li>STL中的queue模板类定义在<queue>头文件中，可以存储任意类型的元素。</li><li>queue提供以下常用操作：<ul><li>push(value)：将元素value添加到队列的尾部。</li><li>pop()：删除队列头部的元素。</li><li>front()：返回队列头部的元素，但不删除它。</li><li>back()：返回队列尾部的元素，但不删除它。</li><li>empty()：检查队列是否为空。</li><li>size()：返回队列中的元素数量。</li></ul></li></ul><p>   示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; myQueue; <span class="comment">// 创建一个int类型的队列</span></span><br><span class="line"></span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">1</span>); <span class="comment">// 入队操作，将元素1添加到队列尾部</span></span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">2</span>); <span class="comment">// 入队操作，将元素2添加到队列尾部</span></span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">3</span>); <span class="comment">// 入队操作，将元素3添加到队列尾部</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Queue size: &quot;</span> &lt;&lt; myQueue.<span class="built_in">size</span>() &lt;&lt; std::endl; <span class="comment">// 打印队列的大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Front element: &quot;</span> &lt;&lt; myQueue.<span class="built_in">front</span>() &lt;&lt; std::endl; <span class="comment">// 打印队列头部的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Back element: &quot;</span> &lt;&lt; myQueue.<span class="built_in">back</span>() &lt;&lt; std::endl; <span class="comment">// 打印队列尾部的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!myQueue.<span class="built_in">empty</span>()) &#123; <span class="comment">// 当队列不为空时</span></span><br><span class="line">        std::cout &lt;&lt; myQueue.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 获取并打印队列头部的元素</span></span><br><span class="line">        myQueue.<span class="built_in">pop</span>(); <span class="comment">// 删除队列头部的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="stack和queue的示例"><a href="#stack和queue的示例" class="headerlink" title="stack和queue的示例"></a>stack和queue的示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// stack的使用示例</span></span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈操作</span></span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">6</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈操作</span></span><br><span class="line">    <span class="type">int</span> topElement = s.<span class="built_in">top</span>();  <span class="comment">// 获取栈顶元素</span></span><br><span class="line">    s.<span class="built_in">pop</span>();  <span class="comment">// 弹出栈顶元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出栈顶元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top element of the stack: &quot;</span> &lt;&lt; topElement &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stack is empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stack is not empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// queue的使用示例</span></span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队操作</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队操作</span></span><br><span class="line">    <span class="type">int</span> frontElement = q.<span class="built_in">front</span>();  <span class="comment">// 获取队头元素</span></span><br><span class="line">    q.<span class="built_in">pop</span>();  <span class="comment">// 弹出队头元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出队头元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Front element of the queue: &quot;</span> &lt;&lt; frontElement &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队列是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Queue is empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Queue is not empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用示例："><a href="#应用示例：" class="headerlink" title="应用示例："></a>应用示例：</h3><ul><li>stack的应用：在实现逆波兰表达式求值、括号匹配和深度优先搜索（DFS）等算法中，通常会使用堆栈来辅助实现。</li><li>queue的应用：在实现广度优先搜索（BFS）和缓冲区管理等场景中，常常使用队列来解决问题。例如，在排队系统中，可以使用队列来处理顾客的请求。</li></ul><h4 id="使用栈实现括号匹配"><a href="#使用栈实现括号匹配" class="headerlink" title="使用栈实现括号匹配"></a>使用栈实现括号匹配</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isMatching</span><span class="params">(<span class="type">char</span> opening, <span class="type">char</span> closing)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (opening == <span class="string">&#x27;(&#x27;</span> &amp;&amp; closing == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (opening == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; closing == <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (opening == <span class="string">&#x27;[&#x27;</span> &amp;&amp; closing == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(std::string expression)</span> </span>&#123;</span><br><span class="line">  std::stack&lt;<span class="type">char</span>&gt; myStack;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">char</span> ch : expression) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span> || ch == <span class="string">&#x27;&#123;&#x27;</span> || ch == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">      myStack.<span class="built_in">push</span>(ch);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;)&#x27;</span> || ch == <span class="string">&#x27;&#125;&#x27;</span> || ch == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (myStack.<span class="built_in">empty</span>() || !<span class="built_in">isMatching</span>(myStack.<span class="built_in">top</span>(), ch)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        myStack.<span class="built_in">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> myStack.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string expression1 = <span class="string">&quot;&#123;([])&#125;&quot;</span>;</span><br><span class="line">  std::string expression2 = <span class="string">&quot;&#123;([)]&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isBalanced</span>(expression1)) &#123;</span><br><span class="line">    std::cout &lt;&lt; expression1 &lt;&lt; <span class="string">&quot; is balanced.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; expression1 &lt;&lt; <span class="string">&quot; is not balanced.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isBalanced</span>(expression2)) &#123;</span><br><span class="line">    std::cout &lt;&lt; expression2 &lt;&lt; <span class="string">&quot; is balanced.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; expression2 &lt;&lt; <span class="string">&quot; is not balanced.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码演示了如何使用栈来检查表达式中的括号是否匹配。首先，我们定义了一个辅助函数<code>isMatching()</code>，用于判断括号对是否匹配。然后，定义了一个<code>isBalanced()</code>函数，用于检查表达式是否括号平衡。</p><p>在<code>isBalanced()</code>函数中，我们使用一个栈<code>myStack</code>来存储遇到的左括号。遍历表达式中的每个字符，如果是左括号（’(‘、’{‘或’[‘），则将其入栈；如果是右括号，则判断栈顶的左括号和当前右括号是否匹配，如果匹配则将栈顶元素弹出，否则表达式不平衡。最后，如果遍历完整个表达式后，栈为空，则表达式平衡，否则不平衡。</p><p>在<code>main()</code>函数中，我们测试了两个表达式<code>&quot;&#123;([])&#125;&quot;</code>和<code>&quot;&#123;([)]&#125;&quot;</code>。输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;([])&#125; is balanced.</span><br><span class="line">&#123;([)]&#125; is not balanced.</span><br></pre></td></tr></table></figure><p>这段代码展示了如何使用栈来检查括号匹配，可以作为栈应用的一个实际场景示例。</p><h4 id="使用std-queue实现等待队列"><a href="#使用std-queue实现等待队列" class="headerlink" title="使用std::queue实现等待队列"></a>使用<code>std::queue</code>实现等待队列</h4><p>等待队列是一种常见的使用队列的场景，特别是在并发编程中。当多个任务或请求同时到达时，可以使用队列来按照请求顺序进行处理。以下是一个简单的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; requestQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求到达，加入等待队列</span></span><br><span class="line">    requestQueue.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    requestQueue.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    requestQueue.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理请求</span></span><br><span class="line">    <span class="keyword">while</span> (!requestQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> request = requestQueue.<span class="built_in">front</span>();  <span class="comment">// 获取队头请求</span></span><br><span class="line">        requestQueue.<span class="built_in">pop</span>();  <span class="comment">// 弹出队头请求</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理请求的逻辑</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Processing request: &quot;</span> &lt;&lt; request &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们使用了<code>std::queue</code>实现了一个等待队列。请求到达时，将其加入到队列的末尾，然后按照先进先出的原则处理请求。通过循环遍历队列，每次处理队头的请求，直到队列为空。</p><h4 id="使用std-queue实现就绪队列"><a href="#使用std-queue实现就绪队列" class="headerlink" title="使用std::queue实现就绪队列"></a>使用<code>std::queue</code>实现就绪队列</h4><p>操作系统中使用队列来管理进程的执行顺序，即进程调度。具体而言，在多道批处理系统中，操作系统维护一个就绪队列（ready queue），将可运行的进程按照某种调度算法添加到队列中，并依次调度执行。以下是一个简单的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Process</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    std::string name;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Process</span>(<span class="type">int</span> _id, std::string _name)</span><br><span class="line">        : <span class="built_in">id</span>(_id), <span class="built_in">name</span>(_name) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::queue&lt;Process&gt; readyQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建进程并加入就绪队列</span></span><br><span class="line">    <span class="function">Process <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;Process 1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Process <span class="title">p2</span><span class="params">(<span class="number">2</span>, <span class="string">&quot;Process 2&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Process <span class="title">p3</span><span class="params">(<span class="number">3</span>, <span class="string">&quot;Process 3&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    readyQueue.<span class="built_in">push</span>(p1);</span><br><span class="line">    readyQueue.<span class="built_in">push</span>(p2);</span><br><span class="line">    readyQueue.<span class="built_in">push</span>(p3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度执行进程</span></span><br><span class="line">    <span class="keyword">while</span> (!readyQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Process currentProcess = readyQueue.<span class="built_in">front</span>();  <span class="comment">// 获取队头进程</span></span><br><span class="line">        readyQueue.<span class="built_in">pop</span>();  <span class="comment">// 弹出队头进程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行进程的逻辑</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Executing process: &quot;</span> &lt;&lt; currentProcess.name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们使用了<code>std::queue</code>实现了一个就绪队列，存储待执行的进程。创建进程时，将其加入到队列的末尾。通过循环遍历队列，每次执行队头的进程，直到队列为空。</p><h4 id="使用std-queue实现缓存队列"><a href="#使用std-queue实现缓存队列" class="headerlink" title="使用std::queue实现缓存队列"></a>使用<code>std::queue</code>实现缓存队列</h4><p>队列还常用于实现缓存，例如网络数据包传输中的滑动窗口（TCP/IP协议）。滑动窗口是一种流量控制机制，使用队列来缓存数据包，以平衡发送端和接收端的速度差异。以下是一个简单的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; packetQueue;</span><br><span class="line">    <span class="type">int</span> windowSize = <span class="number">5</span>;  <span class="comment">// 窗口大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据包到达，加入缓存队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        packetQueue.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查缓存队列是否超过窗口大小</span></span><br><span class="line">        <span class="keyword">if</span> (packetQueue.<span class="built_in">size</span>() &gt; windowSize) &#123;</span><br><span class="line">            <span class="type">int</span> packet = packetQueue.<span class="built_in">front</span>();  <span class="comment">// 获取队头数据包</span></span><br><span class="line">            packetQueue.<span class="built_in">pop</span>();  <span class="comment">// 弹出队头数据包</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理数据包的逻辑</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Processing packet: &quot;</span> &lt;&lt; packet &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们使用了<code>std::queue</code>实现了一个缓存队列，用于存储网络数据包。数据包到达时，将其加入到队列的末尾，并检查队列的长度是否超过滑动窗口的大小。若超过，则取出队头的数据包进行处理，再继续接收新的数据包。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细介绍了栈和队列的概念、基本操作、使用数组、链表分别实现了栈和队列以及使用C++ STL中的<code>std::stack</code>和<code>std::queue</code>实现栈和队列的一些应用场景等。栈和队列是常见的数据结构，具有广泛的应用范围。通过理解栈和队列的特性和使用方法，可以更好地解决实际问题。</p><p>本篇博客内容较长，你能阅读至此，很有毅力！期待下篇博客，有你一阅~</p>]]></content>
      
      
      <categories>
          
          <category> Data Structure Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Explore Map Containers and Multimap Containers in STL</title>
      <link href="/2023/09/02/Explore-Map-Containers-and-Multimap-Containers-in-STL/"/>
      <url>/2023/09/02/Explore-Map-Containers-and-Multimap-Containers-in-STL/</url>
      
        <content type="html"><![CDATA[<h1 id="探索STL中的Map容器和Multimap容器：用于高效管理键值对的强大工具"><a href="#探索STL中的Map容器和Multimap容器：用于高效管理键值对的强大工具" class="headerlink" title="探索STL中的Map容器和Multimap容器：用于高效管理键值对的强大工具"></a>探索STL中的Map容器和Multimap容器：用于高效管理键值对的强大工具</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li><li><a href="#Map%E5%AE%B9%E5%99%A8">Map容器</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">基本介绍</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96Map%E5%AE%B9%E5%99%A8">创建和初始化Map容器</a></li><li><a href="#%E6%8F%92%E5%85%A5%E5%92%8C%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0">插入和访问元素</a></li><li><a href="#%E9%81%8D%E5%8E%86Map%E5%AE%B9%E5%99%A8">遍历Map容器</a></li><li><a href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C">其他常用操作</a></li></ul></li><li><a href="#Multimap%E5%AE%B9%E5%99%A8">Multimap容器</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">基本介绍</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96Multimap%E5%AE%B9%E5%99%A8">创建和初始化Multimap容器</a></li><li><a href="#%E6%8F%92%E5%85%A5%E5%92%8C%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0">插入和访问元素</a></li><li><a href="#%E9%81%8D%E5%8E%86Multimap%E5%AE%B9%E5%99%A8">遍历Multimap容器</a></li><li><a href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C">其他常用操作</a></li></ul></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>今天我将向大家分享关于STL中Map容器和Multimap容器的知识。Map容器和Multimap容器是C++标准模板库(STL)提供的两种关联容器，它们以键值对的形式存储数据，并提供高效的键值查找和插入操作。</p><p>本篇博客将详细介绍Map容器和Multimap容器的特性、用法和常用操作，并通过代码实践演示如何使用它们解决实际问题。让我们一起来探索这两种强大的工具吧！</p><h2 id="Map容器"><a href="#Map容器" class="headerlink" title="Map容器"></a>Map容器</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>Map容器是一种有序的关联容器，其中的每个元素都是一个键值对(pair)，其中键（key）和值（value）之间有一对一的映射关系。Map容器的特点包括：</p><ul><li>键唯一性：Map容器中的键是唯一的，不允许重复。</li><li>自动排序：Map容器根据键的大小自动进行排序，默认采用严格弱序（strict weak ordering）。</li><li>高效的查找和插入：Map容器基于红黑树实现，具有快速的查找和插入性能。</li></ul><h3 id="创建和初始化Map容器"><a href="#创建和初始化Map容器" class="headerlink" title="创建和初始化Map容器"></a>创建和初始化Map容器</h3><p>在使用Map容器之前，我们需要包含头文件<code>&lt;map&gt;</code>。接下来，我们可以通过以下方法创建和初始化Map容器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建空的Map容器</span></span><br><span class="line">std::map&lt;KeyType, ValueType&gt; myMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并初始化Map容器</span></span><br><span class="line">std::map&lt;KeyType, ValueType&gt; myMap = &#123;</span><br><span class="line">    &#123;key1, value1&#125;,</span><br><span class="line">    &#123;key2, value2&#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在创建和初始化Map容器时，我们需要指定键的类型(KeyType)和值的类型(ValueType)。通过大括号内的键值对列表，可以方便地初始化Map容器。</p><p>接下来，我们通过一个简单的例子演示如何创建和初始化Map容器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; myMap = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;apple&quot;</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;banana&quot;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;pear&quot;</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;orange&quot;</span>, <span class="number">5</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 输出Map中的所有元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = myMap.<span class="built_in">begin</span>(); it != myMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，我们创建了一个字符串到整数的Map容器<code>myMap</code>，并用大括号内的键值对列表初始化了它。接着，通过迭代器遍历<code>myMap</code>，输出了Map中所有元素的键和值。</p><h3 id="插入和访问元素"><a href="#插入和访问元素" class="headerlink" title="插入和访问元素"></a>插入和访问元素</h3><p>向Map容器中插入元素可以使用<code>insert()</code>函数或使用下标操作符<code>[]</code>。我们可以按照以下的方式进行操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入键值对</span></span><br><span class="line">myMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(key, value));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用下标操作符插入或修改元素</span></span><br><span class="line">myMap[key] = value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问元素</span></span><br><span class="line">ValueType val = myMap[key];</span><br></pre></td></tr></table></figure><p>需要注意的是，如果插入的键已经存在于Map容器中，<code>insert()</code>函数将不会改变Map容器，而使用下标操作符<code>[]</code>则会覆盖原有的值。</p><p>以下是一个示例代码，演示如何插入和访问Map容器中的元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; myMap;</span><br><span class="line">    <span class="comment">// 向Map中插入元素</span></span><br><span class="line">    myMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>));</span><br><span class="line">    myMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;banana&quot;</span>));</span><br><span class="line">    myMap[<span class="number">3</span>] = <span class="string">&quot;pear&quot;</span>;</span><br><span class="line">    myMap[<span class="number">4</span>] = <span class="string">&quot;orange&quot;</span>;</span><br><span class="line">    <span class="comment">// 访问Map中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The value associated with key 1 is &quot;</span> &lt;&lt; myMap[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt;::iterator it;</span><br><span class="line">    it = myMap.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The value associated with key 2 is &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，我们创建了一个整数到字符串的Map容器<code>myMap</code>，并向其中插入了四个元素。接着，通过下标操作符和<code>find()</code>函数访问了<code>myMap</code>中两个元素。需要注意的是，在使用<code>find()</code>函数查找一个键时，需要判断返回的迭代器是否等于<code>end()</code>，以避免访问不存在的元素。</p><h3 id="遍历Map容器"><a href="#遍历Map容器" class="headerlink" title="遍历Map容器"></a>遍历Map容器</h3><p>遍历Map容器可以使用迭代器实现，以下是一种常用的遍历方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = myMap.<span class="built_in">begin</span>(); it != myMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="comment">// 访问键值对</span></span><br><span class="line">    KeyType key = it-&gt;first;</span><br><span class="line">    ValueType value = it-&gt;second;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器<code>it</code>从Map容器的开始位置(<code>begin()</code>)移动到结束位置(<code>end()</code>)，通过<code>it-&gt;first</code>和<code>it-&gt;second</code>访问键和值。我们可以在循环中根据需要使用键值对进行操作。</p><p>下面是一个演示代码，展示如何使用迭代器遍历Map容器并输出所有键值对：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; myMap = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;apple&quot;</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;banana&quot;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;pear&quot;</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;orange&quot;</span>, <span class="number">5</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 遍历Map中的所有元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = myMap.<span class="built_in">begin</span>(); it != myMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，我们创建了一个字符串到整数的Map容器<code>myMap</code>，并用大括号内的键值对列表初始化了它。接着，通过迭代器遍历<code>myMap</code>，输出了Map中所有元素的键和值。</p><h3 id="其他常用操作"><a href="#其他常用操作" class="headerlink" title="其他常用操作"></a>其他常用操作</h3><p>Map容器还提供了许多其他常用的操作，包括：</p><ul><li><code>size()</code>：返回Map容器中键值对的数量。</li><li><code>find(key)</code>：返回指向具有给定键的元素的迭代器。如果键不存在，则返回<code>end()</code>。</li><li><code>erase(key)</code>：删除具有给定键的元素。</li><li><code>clear()</code>：清空Map容器，删除所有的元素。</li></ul><p>通过合理利用这些操作，我们可以更好地管理和操作Map容器中的键值对数据。</p><p>下面是一个演示代码，展示如何使用<code>size()</code>、<code>find()</code>、<code>erase()</code>和<code>clear()</code>等函数进行Map容器的管理和操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; myMap = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;apple&quot;</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;banana&quot;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;pear&quot;</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;orange&quot;</span>, <span class="number">5</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 输出Map大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The size of myMap is &quot;</span> &lt;&lt; myMap.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 删除指定键的元素</span></span><br><span class="line">    myMap.<span class="built_in">erase</span>(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">    <span class="comment">// 输出Map中指定键的值</span></span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt;::iterator it;</span><br><span class="line">    it = myMap.<span class="built_in">find</span>(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The value associated with key \&quot;pear\&quot; is &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空Map</span></span><br><span class="line">    myMap.<span class="built_in">clear</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The size of myMap after clear is &quot;</span> &lt;&lt; myMap.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，我们创建了一个字符串到整数的Map容器<code>myMap</code>，并用大括号内的键值对列表初始化了它。接着，使用<code>size()</code>函数输出了<code>myMap</code>的大小；使用<code>erase()</code>函数删除了键为”banana”的元素；使用<code>find()</code>函数查找了键为”pear”的元素，并输出了相应的值；最后，通过使用<code>clear()</code>函数清空了<code>myMap</code>。</p><h2 id="Multimap容器"><a href="#Multimap容器" class="headerlink" title="Multimap容器"></a>Multimap容器</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>Multimap容器是一种有序的关联容器，允许键重复，其中的每个元素也是一个键值对(pair)。Multimap容器的特点包括：</p><ul><li>键可以重复：Multimap容器中的键允许重复，可以插入多个相同键的元素。</li><li>自动排序：Multimap容器根据键的大小自动进行排序，默认采用严格弱序（strict weak ordering）。</li><li>高效的查找和插入：Multimap容器基于红黑树实现，具有快速的查找和插入性能。</li></ul><h3 id="创建和初始化Multimap容器"><a href="#创建和初始化Multimap容器" class="headerlink" title="创建和初始化Multimap容器"></a>创建和初始化Multimap容器</h3><p>创建和初始化Multimap容器与Map容器类似，我们同样需要包含头文件<code>&lt;map&gt;</code>，并可以通过以下方式创建和初始化Multimap容器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建空的Multimap容器</span></span><br><span class="line">std::multimap&lt;KeyType, ValueType&gt; myMultimap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并初始化Multimap容器</span></span><br><span class="line">std::multimap&lt;KeyType, ValueType&gt; myMultimap = &#123;</span><br><span class="line">    &#123;key1, value1&#125;,</span><br><span class="line">    &#123;key2, value2&#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在创建和初始化Multimap容器时，同样需要指定键的类型(KeyType)和值的类型(ValueType)。通过大括号内的键值对列表，可以方便地初始化Multimap容器。</p><h3 id="插入和访问元素-1"><a href="#插入和访问元素-1" class="headerlink" title="插入和访问元素"></a>插入和访问元素</h3><p>向Multimap容器中插入元素可以使用<code>insert()</code>函数，我们可以按照以下的方式进行操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入键值对</span></span><br><span class="line">myMultimap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(key, value));</span><br></pre></td></tr></table></figure><p>与Map容器不同，Multimap容器允许插入多个具有相同键的元素。</p><p>访问Multimap容器中的元素需要使用迭代器进行遍历，以下是一种常用的遍历方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = myMultimap.<span class="built_in">begin</span>(); it != myMultimap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="comment">// 访问键值对</span></span><br><span class="line">    KeyType key = it-&gt;first;</span><br><span class="line">    ValueType value = it-&gt;second;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过迭代器<code>it</code>从Multimap容器的开始位置(<code>begin()</code>)移动到结束位置(<code>end()</code>)，通过<code>it-&gt;first</code>和<code>it-&gt;second</code>访问键和值。我们可以在循环中根据需要使用键值对进行操作。</p><h3 id="遍历Multimap容器"><a href="#遍历Multimap容器" class="headerlink" title="遍历Multimap容器"></a>遍历Multimap容器</h3><p>遍历Multimap容器与遍历Map容器类似，可以使用迭代器实现，以下是一种常用的遍历方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = myMultimap.<span class="built_in">begin</span>(); it != myMultimap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="comment">// 访问键值对</span></span><br><span class="line">    KeyType key = it-&gt;first;</span><br><span class="line">    ValueType value = it-&gt;second;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过迭代器<code>it</code>从Multimap容器的开始位置(<code>begin()</code>)移动到结束位置(<code>end()</code>)，通过<code>it-&gt;first</code>和<code>it-&gt;second</code>访问键和值。我们可以在循环中根据需要使用键值对进行操作。</p><h3 id="其他常用操作-1"><a href="#其他常用操作-1" class="headerlink" title="其他常用操作"></a>其他常用操作</h3><p>Multimap容器也提供了许多其他常用的操作，包括：</p><ul><li><code>size()</code>：返回Multimap容器中键值对的数量。</li><li><code>count(key)</code>：返回具有给定键的元素的数量。</li><li><code>find(key)</code>：返回指向具有给定键的第一个元素的迭代器。如果键不存在，则返回<code>end()</code>。</li><li><code>equal_range(key)</code>：返回一个迭代器对，表示Multimap容器中具有给定键的元素的范围。</li><li><code>erase(key)</code>：删除具有给定键的所有元素。</li><li><code>clear()</code>：清空Multimap容器，删除所有的元素。</li></ul><p>通过合理利用这些操作，我们可以更好地管理和操作Multimap容器中的键值对数据。<br>当使用C++中的<code>multimap</code>容器时，可以使用以下代码演示这些常用操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::multimap&lt;<span class="type">int</span>, std::string&gt; multimap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    multimap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>));</span><br><span class="line">    multimap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;banana&quot;</span>));</span><br><span class="line">    multimap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;orange&quot;</span>));</span><br><span class="line">    multimap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="string">&quot;grape&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size() - 获取键值对的数量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size: &quot;</span> &lt;&lt; multimap.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// count(key) - 获取具有给定键的元素数量</span></span><br><span class="line">    <span class="type">int</span> key = <span class="number">2</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Count of &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; multimap.<span class="built_in">count</span>(key) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find(key) - 查找具有给定键的第一个元素的迭代器</span></span><br><span class="line">    <span class="keyword">auto</span> it = multimap.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">if</span> (it != multimap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element with key &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// equal_range(key) - 获取具有给定键的元素范围</span></span><br><span class="line">    <span class="keyword">auto</span> range = multimap.<span class="built_in">equal_range</span>(key);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elements with key &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = range.first; i != range.second; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; i-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// erase(key) - 删除具有给定键的所有元素</span></span><br><span class="line">    multimap.<span class="built_in">erase</span>(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear() - 清空Multimap容器</span></span><br><span class="line">    multimap.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (multimap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Multimap is empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码演示了<code>multimap</code>容器的常用操作，包括<code>size()</code>、<code>count(key)</code>、<code>find(key)</code>、<code>equal_range(key)</code>、<code>erase(key)</code>和<code>clear()</code>。你可以根据需要修改键和值的类型，并根据具体情况进行插入和查找。<br>以下是该代码的输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Size: 4</span><br><span class="line">Count of 2: 2</span><br><span class="line">Element with key 2: banana</span><br><span class="line">Elements with key 2:</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">Multimap is empty</span><br></pre></td></tr></table></figure><p>代码中插入了4个键值对，然后进行了一系列操作。首先，<code>size()</code>函数返回了容器中键值对的数量，即4。接下来，使用<code>count(key)</code>函数获取具有键2的元素数量，结果为2。然后，使用<code>find(key)</code>函数查找具有键2的第一个元素，并输出其对应的值为”banana”。接着，使用<code>equal_range(key)</code>函数获取具有键2的元素范围，并循环输出范围内的所有值，即”banana”和”orange”。然后，使用<code>erase(key)</code>函数删除具有键2的所有元素。最后，使用<code>clear()</code>函数清空了整个<code>multimap</code>容器，并通过<code>empty()</code>函数验证容器是否为空，输出”Multimap is empty”。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本篇博客中，我们探索了STL中Map容器和Multimap容器的基本特性、创建和初始化方式以及常用的操作方法。Map容器以及Multimap容器作为一种强大的工具，在处理键值对数据时提供了高效的查找和插入功能。</p><p>通过深入理解Map容器和Multimap容器的特性和用法，我们可以更好地利用它们来解决实际问题。</p><p>希望本篇博客对读者了解和使用STL中的Map容器和Multimap容器有所帮助。期待下篇博客，依旧能与你相见~</p>]]></content>
      
      
      <categories>
          
          <category> Data Structure Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Detailed explanation of set container</title>
      <link href="/2023/09/01/Detailed-explanation-of-set-container/"/>
      <url>/2023/09/01/Detailed-explanation-of-set-container/</url>
      
        <content type="html"><![CDATA[<p>当你需要使用一个数据结构来存储一组唯一元素，并且对元素具有高效的插入、删除和查找操作时，C++标准库中的<code>std::set</code>容器就是一个理想的选择。<code>std::set</code>容器以平衡二叉搜索树（通常是红黑树）的形式实现，因此能够保持元素的有序性。</p><p>Set（集合）是C++ STL中的一个容器，它提供了存储一组唯一值的功能。在set中，每个元素都是唯一的，并按照一定的顺序进行排序。特点如下：</p><ul><li>set中的元素是唯一的，不存在重复值。</li><li>set中的元素会按照一定的顺序进行排序，默认是升序。</li><li>set中不支持修改元素的操作，只能插入和删除元素。</li><li>set内部使用红黑树（red-black tree）数据结构来实现，因此插入、删除、查找等操作的时间复杂度为O(logN)。</li></ul><p>需要注意的是，如果希望自定义元素的排序规则，可以使用自定义比较函数或自定义类型来实现。此外，还可以使用multiset容器来存储允许重复值的集合。</p><p>本篇博客将详细介绍<code>std::set</code>容器的用法，包括定义、插入元素、删除元素、判断容器是否为空、获取容器大小、查找元素以及遍历容器等操作。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#%E5%A3%B0%E6%98%8Eset%E5%AE%B9%E5%99%A8">声明set容器</a></li><li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96set%E5%AE%B9%E5%99%A8">初始化set容器</a></li><li><a href="#%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0">插入元素</a></li><li><a href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0">删除元素</a></li><li><a href="#%E5%88%A4%E6%96%AD%E5%AE%B9%E5%99%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA">判断容器是否为空</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E5%AE%B9%E5%99%A8%E5%A4%A7%E5%B0%8F">获取容器大小</a></li><li><a href="#%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0">查找元素</a></li><li><a href="#%E9%81%8D%E5%8E%86set%E5%AE%B9%E5%99%A8">遍历set容器</a></li><li><a href="#%E8%AF%A6%E7%BB%86%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E5%92%8C%E8%AE%B2%E8%A7%A3">详细代码示例和讲解</a></li><li><a href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C">其他常用操作</a></li><li><a href="#set%E5%AE%B9%E5%99%A8%E9%97%B4%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C">set容器间集合操作</a></li></ol><h3 id="声明set容器"><a href="#声明set容器" class="headerlink" title="声明set容器"></a>声明set容器</h3><p>在使用set容器之前，需要包含头文件<code>&lt;set&gt;</code>。然后可以使用如下方式声明一个set容器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;类型&gt; 容器名称;</span><br></pre></td></tr></table></figure><p>其中，<code>类型</code>是指set容器中元素的类型，<code>容器名称</code>是给set容器指定的名字。例如，我们可以声明一个存储整数的set容器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line">std::set&lt;<span class="type">int</span>&gt; mySet;</span><br></pre></td></tr></table></figure><h3 id="初始化set容器"><a href="#初始化set容器" class="headerlink" title="初始化set容器"></a>初始化set容器</h3><p>set容器可以通过多种方式进行初始化，常用的包括：</p><ul><li><p>默认初始化：创建一个空的set容器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;<span class="type">int</span>&gt; mySet;  <span class="comment">// 创建一个空的整数set容器</span></span><br></pre></td></tr></table></figure></li><li><p>使用初始化列表初始化：在声明set容器时使用花括号{}，将初始元素放入列表中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;<span class="type">int</span>&gt; mySet = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  <span class="comment">// 初始化一个包含元素1、2、3的整数set容器</span></span><br></pre></td></tr></table></figure></li><li><p>使用迭代器初始化：使用另一个Set容器（或者是其他容器）的起始和结束迭代器，来初始化新的set容器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;<span class="type">int</span>&gt; anotherSet = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="function">std::set&lt;<span class="type">int</span>&gt; <span class="title">mySet</span><span class="params">(anotherSet.begin(), anotherSet.end())</span></span>;  <span class="comment">// 使用迭代器初始化新的set容器</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>向<code>std::set</code>容器插入元素可以使用<code>insert</code>函数。插入操作会自动保持容器中的元素有序。</p><p>下面是一个插入元素的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mySet.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">mySet.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">mySet.<span class="built_in">insert</span>(<span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>上述代码将分别向<code>mySet</code>容器插入了3个整数：5、2和8。</p><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>从<code>std::set</code>容器中删除元素可以使用<code>erase</code>函数。你可以指定要删除的元素值，也可以通过迭代器删除指定位置的元素。</p><p>下面是一个删除元素的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mySet.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>上述代码将从<code>mySet</code>容器中删除值为2的元素。</p><h3 id="判断容器是否为空"><a href="#判断容器是否为空" class="headerlink" title="判断容器是否为空"></a>判断容器是否为空</h3><p>可以使用<code>empty</code>函数来判断<code>std::set</code>容器是否为空。</p><p>下面是一个判断容器是否为空的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mySet.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// 容器为空</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 容器不为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取容器大小"><a href="#获取容器大小" class="headerlink" title="获取容器大小"></a>获取容器大小</h3><p>使用<code>size</code>函数可以获取<code>std::set</code>容器中的元素数量。</p><p>下面是一个获取容器大小的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size = mySet.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure><p>上述代码将获取<code>mySet</code>容器中的元素数量，并将其赋值给变量<code>size</code>。</p><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>使用<code>find</code>函数可以在<code>std::set</code>容器中查找指定的元素。如果找到了匹配的元素，则返回指向该元素的迭代器；如果未找到，则返回容器的<code>end</code>迭代器。</p><p>下面是一个查找元素的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = mySet.<span class="built_in">find</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// 找到了元素</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 未找到元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码将在<code>mySet</code>容器中查找值为5的元素。如果找到了元素，<code>it</code>将指向该元素，否则<code>it</code>将等于容器的<code>end</code>迭代器。</p><h3 id="遍历set容器"><a href="#遍历set容器" class="headerlink" title="遍历set容器"></a>遍历set容器</h3><p>可以使用range-based for循环来遍历<code>std::set</code>容器中的元素。</p><p>下面是一个遍历容器的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : mySet) &#123;</span><br><span class="line">    <span class="comment">// 使用element进行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码将遍历<code>mySet</code>容器中的所有元素，并通过变量<code>element</code>访问每个元素。</p><h3 id="详细代码示例和讲解"><a href="#详细代码示例和讲解" class="headerlink" title="详细代码示例和讲解"></a>详细代码示例和讲解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义set容器</span></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    mySet.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断容器是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (mySet.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Set容器为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Set容器不为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取容器大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Set容器大小为：&quot;</span> &lt;&lt; mySet.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="type">int</span> searchElement = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">auto</span> it = mySet.<span class="built_in">find</span>(searchElement);</span><br><span class="line">    <span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素 &quot;</span> &lt;&lt; searchElement &lt;&lt; <span class="string">&quot; 存在于Set容器中&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素 &quot;</span> &lt;&lt; searchElement &lt;&lt; <span class="string">&quot; 不存在于Set容器中&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历set容器</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Set容器的元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : mySet) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set容器不为空</span><br><span class="line">Set容器大小为：2</span><br><span class="line">元素 5 存在于Set容器中</span><br><span class="line">Set容器的元素：5 8</span><br></pre></td></tr></table></figure><p>在上述代码示例中，我首先使用<code>std::set&lt;int&gt;</code>来定义一个名为<code>mySet</code>的set容器。然后，使用<code>insert</code>函数向set容器中插入元素。接下来，使用<code>erase</code>函数从容器中删除指定元素。使用<code>empty</code>函数判断set容器是否为空，并输出相应信息。使用<code>size</code>函数获取容器的大小，并打印输出。使用<code>find</code>函数查找指定元素，若找到则输出相应信息。最后，使用range-based for循环遍历set容器的元素，并打印输出。</p><h3 id="其他常用操作"><a href="#其他常用操作" class="headerlink" title="其他常用操作"></a>其他常用操作</h3><p>1.当使用<code>count(x)</code>函数时，它会返回Set容器中值为x的元素个数。如果该值存在，则返回1；如果不存在，则返回0。下面是一个使用<code>count(x)</code>函数的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = mySet.<span class="built_in">count</span>(<span class="number">30</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;值为30的元素个数为：&quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    count = mySet.<span class="built_in">count</span>(<span class="number">60</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;值为60的元素个数为：&quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">值为30的元素个数为：1</span><br><span class="line">值为60的元素个数为：0</span><br></pre></td></tr></table></figure><p>2.当使用<code>lower_bound(x)</code>函数时，它会返回一个指向大于或等于x的最小元素的迭代器。如果找不到这样的元素，则返回Set容器的end()迭代器。下面是一个使用<code>lower_bound(x)</code>函数的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = mySet.<span class="built_in">lower_bound</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;大于或等于30的最小元素为：&quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;没有找到大于或等于30的元素&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    it = mySet.<span class="built_in">lower_bound</span>(<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;大于或等于60的最小元素为：&quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;没有找到大于或等于60的元素&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">大于或等于30的最小元素为：30</span><br><span class="line">没有找到大于或等于60的元素</span><br></pre></td></tr></table></figure><p>3.当使用<code>upper_bound(x)</code>函数时，它会返回一个指向大于x的最小元素的迭代器。如果找不到这样的元素，则返回Set容器的end()迭代器。下面是一个使用<code>upper_bound(x)</code>函数的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = mySet.<span class="built_in">upper_bound</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;大于30的最小元素为：&quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;没有找到大于30的元素&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    it = mySet.<span class="built_in">upper_bound</span>(<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;大于60的最小元素为：&quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;没有找到大于60的元素&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">大于30的最小元素为：40</span><br><span class="line">没有找到大于60的元素</span><br></pre></td></tr></table></figure><p>4.当使用<code>equal_range(x)</code>函数时，它会返回一个pair对象，包含<code>lower_bound()</code>和<code>upper_bound()</code>的迭代器范围。<code>equal_range(x)</code>函数返回的pair对象中，first成员是<code>lower_bound(x)</code>函数返回的迭代器，second成员是<code>upper_bound(x)</code>函数返回的迭代器。下面是一个使用<code>equal_range(x)</code>函数的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> range = mySet.<span class="built_in">equal_range</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">if</span> (range.first != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;大于或等于30的最小元素为：&quot;</span> &lt;&lt; *(range.first) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;没有找到大于或等于30的元素&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (range.second != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;大于30的最小元素为：&quot;</span> &lt;&lt; *(range.second) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;没有找到大于30的元素&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    range = mySet.<span class="built_in">equal_range</span>(<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">if</span> (range.first != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;大于或等于60的最小元素为：&quot;</span> &lt;&lt; *(range.first) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;没有找到大于或等于60的元素&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (range.second != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;大于60的最小元素为：&quot;</span> &lt;&lt; *(range.second) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;没有找到大于60的元素&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">大于或等于30的最小元素为：30</span><br><span class="line">大于30的最小元素为：40</span><br><span class="line">没有找到大于或等于60的元素</span><br><span class="line">没有找到大于60的元素</span><br></pre></td></tr></table></figure><h3 id="set容器间集合操作"><a href="#set容器间集合操作" class="headerlink" title="set容器间集合操作"></a>set容器间集合操作</h3><p>当需要对两个set容器进行集合操作时，可以使用<code>set_intersection</code>、<code>set_difference</code>、<code>set_union</code>和<code>set_symmetric_difference</code>等函数。下面我将为你提供详细的代码示例。</p><h4 id="集合交集（set-intersection）"><a href="#集合交集（set-intersection）" class="headerlink" title="集合交集（set_intersection）"></a>集合交集（set_intersection）</h4><p><code>set_intersection</code>函数用于获取两个set容器的交集，即同时存在于两个容器中的元素。交集的结果保存在另一个set容器中。下面是一个使用<code>set_intersection</code>函数的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; set2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    std::<span class="built_in">set_intersection</span>(set1.<span class="built_in">begin</span>(), set1.<span class="built_in">end</span>(), set2.<span class="built_in">begin</span>(), set2.<span class="built_in">end</span>(), std::<span class="built_in">inserter</span>(result, result.<span class="built_in">begin</span>()));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;交集结果：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : result) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交集结果：3 4 5 </span><br></pre></td></tr></table></figure><h4 id="集合差集（set-difference）"><a href="#集合差集（set-difference）" class="headerlink" title="集合差集（set_difference）"></a>集合差集（set_difference）</h4><p><code>set_difference</code>函数用于获取两个set容器的差集，即在第一个容器中存在但在第二个容器中不存在的元素。差集的结果保存在另一个set容器中。下面是一个使用<code>set_difference</code>函数的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; set2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    std::<span class="built_in">set_difference</span>(set1.<span class="built_in">begin</span>(), set1.<span class="built_in">end</span>(), set2.<span class="built_in">begin</span>(), set2.<span class="built_in">end</span>(), std::<span class="built_in">inserter</span>(result, result.<span class="built_in">begin</span>()));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;差集结果：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : result) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">差集结果：1 2 </span><br></pre></td></tr></table></figure><h4 id="集合并集（set-union）"><a href="#集合并集（set-union）" class="headerlink" title="集合并集（set_union）"></a>集合并集（set_union）</h4><p><code>set_union</code>函数用于获取两个set容器的并集，即包含两个容器中所有元素的集合。并集的结果保存在另一个set容器中。下面是一个使用<code>set_union</code>函数的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; set2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    std::<span class="built_in">set_union</span>(set1.<span class="built_in">begin</span>(), set1.<span class="built_in">end</span>(), set2.<span class="built_in">begin</span>(), set2.<span class="built_in">end</span>(), std::<span class="built_in">inserter</span>(result, result.<span class="built_in">begin</span>()));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;并集结果：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : result) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">并集结果：1 2 3 4 5 6 7 </span><br></pre></td></tr></table></figure><h4 id="集合对称差集（set-symmetric-difference）"><a href="#集合对称差集（set-symmetric-difference）" class="headerlink" title="集合对称差集（set_symmetric_difference）"></a>集合对称差集（set_symmetric_difference）</h4><p><code>set_symmetric_difference</code>函数用于获取两个set容器的对称差集，即在两个容器中出现的元素，但不是同时出现在两个容器中的元素。对称差集的结果保存在另一个set容器中。下面是一个使用<code>set_symmetric_difference</code>函数的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; set2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    std::<span class="built_in">set_symmetric_difference</span>(set1.<span class="built_in">begin</span>(), set1.<span class="built_in">end</span>(), set2.<span class="built_in">begin</span>(), set2.<span class="built_in">end</span>(), std::<span class="built_in">inserter</span>(result, result.<span class="built_in">begin</span>()));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;对称差集结果：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : result) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对称差集结果：1 2 6 7 </span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇博客详细介绍了C++标准库中的<code>std::set</code>容器的用法。我们学习了如何定义set容器、插入元素、删除元素、判断容器是否为空、获取容器大小、查找元素以及遍历容器等操作。使用<code>std::set</code>容器，你可以高效地管理一组唯一元素，并根据需要进行各种操作。</p><p>希望本文能够帮助你理解和使用<code>std::set</code>容器。</p>]]></content>
      
      
      <categories>
          
          <category> Data Structure Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>月与夜：哲学之光与深夜思索</title>
      <link href="/2023/08/13/Six-MoonNight/"/>
      <url>/2023/08/13/Six-MoonNight/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=2059208608&auto=1&height=66"></iframe><h1 id="月与夜：哲学之光与深夜思索"><a href="#月与夜：哲学之光与深夜思索" class="headerlink" title="月与夜：哲学之光与深夜思索"></a>月与夜：哲学之光与深夜思索</h1><p>夜幕低垂，寂静的夜晚中，皎洁的明月轻轻升起，点亮了黑暗中的一片天空。在月光的映照下，大自然仿佛进入了一个诗意远方的世界。</p><h2 id="月与夜的对立与统一"><a href="#月与夜的对立与统一" class="headerlink" title="月与夜的对立与统一"></a>月与夜的对立与统一</h2><p>从哲学的角度来看，月与夜可以被视为对立与统一的象征。月代表着光明、清晰和理性，而夜则代表着黑暗、隐秘和感性。这种对立关系中，月和夜互为补充，共同构成了世界的完整性。</p><p>在柏拉图的哲学观点中，月可以被视为理念的世界，而夜则代表具体的现象世界。月的光芒照耀着夜的黑暗，给予夜以存在的意义，同时也通过夜的存在凸显了月的纯粹和高尚。月与夜的共存，展示了理念与现象、抽象与具体之间的辩证关系。</p><h2 id="月与夜的哲学阐释"><a href="#月与夜的哲学阐释" class="headerlink" title="月与夜的哲学阐释"></a>月与夜的哲学阐释</h2><p>在黑格尔的哲学中，月和夜可以被解读为对立的两个概念，构成了辩证法的矛盾。月代表着主动性、明确性和自我意识，而夜则代表着被动性、模糊性和无意识。月和夜的对立与斗争产生了新的合一，从而形成了更高级别的统一，这种统一被称为“合理性”。</p><p>在尼采的哲学中，月和夜可以被视为阿波罗与狄奥尼修斯的象征。月代表着理性、秩序和稳定，而夜则代表着感性、激情和混乱。阿波罗与狄奥尼修斯是对人类本性的不同表达，它们同时存在于人类心灵深处。月和夜的结合体现了人类内心的多元性和矛盾性，也呼应了尼采哲学中的生命力与艺术力的交融。</p><h2 id="人类与月夜的关联"><a href="#人类与月夜的关联" class="headerlink" title="人类与月夜的关联"></a>人类与月夜的关联</h2><p>长久以来，人类与月与夜有着紧密的关联。古人常以明月抒发思念之情，月夜也鼓舞着诗人们的灵感。当我们凝望着那清冷的月光，或许能感受到一种离乡背井的孤寂与温暖。夜晚则为人们提供了一个安静的思考和反思的时刻，让我们关注生活中最纯粹、最真实的感觉。<br><img src="http://sc1goen2r.hn-bkt.clouddn.com/yourname.jpg"></p><h2 id="未来的展望"><a href="#未来的展望" class="headerlink" title="未来的展望"></a>未来的展望</h2><p>月与夜所承载的深层意义将继续引领我们的思考。我们应超越二元对立，以开放的心态去理解和体验世界的复杂性与多样性。未来，我们可以通过更深入的哲学思考，探索宇宙的奥秘、探索人类存在的意义，并将这些思考融入到我们的生活和追求之中。</p><p>夜已深，明月还高悬，让我们在这宁静的时刻，与月夜相连，启迪内心的智慧之光。愿我们珍惜这份美好，用诗意的眼光去感受月与夜带给我们的深远思索和宁静。</p>]]></content>
      
      
      <categories>
          
          <category> ramblings </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 哲学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Explore sorting algorithms:from bubble to cardinality</title>
      <link href="/2023/08/11/Detailed-Explanation-of-Top-Ten-Sorting-Algorithms/"/>
      <url>/2023/08/11/Detailed-Explanation-of-Top-Ten-Sorting-Algorithms/</url>
      
        <content type="html"><![CDATA[<h1 id="十大排序算法详解"><a href="#十大排序算法详解" class="headerlink" title="十大排序算法详解"></a>十大排序算法详解</h1><p>在计算机科学中，排序算法是一种将一组元素按照特定顺序排列的算法。排序算法是解决各种排序问题的基础，它们的性能和适用场景各不相同。本文将介绍数据结构中的十大排序算法，以及它们的实现原理和C++代码示例。</p><h2 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1. 冒泡排序（Bubble Sort）"></a>1. 冒泡排序（Bubble Sort）</h2><p>冒泡排序是一种简单但效率较低的排序算法。它通过重复地遍历要排序的列表，在每次遍历过程中比较相邻的两个元素，并根据需要交换位置，直到整个列表排序完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n-i<span class="number">-1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2. 选择排序（Selection Sort）"></a>2. 选择排序（Selection Sort）</h2><p>选择排序每次从未排序的部分选择最小（或最大）的元素，并将其放到已排序部分的末尾。通过重复进行选择操作，最终可以得到一个有序列表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> min_idx = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min_idx]) &#123;</span><br><span class="line">                min_idx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[min_idx];</span><br><span class="line">        arr[min_idx] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3. 插入排序（Insertion Sort）"></a>3. 插入排序（Insertion Sort）</h2><p>插入排序的核心思想是将未排序的元素逐个插入到已排序部分的正确位置。通过不断地比较和移动元素，可以逐步构建有序列表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> key = arr[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-希尔排序（Shell-Sort）"><a href="#4-希尔排序（Shell-Sort）" class="headerlink" title="4. 希尔排序（Shell Sort）"></a>4. 希尔排序（Shell Sort）</h2><p>希尔排序是一种改进的插入排序算法，它通过将整个列表分割成多个较小的子列表进行插入排序，并逐渐缩小子列表的规模，最终完成排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> gap = n/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = arr[i];</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp; j -= gap) &#123;</span><br><span class="line">                arr[j] = arr[j - gap];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-快速排序（Quick-Sort）"><a href="#5-快速排序（Quick-Sort）" class="headerlink" title="5. 快速排序（Quick Sort）"></a>5. 快速排序（Quick Sort）</h2><p>快速排序是一种高效的分治排序算法。它通过选择一个基准元素，将列表划分为两个子列表，其中一个子列表的所有元素都小于等于基准元素，另一个子列表的所有元素都大于基准元素。然后，对两个子列表递归地应用快速排序，最终得到有序列表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[high];</span><br><span class="line">    <span class="type">int</span> i = (low - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = low; j &lt;= high - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="type">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> temp = arr[i + <span class="number">1</span>];</span><br><span class="line">    arr[i + <span class="number">1</span>] = arr[high];</span><br><span class="line">    arr[high] = temp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pi = <span class="built_in">partition</span>(arr, low, high);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">quickSort</span>(arr, low, pi - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(arr, pi + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-归并排序（Merge-Sort）"><a href="#6-归并排序（Merge-Sort）" class="headerlink" title="6. 归并排序（Merge Sort）"></a>6. 归并排序（Merge Sort）</h2><p>归并排序是一种高效的分治排序算法。它将列表递归地划分为较小的子列表，然后将这些子列表按照顺序合并，最终得到有序列表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合并两个子数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = mid - left + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n2 = right - mid;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建临时数组</span></span><br><span class="line">    <span class="type">int</span> L[n1], R[n2];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将数据复制到临时数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">        L[i] = arr[left + i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n2; j++)</span><br><span class="line">        R[j] = arr[mid + <span class="number">1</span> + j];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合并两个子数组</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> k = left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L[i] &lt;= R[j]) &#123;</span><br><span class="line">            arr[k] = L[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k] = R[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制剩余的元素（如果有）</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1) &#123;</span><br><span class="line">        arr[k] = L[i];</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2) &#123;</span><br><span class="line">        arr[k] = R[j];</span><br><span class="line">        j++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归排序左右子数组</span></span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, left, mid);</span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 合并已排序的子数组</span></span><br><span class="line">        <span class="built_in">merge</span>(arr, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-堆排序（Heap-Sort）"><a href="#7-堆排序（Heap-Sort）" class="headerlink" title="7. 堆排序（Heap Sort）"></a>7. 堆排序（Heap Sort）</h2><p>堆排序是一种基于二叉堆数据结构的排序算法。它首先将列表转换为最大堆或最小堆，然后依次将堆顶元素移除并放入已排序部分，直到整个列表排序完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调整子树以满足堆性质</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> largest = i;  <span class="comment">// 初始化最大值为根节点</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果左子节点比最大值大，更新最大值</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest])</span><br><span class="line">        largest = left;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果右子节点比最大值大，更新最大值</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest])</span><br><span class="line">        largest = right;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果最大值不是根节点，进行交换并继续调整子树</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[largest]);</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建最大堆（初始状态）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, i);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 依次将堆顶元素移动到已排序部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);  <span class="comment">// 将当前根节点（最大值）与最后一个叶子节点交换</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调整剩余的部分为最大堆</span></span><br><span class="line">        <span class="built_in">heapify</span>(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-计数排序（Counting-Sort）"><a href="#8-计数排序（Counting-Sort）" class="headerlink" title="8. 计数排序（Counting Sort）"></a>8. 计数排序（Counting Sort）</h2><p>计数排序是一种非比较排序算法，适用于已知数据范围的整数排序。它统计每个元素出现的次数，并根据统计信息对元素进行排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查找列表中的最大值</span></span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max)</span><br><span class="line">            max = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建计数数组并初始化为0</span></span><br><span class="line">    <span class="type">int</span>* count = <span class="keyword">new</span> <span class="type">int</span>[max + <span class="number">1</span>]();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 统计元素出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        count[arr[i]]++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据计数数组重新排序元素</span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= max; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (count[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            arr[index] = i;</span><br><span class="line">            index++;</span><br><span class="line">            count[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span>[] count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-桶排序（Bucket-Sort）"><a href="#9-桶排序（Bucket-Sort）" class="headerlink" title="9. 桶排序（Bucket Sort）"></a>9. 桶排序（Bucket Sort）</h2><p>桶排序是一种非比较排序算法，适用于已知数据范围的浮点数排序。它将列表划分为一定数量的桶，然后将元素分配到对应的桶中，每个桶再使用其他排序算法或递归地进行排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用插入排序对桶内元素排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(vector&lt;<span class="type">float</span>&gt;&amp; bucket)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = bucket.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">float</span> key = bucket[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; bucket[j] &gt; key) &#123;</span><br><span class="line">            bucket[j + <span class="number">1</span>] = bucket[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        bucket[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bucketSort</span><span class="params">(<span class="type">float</span> arr[], <span class="type">int</span> n, <span class="type">int</span> numBuckets)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">float</span>&gt;&gt; <span class="built_in">buckets</span>(numBuckets);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将元素分配到桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> bucketIndex = arr[i] * numBuckets;</span><br><span class="line">        buckets[bucketIndex].<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对每个桶内的元素进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numBuckets; i++)</span><br><span class="line">        <span class="built_in">insertionSort</span>(buckets[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将桶内的元素按顺序放入原始数组</span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numBuckets; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; buckets[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            arr[index] = buckets[i][j];</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-基数排序（Radix-Sort）"><a href="#10-基数排序（Radix-Sort）" class="headerlink" title="10. 基数排序（Radix Sort）"></a>10. 基数排序（Radix Sort）</h2><p>基数排序是一种非比较排序算法，适用于整数排序。它通过按照各个位数对元素进行排序，从最低有效位到最高有效位，最终得到有序列表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求解最大值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMax</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max)</span><br><span class="line">            max = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基数排序主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> max = <span class="built_in">getMax</span>(arr, n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对每个位数进行计数排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> exp = <span class="number">1</span>; max / exp &gt; <span class="number">0</span>; exp *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="type">int</span> output[n];  <span class="comment">// 存储排序后的结果</span></span><br><span class="line">        <span class="type">int</span> count[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 0-9的计数数组</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 统计当前位数上每个数字的出现次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            count[(arr[i] / exp) % <span class="number">10</span>]++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算累积次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 按照当前位数进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            output[count[(arr[i] / exp) % <span class="number">10</span>] - <span class="number">1</span>] = arr[i];</span><br><span class="line">            count[(arr[i] / exp) % <span class="number">10</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将排序后的结果复制回原始数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            arr[i] = output[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Here-is-a-table-analysis-of-the-sorting-algorithms-using-Markdown-syntax"><a href="#Here-is-a-table-analysis-of-the-sorting-algorithms-using-Markdown-syntax" class="headerlink" title="Here is a table analysis of the sorting algorithms using Markdown syntax:"></a>Here is a table analysis of the sorting algorithms using Markdown syntax:</h2><table><thead><tr><th>排序算法</th><th>时间复杂度</th><th>空间复杂度</th><th>适用场景</th></tr></thead><tbody><tr><td>冒泡排序</td><td>最好情况：O(n)<br>最坏情况：O(n^2)</td><td>O(1)</td><td>适用于小型数据集或基本有序的数据集，实现简单，但对于大规模数据效率较低</td></tr><tr><td>选择排序</td><td>O(n^2)</td><td>O(1)</td><td>适用于小型数据集，不占用额外空间，但对于大规模数据效率较低</td></tr><tr><td>插入排序</td><td>最好情况：O(n)<br>最坏情况：O(n^2)</td><td>O(1)</td><td>适用于小型数据集或基本有序的数据集，对于部分有序的数据效果较好</td></tr><tr><td>快速排序</td><td>平均情况：O(n*log(n))<br>最坏情况：O(n^2)</td><td>O(log(n))-O(n)</td><td>适用于大规模数据集，具有较高的平均性能，不需要额外空间</td></tr><tr><td>希尔排序</td><td>取决于增量序列的选择</td><td>O(1)</td><td>适用于中等大小的数据集，相较于简单排序算法，希尔排序在一定程度上提升了排序速度</td></tr><tr><td>归并排序</td><td>O(n*log(n))</td><td>O(n)</td><td>适用于大规模数据集，稳定且可靠，但占用较多的额外空间</td></tr><tr><td>堆排序</td><td>O(n*log(n))</td><td>O(1)</td><td>适用于大规模数据集，对于选择最大/最小元素具有高效性能，但不稳定</td></tr><tr><td>计数排序</td><td>O(n+k)（k为输入范围）</td><td>O(k)</td><td>适用于已知数据范围的整数排序，非常高效，但需要额外空间</td></tr><tr><td>桶排序</td><td>O(n+k)（k为桶的数量）</td><td>O(n+k)</td><td>适用于已知数据范围的浮点数排序，对于分布均匀的数据集效果较好</td></tr><tr><td>基数排序</td><td>O(d*(n+k))（d为最大元素位数，k为基数）</td><td>O(n+k)</td><td>适用于整数排序，特别是位数较小的整数，且数据集范围较小</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Data Structure Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构算法 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>风的旅程</title>
      <link href="/2023/08/11/xzp-fblog-ramblings/"/>
      <url>/2023/08/11/xzp-fblog-ramblings/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=427606780&auto=1&height=66"></iframe><h1 id="风的旅程"><a href="#风的旅程" class="headerlink" title="风的旅程"></a>风的旅程</h1><p>风来自很远的地方，轻柔地穿梭于时光的缝隙，<br>它带着远方的气息，漫游在无垠的天空中。</p><p>偶尔，风会停下脚步，近距离观察每一个细微的瞬间，<br>它轻抚花瓣，轻拂树叶，似乎在述说着流转的故事。</p><p>风没有栖息之处，却无所畏惧，<br>它以自由的姿态展翅飞翔，留下一串渐行渐远的足迹。</p><p><img src="http://sc1goen2r.hn-bkt.clouddn.com/%E4%BA%BA%E5%83%8F3.jpg"></p><p>或许，风是在寻找迷失的灵魂，寻觅心灵的归宿，<br>它吹散沉重的忧伤，吹拂人们内心的尘埃。</p><p>风知道，每一个刹那瞬间都是美的存在，<br>它用轻轻的呼吸，将这美好的瞬间铭记于心灵深处。</p><p>去去也无妨，风终将回到起点，<br>它将带着经历的智慧，告诉那些犹豫前行的旅人：</p><p>生活如同风的旅程，不妨放飞心灵，追寻内心的真实，<br>在短暂的人生中，将美好的瞬间谱写成永恒的诗篇。</p><p>让风带走忧愁，让心灵荡起勇敢的涟漪，<br>风来自很远的地方，去去也无妨，让生命在追寻中闪烁绽放。<br><img src="http://sc1goen2r.hn-bkt.clouddn.com/%E9%A3%8E%E6%99%AF1.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> ramblings </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读四大名著有感</title>
      <link href="/2023/08/10/xiao-third-blog-reading/"/>
      <url>/2023/08/10/xiao-third-blog-reading/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=2042350186&auto=1&height=66"></iframe><h2 id="《红楼梦》"><a href="#《红楼梦》" class="headerlink" title="《红楼梦》"></a><strong>《红楼梦》</strong></h2><p>《红楼梦》是中国四大名著之一，被誉为中国古典小说的巅峰之作。它以贾、史、王、薛四大家族的兴衰为背景，通过一系列丰富多彩的人物形象和情节，展现了封建社会的种种弊端和虚伪。这部小说以其独特的艺术魅力和深刻的社会批判性使其在现实中依然具有重要的意义。</p><h3 id="观后感："><a href="#观后感：" class="headerlink" title="观后感："></a><strong>观后感：</strong></h3><p>《红楼梦》描绘了一个宏大而精致的封建社会，不仅仅是一部家族的兴衰史，更是对封建社会道德观念的深刻剖析。小说中的人物形象栩栩如生，他们追求权力、享乐和财富，却忽略了真正的人情与真善美。贾宝玉、林黛玉、王熙凤等人物的形象给人留下深刻的印象，他们既是传统文化的典型代表，也具备着普遍的生命意义。</p><p>《红楼梦》通过对贾、史、王、薛四大家族的描写，展现了封建社会的虚伪和道德沦丧。尤其是通过贾府的描述，小说深刻地揭示了封建家族内部权力斗争和人性的复杂性。从贾政、贾母到贾宝玉，他们身陷权谋之中，忘记了最初的善良与纯真。这些形象使读者深思封建社会的道德沦丧和人性的扭曲。</p><h3 id="与现实的联系："><a href="#与现实的联系：" class="headerlink" title="与现实的联系："></a>与现实的联系：</h3><p>《红楼梦》中描写的虚伪、权谋、财富追逐等主题在现实社会同样存在。封建社会虽已过去，但人性的弱点和社会问题依然存在。现实中，我们也经常看到人们追求权力、财富而忽略了真正的人情与真善美。贪污腐败、权力斗争等问题仍然不断涌现，这些现象与小说中描述的封建社会的虚伪性有着异曲同工之妙。</p><p>同时，《红楼梦》中展现的女性形象和性别歧视问题也与现实息息相关。小说中的女性形象丰满而复杂，她们有着自己的思想和情感，但却受制于封建社会的束缚。这使人们反思在现实社会中女性地位的问题和性别歧视的存在。</p><p>总的来说，《红楼梦》以其细腻的描写、深刻的人物形象和对封建社会弊端的批判，在现实中依然具有深远的意义。小说通过对社会和个人的剖析，引发了读者对现实社会的思考和反思。它不仅是一部文学作品，更是一面镜子，让人们反思人性的弱点、社会的问题，进而寻求改变和进步的可能性。</p><h2 id="《西游记》"><a href="#《西游记》" class="headerlink" title="《西游记》"></a>《西游记》</h2><p>《西游记》是中国四大名著之一，被誉为中国古代小说中的经典之作。它讲述了孙悟空、猪八戒、沙僧和唐僧师徒四人西天取经的故事，在奇幻的背景下，呈现了各种人物形象和故事情节。这部小说以其幽默风趣、寓意深远的特点，深受广大读者的喜爱，并在现实中有着广泛的影响。</p><h3 id="观后感：-1"><a href="#观后感：-1" class="headerlink" title="观后感："></a><strong>观后感：</strong></h3><p>《西游记》以其独特的创意和神话色彩成为中国古代小说中的经典之作。小说通过一系列想象丰富、情节曲折的故事，呈现了各种神仙、妖怪和人类的形象。其中最引人注目的是孙悟空，他聪明机智、勇敢无畏，成为了中国文化中具有象征意义的英雄形象。通过这些幽默而深刻的描写，小说传递了对于人性的思考和对于正义与善的追求。</p><p>《西游记》中的每个故事情节都寓意深远，蕴含着对人性、善恶、道德等方面的品味。小说中的形象和故事超越了现实世界的限制，带有一种超然的艺术感和哲学思考。孙悟空的反叛、唐僧的慈悲、猪八戒的贪婪和沙僧的忍耐，都给人以启示，让人们反思自身的行为和价值观。</p><h3 id="与现实的联系：-1"><a href="#与现实的联系：-1" class="headerlink" title="与现实的联系："></a>与现实的联系：</h3><p>《西游记》中的故事情节和人物形象在现实中也有着深远的影响。故事中展现出的对于正义与善的追求、对于勇气和智慧的推崇，都是现实生活中值得借鉴的品质。孙悟空作为一个反抗者和保护者的形象，给人们勇气和力量去面对困难和挑战。</p><p>同时，《西游记》中的人物形象也反映了人性中的弱点和问题。孙悟空的傲慢、猪八戒的贪婪等都是现实社会中存在的弱点，这使得人们反思自身的行为和修炼。</p><p>总的来说，《西游记》以其丰富的想象力和深刻的寓意，在现实中依然具有重要的价值。小说展示了正义与善的力量，鼓舞了人们勇气和智慧的追求。通过对人性的深刻描写，小说让读者反思自身的行为和思考，去探索人性的本质和价值观的塑造。</p><h2 id="《水浒传》"><a href="#《水浒传》" class="headerlink" title="《水浒传》"></a><strong>《水浒传》</strong></h2><p>《水浒传》是中国四大名著之一，被誉为中国古代小说中的巅峰之作。它以宋江等梁山好汉的故事为主线，描绘了农民起义和反抗封建统治的斗争。这部小说具有浓厚的英雄史诗风格，通过对人物形象的塑造和故事情节的铺陈，展现了正义与邪恶、忠诚与背叛等复杂的道德困境。</p><h3 id="观后感：-2"><a href="#观后感：-2" class="headerlink" title="观后感："></a><strong>观后感：</strong></h3><p>《水浒传》通过对宋江等108位梁山好汉的故事的描述，展现了他们的成长经历、人性斗争和忠诚品质。小说中的人物形象生动鲜明，每个梁山好汉都有自己的性格特点和命运轨迹，使读者能够真切地感受到他们的喜怒哀乐。小说还揭示了封建社会不公和压迫的问题，并以梁山好汉的反抗精神和正义情怀呼唤着社会的改变。</p><p>《水浒传》以其宏大的史诗气势和丰富的情节成为中国古代小说中的经典之作。小说中的英雄形象和故事情节激发着读者的崇高情怀和正义意识，展现了人性中的复杂性。</p><h3 id="与现实的联系：-2"><a href="#与现实的联系：-2" class="headerlink" title="与现实的联系："></a>与现实的联系：</h3><p>《水浒传》中描绘的农民起义、反抗封建统治的主题在现实中具有深刻的联系。尽管故事背景发生在古代，但其中所蕴含的反抗不义、追求自由和正义的精神依然具有现实意义。现实社会中，仍然存在着各种不公平和不正义的现象，人们对于这些问题的反抗和呼唤正义的声音依然存在。</p><p>同时，《水浒传》中塑造的人物形象也与现实中的人性存在共鸣。小说中的人物有着各式各样的性格和命运，有英勇善战的好汉，亦有机智狡诈的奸人，他们的行为和选择反映了现实中人性的复杂性。这使人们不仅能够欣赏故事的精彩，也能够思考和反思自身的行为和选择。</p><p>总的来说，《水浒传》以其壮观的叙事风格和对人性、正义的思考，在现实中依然具有重要的价值。小说通过对英雄形象和故事情节的描绘，引发了读者对社会现象的深思和社会变革的渴望。尽管时代变迁，但《水浒传》中所展现的人性困境和反抗精神依然在现实中具有重要的意义。</p><h2 id="《三国演义》"><a href="#《三国演义》" class="headerlink" title="《三国演义》"></a><strong>《三国演义》</strong></h2><p>《三国演义》是中国四大名著之一，是一部以中国历史上三国时期为背景的长篇历史小说。它以刘备、关羽、张飞等著名人物的故事为主线，描绘了三国鼎立的历史画卷。这部小说不仅展示了英雄豪杰的形象和战争的激烈，也反映了权谋斗争和人性的复杂性。</p><h3 id="观后感：-3"><a href="#观后感：-3" class="headerlink" title="观后感："></a><strong>观后感：</strong></h3><p>《三国演义》是一部宏大的历史史诗，通过对那个战乱纷争的时代的描写，展现了各类人物的命运和选择。小说中的人物形象栩栩如生，刘备、关羽、张飞等英雄人物给人留下了深刻的印象。他们或忠诚无私，或机智谋略，或短视贪婪，都是那个时代和社会的缩影。</p><p>《三国演义》通过对权谋斗争、英雄事迹的描写，展示了人性的复杂性。小说中的人物有着各自的欲望、利益和信仰，他们在权力的角逐中展现出各种品质和行为。这使得读者对于权力与道德、忠诚与背叛等问题进行了深刻思考。</p><h3 id="与现实的联系：-3"><a href="#与现实的联系：-3" class="headerlink" title="与现实的联系："></a>与现实的联系：</h3><p>《三国演义》中塑造的人物形象和情节在现实中有着深远的影响。故事中展现的权谋斗争、战争冲突等主题在现实社会中依然存在。人们对于权力、利益的追逐和争夺是人性中普遍存在的弱点。小说对权力、利益、忠诚等问题的探讨，引发了读者对现实社会的思考和反思。</p><p>同时，《三国演义》中英雄形象所表现的忠诚、勇气、智慧等品质也与现实中的人性存在共通之处。现实社会中仍然有人们追求正义、维护和平的行为，这些行为与小说中英雄形象所展现的特质不谋而合。</p><p>总的来说，《三国演义》以其壮阔的历史背景和丰富的人物群像，在现实中依然具有重要的意义。小说通过对权谋斗争和人性复杂性的描写，引发了读者对权力、道德和人性的思考。它不仅是一部具有历史价值的文学作品，也是一面反映现实社会中人性困境和价值观的镜子。</p>]]></content>
      
      
      <categories>
          
          <category> literature </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读后感 </tag>
            
            <tag> 经典百书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Analysis of classic algorithm problems of linked list</title>
      <link href="/2023/08/10/xiao-second-blog/"/>
      <url>/2023/08/10/xiao-second-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>摘要是玩笑玩笑嘿嘿，我们直奔主题嗷~</p><h2 id="第一题：JZ35-复杂链表的复制（Hard）"><a href="#第一题：JZ35-复杂链表的复制（Hard）" class="headerlink" title="第一题：JZ35 复杂链表的复制（Hard）"></a>第一题：JZ35 复杂链表的复制（Hard）</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。<br>（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）。 </p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode* <span class="title">Clone</span><span class="params">(RandomListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123; <span class="comment">// 检查原始链表是否为空</span></span><br><span class="line">            <span class="keyword">return</span> pHead; <span class="comment">// 如果为空，则直接返回空指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第一步：在每个原始节点后插入复制节点</span></span><br><span class="line">        RandomListNode* cur = pHead;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            RandomListNode* clone = <span class="keyword">new</span> <span class="built_in">RandomListNode</span>(cur-&gt;label); <span class="comment">// 创建新的复制节点</span></span><br><span class="line">            clone-&gt;next = cur-&gt;next; <span class="comment">// 将复制节点指向下一个原始节点</span></span><br><span class="line">            cur-&gt;next = clone; <span class="comment">// 将当前原始节点指向复制节点</span></span><br><span class="line">            cur = clone-&gt;next; <span class="comment">// 移动到下一个原始节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第二步：设置复制节点的随机指针</span></span><br><span class="line">        cur = pHead; <span class="comment">// 重新回到原始链表的头节点</span></span><br><span class="line">        RandomListNode* clone = pHead-&gt;next; <span class="comment">// 复制链表的头节点为原始链表的下一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;random == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果当前原始节点的随机指针为空</span></span><br><span class="line">                clone-&gt;random = <span class="literal">nullptr</span>; <span class="comment">// 复制节点的随机指针也为空</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                clone-&gt;random = cur-&gt;random-&gt;next; <span class="comment">// 复制节点的随机指针指向当前原始节点的随机指针对应的复制节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            cur = clone-&gt;next; <span class="comment">// 移动到下一个原始节点</span></span><br><span class="line">            <span class="keyword">if</span> (clone-&gt;next) &#123; <span class="comment">// 如果当前复制节点存在下一个节点</span></span><br><span class="line">                clone = cur-&gt;next; <span class="comment">// 则将复制节点指向下一个复制节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第三步：将原始链表和复制链表分离</span></span><br><span class="line">        cur = pHead; <span class="comment">// 重新回到原始链表的头节点</span></span><br><span class="line">        RandomListNode* res = pHead-&gt;next; <span class="comment">// 复制链表的头节点为原始链表的下一个节点</span></span><br><span class="line">        clone = res; <span class="comment">// 复制链表的当前节点为复制链表的头节点</span></span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            cur-&gt;next = clone-&gt;next; <span class="comment">// 将原始节点的下一个节点指向复制节点的下一个节点</span></span><br><span class="line">            cur = cur-&gt;next; <span class="comment">// 移动到下一个原始节点</span></span><br><span class="line">            <span class="keyword">if</span> (clone-&gt;next) &#123; <span class="comment">// 如果当前复制节点存在下一个节点</span></span><br><span class="line">                clone-&gt;next = cur-&gt;next; <span class="comment">// 则将复制节点的下一个节点指向复制节点的下下个节点</span></span><br><span class="line">                clone = clone-&gt;next; <span class="comment">// 移动到下一个复制节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回复制链表的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路-amp-步骤-amp-复杂度"><a href="#思路-amp-步骤-amp-复杂度" class="headerlink" title="思路&amp;步骤&amp;复杂度"></a>思路&amp;步骤&amp;复杂度</h4><p>当我们要复制一个含有随机指针的链表时，可以采用以下步骤来完成复制操作，并保持原始链表节点之间的随机关系。</p><p><strong>算法思路剖析：</strong></p><ol><li><p><strong>第一步：在每个原始节点后插入复制节点</strong></p><ul><li>遍历原始链表，从头节点开始。</li><li>对于每个原始节点<code>cur</code>，创建一个新的复制节点<code>clone</code>。</li><li>将<code>clone</code>节点的值设为与<code>cur</code>节点相同。</li><li>将<code>clone</code>节点插入到<code>cur</code>节点的后面，即<code>cur.next</code>指向<code>clone</code>。</li></ul></li><li><p><strong>第二步：设置复制节点的随机指针</strong></p><ul><li>再次遍历链表，从头节点开始。</li><li>对于每个原始节点<code>cur</code>，将其对应的复制节点<code>clone</code>的随机指针指向<code>cur</code>节点的随机指针指向的节点的复制节点。</li><li>如果原始节点的随机指针为空，则复制节点的随机指针也为空。</li></ul></li><li><p><strong>第三步：将原始链表和复制链表分离</strong></p><ul><li>再次遍历链表，从头节点开始。</li><li>对于每个原始节点<code>cur</code>，将其<code>next</code>指针指向下一个原始节点<code>cur.next</code>。</li><li>将复制节点<code>clone</code>的<code>next</code>指针指向下一个复制节点<code>clone.next</code>。</li></ul></li></ol><p>最后，返回复制链表的头节点，即原始链表的下一个节点。</p><p><strong>算法时空复杂度分析：</strong></p><ul><li>时间复杂度：O(n)，其中n是链表的长度。因为我们需要遍历链表三次，每次遍历都只需要常数级别的操作。</li><li>空间复杂度：O(n)，因为除了原始链表节点外，我们还需要创建相同数量的复制链表节点。</li></ul><h2 id="第二题：JZ23-链表中环的入口结点-Middle"><a href="#第二题：JZ23-链表中环的入口结点-Middle" class="headerlink" title="第二题：JZ23 链表中环的入口结点(Middle)"></a>第二题：JZ23 链表中环的入口结点(Middle)</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特判链表为空或只有一个节点的情况，无环</span></span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="literal">nullptr</span>||pHead-&gt;next==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 快慢指针初始化为头结点</span></span><br><span class="line">        ListNode* fast = pHead;</span><br><span class="line">        ListNode* slow = pHead;</span><br><span class="line">        <span class="comment">// 找到快慢指针第一次相遇的位置</span></span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next; <span class="comment">// 快指针每次前进两步</span></span><br><span class="line">            slow = slow-&gt;next; <span class="comment">// 慢指针每次前进一步</span></span><br><span class="line">            <span class="keyword">if</span>(slow == fast)&#123; <span class="comment">// 快慢指针相遇，说明有环存在</span></span><br><span class="line">                <span class="comment">// 慢指针回到头结点，然后和快指针以相同的速度前进，</span></span><br><span class="line">                <span class="comment">// 当它们再次相遇时就是环的入口节点</span></span><br><span class="line">                slow = pHead;</span><br><span class="line">                <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow; <span class="comment">// 返回环的入口节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 无环，返回nullptr</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路-amp-步骤-amp-复杂度-1"><a href="#思路-amp-步骤-amp-复杂度-1" class="headerlink" title="思路&amp;步骤&amp;复杂度"></a>思路&amp;步骤&amp;复杂度</h4><p><strong>算法步骤：</strong></p><ol><li>如果链表为空或只有一个节点，则无环，返回<code>nullptr</code>。</li><li>初始化快慢指针<code>fast</code>和<code>slow</code>为链表的头结点<code>pHead</code>。</li><li>使用快慢指针寻找环：<ul><li>快指针每次前进两步，慢指针每次前进一步，直到它们相遇或快指针到达链表尾部。</li><li>若快慢指针相遇，说明链表中存在环。</li></ul></li><li>若有环存在，则将慢指针重新指向头结点，然后使用相同的速度前进：<ul><li>当慢指针和快指针再次相遇时，即为环的入口节点。</li></ul></li><li>若无环存在，返回<code>nullptr</code>。</li></ol><p>整体来说，该算法通过快慢指针来判断链表中是否存在环，并且找出环的入口节点。</p><p><strong>时间复杂度：</strong><br>该算法采用了快慢指针的方式来寻找链表中的环，时间复杂度为 <code>O(n)</code>，其中 <code>n</code> 是链表的长度。</p><p><strong>空间复杂度：</strong><br>该算法只使用了两个辅助指针 <code>fast</code> 和 <code>slow</code>，没有使用额外的数据结构，因此空间复杂度为 <code>O(1)</code>（常数级别）。</p><h2 id="第三题：JZ52-两个链表的第一个公共结点-Easy"><a href="#第三题：JZ52-两个链表的第一个公共结点-Easy" class="headerlink" title="第三题：JZ52 两个链表的第一个公共结点(Easy)"></a>第三题：JZ52 两个链表的第一个公共结点(Easy)</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。<br>（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead1 == <span class="literal">nullptr</span> || pHead2 == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果其中一个链表为空，则直接返回空指针</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* head1 = pHead1; <span class="comment">// 创建指针head1，指向链表pHead1的头节点</span></span><br><span class="line">        ListNode* head2 = pHead2; <span class="comment">// 创建指针head2，指向链表pHead2的头节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (head1 != head2) &#123; <span class="comment">// 当head1和head2不相等时，执行循环</span></span><br><span class="line">            <span class="keyword">if</span> (head1 == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果head1到达链表末尾，将它重新指向pHead2的头节点</span></span><br><span class="line">                head1 = pHead2;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                head1 = head1-&gt;next; <span class="comment">// 否则，将head1向后移动一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (head2 == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果head2到达链表末尾，将它重新指向pHead1的头节点</span></span><br><span class="line">                head2 = pHead1;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                head2 = head2-&gt;next; <span class="comment">// 否则，将head2向后移动一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head1; <span class="comment">// 返回相等的节点，即为两个链表的第一个公共节点，如果没有公共节点则返回空指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路-amp-步骤-amp-复杂度-2"><a href="#思路-amp-步骤-amp-复杂度-2" class="headerlink" title="思路&amp;步骤&amp;复杂度"></a>思路&amp;步骤&amp;复杂度</h4><p>这段代码实现了找到两个链表的第一个公共节点的功能。<br>输入参数为两个指向链表头节点的指针 <code>pHead1</code> 和 <code>pHead2</code>，返回值为链表中的一个节点，表示两个链表的第一个公共节点。<br>如果两个链表没有公共节点，则返回空指针。</p><p>算法思路如下：</p><ol><li>首先判断 <code>pHead1</code> 和 <code>pHead2</code> 是否为空，如果其中一个为空，则直接返回空指针。</li><li>创建两个指针 <code>head1</code> 和 <code>head2</code> 分别指向 <code>pHead1</code> 和 <code>pHead2</code>，用于遍历两个链表。同时进入循环。</li><li>当 <code>head1</code> 和 <code>head2</code> 相等时，退出循环，返回相等的节点即为两个链表的第一个公共节点，如果循环所有节点后仍未找到公共节点，则返回空指针。</li><li>在循环过程中，分别对 <code>head1</code> 和 <code>head2</code> 进行以下操作：<ul><li>如果 <code>head1</code> 到达了链表末尾，将它重新指向 <code>pHead2</code> 的头节点，如果 <code>head2</code> 到达了链表末尾，将它重新指向 <code>pHead1</code> 的头节点。这样可以让两个指针同步地遍历两个链表的所有节点，最终找到公共节点或者同时到达链表末尾退出循环。</li><li>否则，将 <code>head1</code> 和 <code>head2</code> 都向后移动一个节点，继续比较下一个节点是否相同。</li></ul></li><li>循环结束后，返回相等的节点即为两个链表的第一个公共节点，如果未找到公共节点，则返回空指针。</li></ol><p>算法的时间复杂度为 <code>O(m+n)</code>，其中 <code>m</code> 和 <code>n</code> 分别是两个链表的长度。在最坏情况下，需要遍历两个链表的所有节点，但是由于两个指针同步地向前移动，所以最多只需遍历两个链表的长度之和。</p><p>算法的空间复杂度为 <code>O(1)</code>，只使用了常数个额外的指针变量来保存中间结果，没有使用额外的动态空间。</p><h2 id="第四题：JZ24-反转链表（Easy）"><a href="#第四题：JZ24-反转链表（Easy）" class="headerlink" title="第四题：JZ24 反转链表（Easy）"></a>第四题：JZ24 反转链表（Easy）</h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。</p><h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>)&#123; <span class="comment">// 如果链表为空或者只有一个节点，则直接返回链表头节点</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode*pre=<span class="literal">nullptr</span>; <span class="comment">// 定义一个指针变量pre，表示待反转部分的前一个节点，初始化为nullptr</span></span><br><span class="line">        ListNode*cur=head; <span class="comment">// 定义一个指针变量cur，表示当前节点，初始化为头节点</span></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123; <span class="comment">// 当cur不为nullptr时，进入循环，进行反转操作</span></span><br><span class="line">            ListNode*temp=cur-&gt;next; <span class="comment">// 创建一个临时指针变量temp，保存当前节点的下一个节点</span></span><br><span class="line">            cur-&gt;next=pre; <span class="comment">// 将当前节点的next指针指向pre，实现反转操作</span></span><br><span class="line">            pre=cur; <span class="comment">// 更新pre为当前节点</span></span><br><span class="line">            cur=temp; <span class="comment">// 更新cur为临时节点temp，继续下一次循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre; <span class="comment">// 返回反转后的链表头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路-amp-步骤-amp-复杂度-3"><a href="#思路-amp-步骤-amp-复杂度-3" class="headerlink" title="思路&amp;步骤&amp;复杂度"></a>思路&amp;步骤&amp;复杂度</h4><p>函数接受一个 <code>ListNode*</code> 类型的参数 <code>head</code>，表示链表的头节点，并返回一个 <code>ListNode*</code> 类型的结果，表示反转后的链表的头节点。</p><p>算法思路如下：</p><ol><li>如果输入的链表头节点 <code>head</code> 是 <code>nullptr</code> 或者链表只有一个节点（<code>head-&gt;next</code> 是 <code>nullptr</code>），则直接返回 <code>head</code>。</li><li>定义两个指针变量 <code>pre</code> 和 <code>cur</code>，初始时都指向 <code>nullptr</code> 和 <code>head</code>，分别表示待反转部分的前一个节点和当前节点。</li><li>进入循环，当 <code>cur</code> 不为 <code>nullptr</code> 时：<ul><li>创建一个临时指针变量 <code>temp</code>，保存 <code>cur-&gt;next</code>，即当前节点的下一个节点。</li><li>将当前节点的 <code>next</code> 指针指向 <code>pre</code>，实现反转操作。</li><li>更新 <code>pre</code> 为当前节点 <code>cur</code>，更新 <code>cur</code> 为临时节点 <code>temp</code>。</li></ul></li><li>循环结束后，链表已经完成了反转。返回 <code>pre</code>，即反转后的链表头节点。</li></ol><p>算法的时间复杂度为 <code>O(n)</code>，其中 <code>n</code> 是链表的长度。算法需要遍历整个链表一次，并在每次循环中进行常数次的操作。</p><p>算法的空间复杂度为 <code>O(1)</code>，只使用了常数个额外的指针变量来保存中间结果。没有使用额外的动态空间。</p><h2 id="第五题：JZ6-从尾到头打印链表-Easy"><a href="#第五题：JZ6-从尾到头打印链表-Easy" class="headerlink" title="第五题：JZ6 从尾到头打印链表(Easy)"></a>第五题：JZ6 从尾到头打印链表(Easy)</h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案-1"></a>解决方案-1</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res; <span class="comment">// 定义一个空的 vector 容器 res，用来存储链表节点值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果输入的链表头结点 head 是 nullptr，即链表为空，则直接返回空的 vector 容器</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* cur = head; <span class="comment">// 定义一个指针变量 cur，初始化为 head，表示当前遍历到的节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123; <span class="comment">// 进入循环，当 cur 不为空时</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(cur-&gt;val); <span class="comment">// 将当前节点的值 cur-&gt;val 添加到向量 res 中</span></span><br><span class="line">            cur = cur-&gt;next; <span class="comment">// 将指针 cur 指向下一个节点 cur-&gt;next</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>()); <span class="comment">// 使用 reverse() 函数将向量 res 反转，使得向量中的元素从尾部到头部排列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回反转后的 vector 容器 res</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路-amp-步骤-amp-复杂度-4"><a href="#思路-amp-步骤-amp-复杂度-4" class="headerlink" title="思路&amp;步骤&amp;复杂度"></a>思路&amp;步骤&amp;复杂度</h4><p>该代码实现了从链表尾部到头部输出链表节点值的功能。</p><ol><li>定义一个空的 vector 容器 <code>res</code>，用来存储链表节点值。</li><li>如果输入的链表头结点 <code>head</code> 是 <code>nullptr</code>，即链表为空，则直接返回空的 vector 容器。</li><li>定义一个指针变量 <code>cur</code>，初始化为 <code>head</code>。</li><li>进入循环，当 <code>cur</code> 不为空时，将当前节点的值 <code>cur-&gt;val</code> 添加到向量 <code>res</code> 中，然后将指针 <code>cur</code> 指向下一个节点 <code>cur-&gt;next</code>。</li><li>循环结束后，使用 <code>reverse()</code> 函数将向量 <code>res</code> 反转，使得向量中的元素从尾部到头部排列。</li><li>返回反转后的 vector 容器 <code>res</code>。</li></ol><p>该算法的时间复杂度为 <code>O(n)</code>，其中 <code>n</code> 是链表的长度。算法需要遍历整个链表一次，并且需要对 vector 容器进行一次反转操作，时间复杂度均为 <code>O(n)</code>。<br>同时，算法只需使用常数个额外空间，空间复杂度为 <code>O(n)</code>（主要是用于存储 vector 容器）。</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案-2"></a>解决方案-2</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res; <span class="comment">// 定义一个空的 vector 容器 res，用来存储链表节点值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果输入的链表头结点 head 是 nullptr，即链表为空，则直接返回空的 vector 容器</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stack; <span class="comment">// 定义一个栈 stack，用于暂存链表节点值</span></span><br><span class="line">        ListNode* cur = head; <span class="comment">// 定义一个指针变量 cur，初始化为 head，表示当前遍历到的节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123; <span class="comment">// 进入循环，当 cur 不为空时</span></span><br><span class="line">            stack.<span class="built_in">push</span>(cur-&gt;val); <span class="comment">// 将当前节点的值 cur-&gt;val 压入栈 stack 中</span></span><br><span class="line">            cur = cur-&gt;next; <span class="comment">// 将指针 cur 指向下一个节点 cur-&gt;next</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>()) &#123; <span class="comment">// 进入循环，当栈 stack 不为空时</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(stack.<span class="built_in">top</span>()); <span class="comment">// 依次将栈顶元素弹出并添加到向量 res 中</span></span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回向量 res</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路-amp-步骤-amp-复杂度-5"><a href="#思路-amp-步骤-amp-复杂度-5" class="headerlink" title="思路&amp;步骤&amp;复杂度"></a>思路&amp;步骤&amp;复杂度</h4><p>该代码实现了从链表尾部到头部输出链表节点值的功能。</p><ol><li>定义一个空的 vector 容器 <code>res</code>，用来存储链表节点值。</li><li>如果输入的链表头结点 <code>head</code> 是 <code>nullptr</code>，即链表为空，则直接返回空的 vector 容器。</li><li>定义一个栈 <code>stack</code>，用于暂存链表节点值。</li><li>定义一个指针变量 <code>cur</code>，初始化为 <code>head</code>，表示当前遍历到的节点。</li><li>进入循环，当 <code>cur</code> 不为空时，将当前节点的值 <code>cur-&gt;val</code> 压入栈 <code>stack</code> 中，然后将指针 <code>cur</code> 指向下一个节点 <code>cur-&gt;next</code>。</li><li>循环结束后，使用另一个循环，当栈 <code>stack</code> 不为空时，依次将栈顶元素弹出并添加到向量 <code>res</code> 中。</li><li>返回向量 <code>res</code>。</li></ol><p>该算法的时间复杂度为 <code>O(n)</code>，其中 <code>n</code> 是链表的长度。算法需要遍历整个链表一次，并且需要将所有节点值压入栈中，时间复杂度均为 <code>O(n)</code>。<br>同时，算法只需使用常数个额外空间，空间复杂度为 <code>O(n)</code>（主要是用于存储栈和向量容器）。</p><h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案-3"></a>解决方案-3</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res; <span class="comment">// 定义一个空的 vector 容器 res，用来存储链表节点值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果输入的链表头结点 head 是 nullptr，即链表为空，则直接返回空的 vector 容器</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; dq; <span class="comment">// 定义一个双端队列 dq，用于暂存链表节点值</span></span><br><span class="line">        ListNode* cur = head; <span class="comment">// 定义一个指针变量 cur，初始化为 head，表示当前遍历到的节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123; <span class="comment">// 进入循环，当 cur 不为空时</span></span><br><span class="line">            dq.<span class="built_in">push_back</span>(cur-&gt;val); <span class="comment">// 将当前节点的值 cur-&gt;val 从尾部插入双端队列 dq 中</span></span><br><span class="line">            cur = cur-&gt;next; <span class="comment">// 将指针 cur 指向下一个节点 cur-&gt;next</span></span><br><span class="line">            <span class="comment">//dq.push_front(cur-&gt;val);如果是对队头操作，下面循环内容则需要同步更改</span></span><br><span class="line">            <span class="comment">//cur = cur-&gt;next;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>()) &#123; <span class="comment">// 进入循环，当双端队列 dq 不为空时</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(dq.<span class="built_in">back</span>()); <span class="comment">// 将双端队列 dq 的最后一个元素从尾部取出并添加到向量 res 中</span></span><br><span class="line">            dq.<span class="built_in">pop_back</span>(); <span class="comment">// 移除双端队列 dq 的最后一个元素</span></span><br><span class="line">            <span class="comment">//res.push_back(dq.front());</span></span><br><span class="line">            <span class="comment">//dq.pop_front();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回向量 res</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路-amp-步骤-amp-复杂度-6"><a href="#思路-amp-步骤-amp-复杂度-6" class="headerlink" title="思路&amp;步骤&amp;复杂度"></a>思路&amp;步骤&amp;复杂度</h4><p>算法思路与之前相同，只是使用了双端队列 deque 代替了栈。首先遍历链表，将节点值从尾部插入双端队列 dq，然后再从尾部读取双端队列中的元素并添加到结果向量 res 中。</p><p>该算法的时间复杂度为 O(n)，其中 nn 是链表的长度。算法需要遍历整个链表一次，并且需要将所有节点值从尾部插入双端队列 dq 中，时间复杂度均为 O(n)。<br>同时，算法只需使用常数个额外空间，空间复杂度为 O(n)（主要是用于存储双端队列和向量容器）。</p><h2 id="第六题：JZ25-合并两个排序的链表-Easy"><a href="#第六题：JZ25-合并两个排序的链表-Easy" class="headerlink" title="第六题：JZ25 合并两个排序的链表(Easy)"></a>第六题：JZ25 合并两个排序的链表(Easy)</h2><h3 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h3><p>输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead1==<span class="literal">nullptr</span>)&#123; <span class="comment">// 如果pHead1为空，直接返回pHead2</span></span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pHead2==<span class="literal">nullptr</span>)&#123; <span class="comment">// 如果pHead2为空，直接返回pHead1</span></span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>); <span class="comment">// 创建一个新的头节点res，并初始化为-1</span></span><br><span class="line">        ListNode* cur = res; <span class="comment">// 创建一个指针变量cur，指向res，用于遍历并构建合并后的链表</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pHead1 &amp;&amp; pHead2)&#123; <span class="comment">// 当pHead1和pHead2都不为空时，进行以下操作</span></span><br><span class="line">            <span class="keyword">if</span>(pHead1-&gt;val &lt; pHead2-&gt;val)&#123; <span class="comment">// 如果pHead1的值小于pHead2的值</span></span><br><span class="line">                cur-&gt;next = pHead1; <span class="comment">// 将pHead1插入到新链表中</span></span><br><span class="line">                pHead1 = pHead1-&gt;next; <span class="comment">// 更新pHead1指向下一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// 否则，pHead2的值小于等于pHead1的值</span></span><br><span class="line">                cur-&gt;next = pHead2; <span class="comment">// 将pHead2插入到新链表中</span></span><br><span class="line">                pHead2 = pHead2-&gt;next; <span class="comment">// 更新pHead2指向下一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next; <span class="comment">// 更新cur指向新链表的最后一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pHead1)&#123; <span class="comment">// 当循环结束时，至少有一个链表到达了末尾，将另一个链表的剩余部分直接连接到新链表的末尾</span></span><br><span class="line">            cur-&gt;next = pHead1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur-&gt;next = pHead2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res-&gt;next; <span class="comment">// 返回res的下一个节点，即合并后的链表的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路-amp-步骤-amp-复杂度-7"><a href="#思路-amp-步骤-amp-复杂度-7" class="headerlink" title="思路&amp;步骤&amp;复杂度"></a>思路&amp;步骤&amp;复杂度</h4><p>这段代码实现了合并两个有序链表的功能。结构体 <code>ListNode</code> 表示链表节点，包含一个整型值 <code>val</code> 和指向下一个节点的指针 <code>next</code>。</p><p>算法思路如下：</p><ol><li>首先判断 <code>pHead1</code> 和 <code>pHead2</code> 是否为空，如果其中一个为空，则直接返回另一个链表。</li><li>创建一个新的头节点 <code>res</code>，并创建一个指针变量 <code>cur</code> 指向 <code>res</code>，用于遍历并构建合并后的链表。</li><li>进入循环，当 <code>pHead1</code> 和 <code>pHead2</code> 都不为空时，进行以下操作：<ul><li>比较 <code>pHead1-&gt;val</code> 和 <code>pHead2-&gt;val</code> 的大小，如果 <code>pHead1-&gt;val</code> 小于 <code>pHead2-&gt;val</code>，则将 <code>pHead1</code> 插入到新链表中，并更新 <code>pHead1</code> 指向下一个节点。</li><li>否则，将 <code>pHead2</code> 插入到新链表中，并更新 <code>pHead2</code> 指向下一个节点。</li><li>更新 <code>cur</code> 指向新链表的最后一个节点。</li></ul></li><li>循环结束后，至少有一个链表到达了末尾，将另一个链表的剩余部分直接连接到新链表的末尾。</li><li>返回 <code>res</code> 的下一个节点，即合并后的链表的头节点。</li></ol><p>算法的时间复杂度为 <code>O(m+n)</code>，其中 <code>m</code> 和 <code>n</code> 分别是两个链表的长度。算法需要同时遍历两个链表，每次循环插入一个节点，并更新指针，所以时间复杂度与两个链表的长度之和成正比。</p><p>算法的空间复杂度为 <code>O(1)</code>，只使用了常数个额外的指针变量来保存中间结果，没有使用额外的动态空间。</p><h2 id="第七题：JZ22-链表中倒数最后k个结点-Easy"><a href="#第七题：JZ22-链表中倒数最后k个结点-Easy" class="headerlink" title="第七题：JZ22 链表中倒数最后k个结点(Easy)"></a>第七题：JZ22 链表中倒数最后k个结点(Easy)</h2><h3 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h3><p>输入一个长度为 n 的链表，设链表中的元素的值为 ai ，返回该链表中倒数第k个节点。<br>如果该链表长度小于k，请返回一个长度为 0 的链表。</p><h3 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pHead, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="literal">nullptr</span> || k == <span class="number">0</span>) &#123; <span class="comment">// 如果链表为空或者k的值为0，则返回空指针</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode* fast = pHead; <span class="comment">// 创建指针fast，初始时指向链表头节点</span></span><br><span class="line">    ListNode* slow = pHead; <span class="comment">// 创建指针slow，初始时指向链表头节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123; <span class="comment">// 将fast指针向后移动k个位置</span></span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果链表长度小于k，则返回空指针</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fast = fast-&gt;next; <span class="comment">// 否则，将fast指针向后移动一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (fast) &#123; <span class="comment">// 同时移动fast和slow指针，直到fast到达链表末尾</span></span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> slow; <span class="comment">// 返回slow指针，即为链表倒数第k个节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-amp-步骤-amp-复杂度-8"><a href="#思路-amp-步骤-amp-复杂度-8" class="headerlink" title="思路&amp;步骤&amp;复杂度"></a>思路&amp;步骤&amp;复杂度</h4><p>这段代码实现了找到链表倒数第k个节点的功能。<br>输入参数为一个指向链表头节点的指针 <code>pHead</code> 和整数 <code>k</code>，返回值为链表中倒数第k个节点的指针。<br>如果链表为空或者k的值为0，则返回空指针。</p><p>算法思路如下：</p><ol><li>首先判断链表是否为空或者k的值为0，如果满足条件则直接返回空指针。</li><li>创建两个指针 <code>fast</code> 和 <code>slow</code>，初始时都指向链表头节点。</li><li>将 <code>fast</code> 指针向后移动k个位置。如果链表长度小于k，即 <code>fast</code> 到达链表末尾之前就为nullptr，则返回空指针。</li><li>然后同时移动 <code>fast</code> 和 <code>slow</code> 指针，直到 <code>fast</code> 到达链表末尾。此时，<code>slow</code> 指针指向的节点就是链表倒数第k个节点。</li><li>返回 <code>slow</code> 指针。</li></ol><p>算法的时间复杂度为 O(n)，其中 n 是链表的长度。在最坏情况下，需要遍历一次整个链表。</p><p>算法的空间复杂度为 O(1)，只使用了常数个额外的指针变量来保存中间结果，没有使用额外的动态空间。</p><h2 id="第八题：JZ76-删除链表中重复的结点-Middle"><a href="#第八题：JZ76-删除链表中重复的结点-Middle" class="headerlink" title="第八题：JZ76 删除链表中重复的结点(Middle)"></a>第八题：JZ76 删除链表中重复的结点(Middle)</h2><h3 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a>描述</h3><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。<br>例如，链表 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5  处理后为 1-&gt;2-&gt;5</p><h3 id="解决方案-6"><a href="#解决方案-6" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特判链表为空或只有一个节点的情况</span></span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="literal">nullptr</span>||pHead-&gt;next==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个虚拟头节点res，并将其指向pHead</span></span><br><span class="line">        ListNode*res=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        res-&gt;next=pHead;</span><br><span class="line">        <span class="comment">// 创建辅助指针cur，初始值为res</span></span><br><span class="line">        ListNode*cur=res;</span><br><span class="line">        <span class="comment">// 循环遍历链表，直到cur指向倒数第二个节点</span></span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next&amp;&amp;cur-&gt;next-&gt;next)&#123;</span><br><span class="line">            <span class="comment">// 若当前节点和下一节点的值相等（表示有重复元素）</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next-&gt;val==cur-&gt;next-&gt;next-&gt;val)&#123;</span><br><span class="line">                <span class="comment">// 先将重复的值保存到临时变量temp中</span></span><br><span class="line">                <span class="type">int</span> temp=cur-&gt;next-&gt;val;</span><br><span class="line">                <span class="comment">// 循环删除所有与temp相等的节点</span></span><br><span class="line">                <span class="keyword">while</span>(cur-&gt;next&amp;&amp;cur-&gt;next-&gt;val==temp)&#123;</span><br><span class="line">                    cur-&gt;next=cur-&gt;next-&gt;next; <span class="comment">// 接着跳过这些节点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 若当前节点和下一节点的值不相等</span></span><br><span class="line">                cur=cur-&gt;next; <span class="comment">// 直接继续遍历下一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res-&gt;next; <span class="comment">// 返回新链表的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路-amp-步骤-amp-复杂度-9"><a href="#思路-amp-步骤-amp-复杂度-9" class="headerlink" title="思路&amp;步骤&amp;复杂度"></a>思路&amp;步骤&amp;复杂度</h4><p>这段代码实现了删除排序链表中的重复元素。</p><p><strong>算法步骤：</strong></p><ol><li>如果链表为空或只有一个节点，则直接返回该链表。</li><li>创建一个新的头节点<code>res</code>，并将其指向原链表的头节点<code>pHead</code>。</li><li>创建一个辅助指针<code>cur</code>，初始化为<code>res</code>。</li><li>循环遍历链表，直到<code>cur</code>指向链表的倒数第二个节点。</li><li>若当前节点<code>cur-&gt;next</code>和下一个节点<code>cur-&gt;next-&gt;next</code>的值相等，则表示有重复元素。<ul><li>将重复的值保存在临时变量<code>temp</code>中。</li><li>循环删除所有与<code>temp</code>相等的节点，直到遇到不相等的节点或链表结束。</li><li>更新<code>cur</code>的<code>next</code>指针，跳过重复的节点。</li></ul></li><li>若当前节点<code>cur-&gt;next</code>和下一个节点<code>cur-&gt;next-&gt;next</code>的值不相等，则继续遍历下一个节点。</li><li>返回新链表的头节点。</li></ol><p>整体来说，该算法通过两层循环遍历链表，删除了所有重复元素，最终返回去重后的链表的头节点。</p><p><strong>时间复杂度：</strong></p><p>该算法采用了两层循环遍历链表，时间复杂度为<code>O(n)</code>，其中<code>n</code>是链表的长度。</p><p><strong>空间复杂度：</strong></p><p>该算法只创建了一个虚拟头节点和两个辅助指针，空间复杂度为<code>O(1)</code>（常数级别）。</p><h2 id="第九题：JZ18-删除链表的节点-Easy"><a href="#第九题：JZ18-删除链表的节点-Easy" class="headerlink" title="第九题：JZ18 删除链表的节点(Easy)"></a>第九题：JZ18 删除链表的节点(Easy)</h2><h3 id="描述-8"><a href="#描述-8" class="headerlink" title="描述"></a>描述</h3><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。</p><p>1.此题对比原题有改动<br>2.题目保证链表中节点的值互不相同<br>3.该题只会输出返回的链表和结果做对比，所以若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</p><h3 id="解决方案-7"><a href="#解决方案-7" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123; <span class="comment">// 检查链表是否为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 如果为空，则直接返回空指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>); <span class="comment">// 创建新的头节点res，并将其指向原始链表的头节点</span></span><br><span class="line">        res-&gt;next = head;</span><br><span class="line">        ListNode* cur = res; <span class="comment">// 创建指针cur，初始时指向新的头节点res</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) &#123; <span class="comment">// 使用循环遍历链表</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val == val) &#123; <span class="comment">// 检查当前节点的下一个节点的值是否等于指定值val</span></span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next; <span class="comment">// 如果相等，则将当前节点的下一个节点指向下下个节点，即删除指定节点</span></span><br><span class="line">                <span class="keyword">return</span> res-&gt;next; <span class="comment">// 返回新的头节点res的下一个节点，即为删除指定节点后的链表头节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next; <span class="comment">// 否则，将当前节点移向下一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res-&gt;next; <span class="comment">// 返回新的头节点res的下一个节点，即为删除指定节点后的链表头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路-amp-步骤-amp-复杂度-10"><a href="#思路-amp-步骤-amp-复杂度-10" class="headerlink" title="思路&amp;步骤&amp;复杂度"></a>思路&amp;步骤&amp;复杂度</h4><ol><li>首先检查链表是否为空。如果空，则直接返回空指针。</li><li>创建一个新的头节点 <code>res</code>，并将其指向原始链表的头节点。</li><li>创建一个指针 <code>cur</code>，它起初指向新的头节点 <code>res</code>。</li><li>使用循环遍历链表，直到当前节点的下一个节点为空。</li><li>在遍历过程中，检查当前节点的下一个节点的值是否等于指定值 <code>val</code>。如果相等，则将当前节点的下一个节点指向下下个节点，从而删除了指定节点。</li><li>如果当前节点的下一个节点的值不等于指定值 <code>val</code>，则将当前节点移向下一个节点。</li><li>循环结束后，返回新的头节点 <code>res</code> 的下一个节点，即为删除指定节点后的链表头节点。</li></ol><p>此算法的时间复杂度为 O(n)，其中 n 是链表的长度。在最坏情况下，需要遍历整个链表。</p><p>此算法的空间复杂度为 O(1)，只使用了常数个额外的指针变量来保存中间结果，没有使用额外的动态空间。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>剑指offer链表专题就到此完结啦，想给阅读至此的你，一个大大滴拇指👍</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《剃须。然后捡到女高中生》观后有感</title>
      <link href="/2022/10/20/Review%20of%20Shaving/"/>
      <url>/2022/10/20/Review%20of%20Shaving/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=2069668052&auto=1&height=66"></iframe><h2 id="剧情介绍"><a href="#剧情介绍" class="headerlink" title="剧情介绍"></a>剧情介绍</h2><p>《剃须。然后捡到女高中生》是一部令人深思的动画作品，以其复杂而又严肃的剧情展示了主人公沙优在困境中的成长与救赎的故事。这部作品通过探讨人性、友情和爱的力量，引发观众对社会议题如家庭问题、校园暴力和个人心理困境等的思考。</p><p>故事一开始，我们见识到了主人公沙优的不幸遭遇。她的父亲出轨导致家庭破裂，母亲为了挽回丈夫的爱，选择怀孕并生下了沙优。然而，这样做并没有改变事实，沙优的母亲仍然无法获得她所渴望的完整家庭和幸福。沙优从小就受到母亲的冷漠对待，她感到自己毫无存在感，缺乏面对生活的动力，甚至在学校里也没有朋友。</p><p>然而，一切都发生了改变。沙优遇到了一个真正的朋友，一个陪伴她度过黑暗时光的好闺蜜。然而，由于校园暴力的压力，好闺蜜最终选择了自杀。这个悲剧深深地打击了沙优，让她感到自责和痛苦。更加令人痛心的是，她的母亲对此事反应冷漠，甚至怀疑沙优可能是好闺蜜自杀的凶手。这个事件引发了沙优对母亲的愤怒和厌恶，她决定离开家寻找新的生活。</p><p>在这个过程中，沙优遇到了吉田，一个善良而坚定的人。吉田并没有对沙优有任何不良企图，他只是愿意帮助沙优重新审视自己的处境，并给她力量重新开始。通过吉田和他的同事们的帮助，沙优逐渐摆脱困境，重建了自己的生活。这个过程并非一帆风顺，沙优曾经走上错误道路，出卖自己的身体以谋取生活所需。然而，她最终通过吉田的引导和支持，找回了自尊和勇气，重新投身于正常的生活。</p><p><img src="http://sc1goen2r.hn-bkt.clouddn.com/boygirl.jpg"></p><h2 id="观后有感"><a href="#观后有感" class="headerlink" title="观后有感"></a>观后有感</h2><p>《剃须。然后捡到女高中生》这部动画作品深入探讨了社会中存在的一系列问题，并引发了观众对更深层次议题的思考。</p><p>首先，家庭破裂是这部作品中一个重要的主题。沙优来自一个破碎的家庭，她的母亲选择怀孕来填补家庭的空虚，却并未解决问题。这一情节引发了观众对家庭价值观、亲情关系和家庭责任的思考。作品中通过沙优与她的家人之间的交流和矛盾，展现了家庭关系对个体成长的重要性以及家庭矛盾背后隐藏的心理压力。</p><p>其次，校园暴力是另一个重要的议题。作品中描绘了沙优在学校中遭受的欺凌和暴力行为，她面临着身体和心理上的伤害。这激发了观众对校园暴力现象的反思，以及对学校和社会应如何处理这一问题的思考。同时，作品也通过描绘沙优与其他同学的互动，探索了友谊、团结和支持对于个体自我认同和生活质量的重要性。</p><p>此外，人际关系的脆弱性也是这部作品的一个重要主题。在故事中，沙优与一个真正的朋友建立了联系，然而这段关系却因意外而突然终结。这让观众对友谊的定义和友谊的稳固性产生思考，以及对于在现实世界中面临困境时如何建立和维护健康的人际关系的探索。</p><p>这些议题都提醒观众们去反思现实社会中存在的问题，并激发他们思考应对这些问题的方法。在故事中，吉田作为一个支持者和引导者的角色，教会了沙优如何勇敢地面对现实，并逐渐找到自己的力量。这也呼应了现实世界中的挑战，鼓励观众不畏困难，积极应对生活中的问题，寻求正确的解决方案。</p><p>除了以上的主题，这部作品还通过角色的内心独白、情感细节和表情动作等元素，深入探索了人性的复杂性和心理层面的挣扎。观众们可以从中思考人的内心世界、情绪管理和自我成长的重要性。此外，作品中的意象和隐喻也为观众提供了丰富的思考空间，让他们思索生命的意义、幸福的追求以及个体在社会中的角色。</p><p>总而言之，《剃须。然后捡到女高中生》通过深入探讨家庭、校园、人际关系等议题，引发观众对于现实社会的思考和反思。通过描绘一个受伤和孤立的年轻女孩，以及她在困境中寻求救赎和重生的旅程，展示主人公的成长和救赎，作品鼓励观众积极面对挑战、追求真理和成长，并思考个体与社会、内心与现实之间的关系。通过这些思考，观众可以更加深入地理解人性和社会，从而在现实生活中作出积极的改变和选择。</p><p>沙优的成长之路充满了挑战和痛苦，但最终她通过勇气和坚持走出了阴影。这种积极的主题激励着我们，让我们相信即使面临困境，也存在希望和改变的可能。</p><p><img src="http://sc1goen2r.hn-bkt.clouddn.com/cupgirl.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Thoughts after viewing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 观后感 </tag>
            
            <tag> 影评 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
