<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux Terminal Commands</title>
      <link href="/2023/09/08/Linux-Terminal-Commands/"/>
      <url>/2023/09/08/Linux-Terminal-Commands/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux终端命令，让你的工作更高效"><a href="#Linux终端命令，让你的工作更高效" class="headerlink" title="Linux终端命令，让你的工作更高效"></a>Linux终端命令，让你的工作更高效</h1><h2 id="目录导航"><a href="#目录导航" class="headerlink" title="目录导航"></a>目录导航</h2><ol><li><a href="#1-linux%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F">Linux终端命令格式</a></li><li><a href="#2-%E6%9F%A5%E9%98%85%E5%91%BD%E4%BB%A4%E5%B8%AE%E5%8A%A9%E4%BF%A1%E6%81%AF">查阅命令帮助信息</a></li><li><a href="#3-%E5%B8%B8%E7%94%A8linux%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%94%A8">常用Linux命令的基本实用</a></li><li><a href="#4-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">文件和目录常用命令</a></li><li><a href="#5-%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4">系统信息相关命令</a></li><li><a href="#6-%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4">用户权限相关命令</a></li><li><a href="#7-%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">远程管理常用命令</a></li><li><a href="#8-%E7%BB%93%E8%AF%AD">结语</a></li></ol><h2 id="1-Linux终端命令格式"><a href="#1-Linux终端命令格式" class="headerlink" title="1. Linux终端命令格式"></a>1. Linux终端命令格式</h2><p>在学习Linux终端命令之前，我们需要先了解它们的基本结构和格式。通常情况下，每个终端命令由命令名称、选项和参数组成。命令名称表示要执行的操作，选项用于修改命令的行为，参数指定操作的对象。</p><p>命令格式示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> -option argument</span><br></pre></td></tr></table></figure><h2 id="2-查阅命令帮助信息"><a href="#2-查阅命令帮助信息" class="headerlink" title="2. 查阅命令帮助信息"></a>2. 查阅命令帮助信息</h2><p>当我们遇到一个新的命令时，我们往往需要查阅其帮助文档来了解其功能和使用方法。Linux系统提供了多种方式来获取命令的帮助信息。</p><ul><li><code>command --help</code>：使用该选项可以查看命令的简要帮助信息。</li><li><code>man command</code>：使用该命令可以查看命令的详细帮助文档。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> --<span class="built_in">help</span></span><br><span class="line">man <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><h2 id="3-常用Linux命令的基本实用"><a href="#3-常用Linux命令的基本实用" class="headerlink" title="3. 常用Linux命令的基本实用"></a>3. 常用Linux命令的基本实用</h2><p>下面列举了一些常用的Linux命令，这些命令可以帮助你在终端中更高效地操作文件和目录、获取系统信息以及管理用户权限等。</p><h3 id="3-1-查看当前目录下的文件和文件夹"><a href="#3-1-查看当前目录下的文件和文件夹" class="headerlink" title="3.1 查看当前目录下的文件和文件夹"></a>3.1 查看当前目录下的文件和文件夹</h3><ul><li><code>ls</code>：列出当前目录下的文件和文件夹。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure><h3 id="3-2-切换目录"><a href="#3-2-切换目录" class="headerlink" title="3.2 切换目录"></a>3.2 切换目录</h3><ul><li><code>cd</code>：切换到指定目录。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/directory</span><br></pre></td></tr></table></figure><h3 id="3-3-查看文本文件内容"><a href="#3-3-查看文本文件内容" class="headerlink" title="3.3 查看文本文件内容"></a>3.3 查看文本文件内容</h3><ul><li><code>cat</code>：显示文本文件的内容。</li><li><code>less</code>：分页显示文本文件的内容。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> filename.txt</span><br><span class="line">less filename.txt</span><br></pre></td></tr></table></figure><h3 id="3-4-查找文件"><a href="#3-4-查找文件" class="headerlink" title="3.4 查找文件"></a>3.4 查找文件</h3><ul><li><code>find</code>：在指定路径下查找文件。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/search -name <span class="string">&quot;filename&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3-5-拷贝和移动文件"><a href="#3-5-拷贝和移动文件" class="headerlink" title="3.5 拷贝和移动文件"></a>3.5 拷贝和移动文件</h3><ul><li><code>cp</code>：拷贝文件或目录。</li><li><code>mv</code>：移动文件或目录。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /path/to/source /path/to/destination</span><br><span class="line"><span class="built_in">mv</span> /path/to/source /path/to/destination</span><br></pre></td></tr></table></figure><h3 id="3-6-创建和删除文件-目录"><a href="#3-6-创建和删除文件-目录" class="headerlink" title="3.6 创建和删除文件/目录"></a>3.6 创建和删除文件/目录</h3><ul><li><code>touch</code>：创建空文件。</li><li><code>mkdir</code>：创建目录。</li><li><code>rm</code>：删除文件或目录。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> filename.txt</span><br><span class="line"><span class="built_in">mkdir</span> directory</span><br><span class="line"><span class="built_in">rm</span> filename.txt</span><br></pre></td></tr></table></figure><h3 id="3-7-其他命令"><a href="#3-7-其他命令" class="headerlink" title="3.7 其他命令"></a>3.7 其他命令</h3><ul><li><code>pwd</code>：显示当前工作目录。</li><li><code>clear</code>：清除终端屏幕。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br><span class="line">clear</span><br></pre></td></tr></table></figure><h2 id="4-文件和目录常用命令"><a href="#4-文件和目录常用命令" class="headerlink" title="4. 文件和目录常用命令"></a>4. 文件和目录常用命令</h2><h3 id="4-1-ls-命令说明"><a href="#4-1-ls-命令说明" class="headerlink" title="4.1 ls 命令说明"></a>4.1 ls 命令说明</h3><p><code>ls</code>命令用于列出指定目录下的文件和子目录。</p><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /path/to/directory</span><br></pre></td></tr></table></figure><h3 id="4-2-Linux下文件和目录的特点"><a href="#4-2-Linux下文件和目录的特点" class="headerlink" title="4.2 Linux下文件和目录的特点"></a>4.2 Linux下文件和目录的特点</h3><p>在Linux系统中，所有文件和目录都具有以下特点：</p><ul><li>文件和目录都是以字符序列组成的。</li><li>所有内容都被保存在文件中。</li><li>所有文件都包含一个inode，它保存了与该文件相关的元数据。</li></ul><h3 id="4-3-ls-常用选项"><a href="#4-3-ls-常用选项" class="headerlink" title="4.3 ls 常用选项"></a>4.3 ls 常用选项</h3><ul><li><code>-l</code>：以长格式显示文件和目录的详细信息。</li><li><code>-a</code>：显示所有文件和目录，包括隐藏文件。</li><li><code>-h</code>：以人类可读的方式显示文件大小。</li><li><code>-r</code>：以相反的顺序显示文件和目录。</li><li><code>-t</code>：按修改时间排序文件和目录。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line"><span class="built_in">ls</span> -a</span><br><span class="line"><span class="built_in">ls</span> -lh</span><br></pre></td></tr></table></figure><h3 id="4-4-ls通配符的使用"><a href="#4-4-ls通配符的使用" class="headerlink" title="4.4 ls通配符的使用"></a>4.4 ls通配符的使用</h3><p>在ls命令中，可以使用通配符来匹配文件和目录的名称。</p><ul><li><code>*</code>：匹配任意字符序列。</li><li><code>?</code>：匹配单个字符。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> *.txt</span><br><span class="line"><span class="built_in">ls</span> file?.txt</span><br></pre></td></tr></table></figure><h3 id="4-5-相对路径和绝对路径"><a href="#4-5-相对路径和绝对路径" class="headerlink" title="4.5 相对路径和绝对路径"></a>4.5 相对路径和绝对路径</h3><p>在Linux系统中，可以使用相对路径和绝对路径来指定文件和目录的位置。</p><ul><li>相对路径：相对于当前工作目录的路径。</li><li>绝对路径：完整的路径，从根目录开始。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> directory</span><br><span class="line"><span class="built_in">ls</span>        <span class="comment"># 使用相对路径</span></span><br><span class="line"><span class="built_in">ls</span> /path  <span class="comment"># 使用绝对路径</span></span><br></pre></td></tr></table></figure><h2 id="5-系统信息相关命令"><a href="#5-系统信息相关命令" class="headerlink" title="5. 系统信息相关命令"></a>5. 系统信息相关命令</h2><h3 id="5-1-时间和日期"><a href="#5-1-时间和日期" class="headerlink" title="5.1 时间和日期"></a>5.1 时间和日期</h3><ul><li><code>date</code>：显示当前的日期和时间。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span></span><br></pre></td></tr></table></figure><h3 id="5-2-磁盘信息"><a href="#5-2-磁盘信息" class="headerlink" title="5.2 磁盘信息"></a>5.2 磁盘信息</h3><ul><li><code>df</code>：显示磁盘使用情况。</li><li><code>du</code>：显示指定目录或文件的磁盘使用情况。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br><span class="line"><span class="built_in">du</span> -sh directory</span><br></pre></td></tr></table></figure><h3 id="5-3-进程信息"><a href="#5-3-进程信息" class="headerlink" title="5.3 进程信息"></a>5.3 进程信息</h3><ul><li><code>ps</code>：查看运行中的进程。</li><li><code>top</code>：动态显示系统的资源占用情况和进程状态。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br><span class="line">top</span><br></pre></td></tr></table></figure><h2 id="6-用户权限相关命令"><a href="#6-用户权限相关命令" class="headerlink" title="6. 用户权限相关命令"></a>6. 用户权限相关命令</h2><h3 id="6-1-组管理"><a href="#6-1-组管理" class="headerlink" title="6.1 组管理"></a>6.1 组管理</h3><ul><li><code>groupadd</code>：创建新的用户组。</li><li><code>groupdel</code>：删除用户组。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd groupname</span><br><span class="line">groupdel groupname</span><br></pre></td></tr></table></figure><h3 id="6-2-用户管理"><a href="#6-2-用户管理" class="headerlink" title="6.2 用户管理"></a>6.2 用户管理</h3><ul><li><code>useradd</code>：创建新用户。</li><li><code>userdel</code>：删除用户。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd username</span><br><span class="line">userdel username</span><br></pre></td></tr></table></figure><h3 id="6-3-创建用户-设置密码-删除用户"><a href="#6-3-创建用户-设置密码-删除用户" class="headerlink" title="6.3 创建用户/设置密码/删除用户"></a>6.3 创建用户/设置密码/删除用户</h3><ul><li><code>adduser</code>：创建新用户。</li><li><code>passwd</code>：设置用户密码。</li><li><code>deluser</code>：删除用户。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adduser username</span><br><span class="line">passwd username</span><br><span class="line">deluser username</span><br></pre></td></tr></table></figure><h3 id="6-4-查看用户信息"><a href="#6-4-查看用户信息" class="headerlink" title="6.4 查看用户信息"></a>6.4 查看用户信息</h3><ul><li><code>id</code>：显示用户的UID和GID。</li><li><code>whoami</code>：显示当前登录用户的用户名。</li><li><code>finger</code>：显示用户信息。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span> username</span><br><span class="line"><span class="built_in">whoami</span></span><br><span class="line">finger username</span><br></pre></td></tr></table></figure><h3 id="6-5-which（重要）"><a href="#6-5-which（重要）" class="headerlink" title="6.5 which（重要）"></a>6.5 which（重要）</h3><ul><li><code>which</code>：查找给定命令的可执行文件的路径。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> <span class="built_in">command</span></span><br></pre></td></tr></table></figure><h3 id="6-6-切换用户"><a href="#6-6-切换用户" class="headerlink" title="6.6 切换用户"></a>6.6 切换用户</h3><ul><li><code>su</code>：切换到其他用户。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su username</span><br></pre></td></tr></table></figure><h3 id="6-7-修改文件权限"><a href="#6-7-修改文件权限" class="headerlink" title="6.7 修改文件权限"></a>6.7 修改文件权限</h3><ul><li><code>chmod</code>：修改文件或目录的权限。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> permissions filename</span><br></pre></td></tr></table></figure><h2 id="7-远程管理常用命令"><a href="#7-远程管理常用命令" class="headerlink" title="7. 远程管理常用命令"></a>7. 远程管理常用命令</h2><h3 id="7-1-关机-重启"><a href="#7-1-关机-重启" class="headerlink" title="7.1 关机/重启"></a>7.1 关机/重启</h3><ul><li><code>shutdown</code>：关机或重启系统。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h now   <span class="comment"># 立即关机</span></span><br><span class="line">shutdown -r now   <span class="comment"># 立即重启</span></span><br></pre></td></tr></table></figure><h3 id="7-2-查看配置网卡信息"><a href="#7-2-查看配置网卡信息" class="headerlink" title="7.2 查看配置网卡信息"></a>7.2 查看配置网卡信息</h3><ul><li><code>ifconfig</code>：显示网络接口的配置信息。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><h3 id="7-3-ping"><a href="#7-3-ping" class="headerlink" title="7.3 ping"></a>7.3 ping</h3><ul><li><code>ping</code>：测试网络连接。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping hostname</span><br></pre></td></tr></table></figure><h3 id="7-4-远程登录和赋值文件"><a href="#7-4-远程登录和赋值文件" class="headerlink" title="7.4 远程登录和赋值文件"></a>7.4 远程登录和赋值文件</h3><ul><li><code>ssh</code>：远程登录到另一台计算机。</li><li><code>scp</code>：将文件从本地复制到远程计算机或者从远程计算机复制到本地。</li></ul><p>示例使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh username@hostname</span><br><span class="line">scp localfile username@hostname:remotefile</span><br><span class="line">scp username@hostname:remotefile localfile</span><br></pre></td></tr></table></figure><h2 id="8-结语"><a href="#8-结语" class="headerlink" title="8. 结语"></a>8. 结语</h2><p>本篇博客介绍了一些常用的Linux终端命令，这些命令可以帮助你在终端中更高效地操作文件和目录、获取系统信息以及管理用户权限等。通过熟练掌握这些命令，你可以提高工作效率，更好地利用Linux系统的强大功能。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 终端命令 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stack and Queue</title>
      <link href="/2023/09/02/Stack-and-Queue/"/>
      <url>/2023/09/02/Stack-and-Queue/</url>
      
        <content type="html"><![CDATA[<h1 id="栈和队列：数据结构与应用"><a href="#栈和队列：数据结构与应用" class="headerlink" title="栈和队列：数据结构与应用"></a>栈和队列：数据结构与应用</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>栈（Stack）和队列（Queue）是计算机科学中常用的数据结构。它们在许多应用中发挥着重要作用。本篇博客将详细介绍栈和队列的概念、特性以及C++ STL中的实现。</p><h2 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h2><p>栈是一种遵循后进先出（Last-In-First-Out，LIFO）原则的数据结构。最后插入栈的元素，第一个被移除。栈可以用数组或链表等不同的数据结构来实现。</p><h3 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h3><p>在C++中，我们可以使用数组或链表来实现栈。以下是栈的基本操作：</p><ul><li><code>push(element)</code>：将元素压入栈顶</li><li><code>pop()</code>：弹出栈顶元素</li><li><code>top()</code>：访问栈顶元素</li><li><code>empty()</code>：判断栈是否为空</li><li><code>size()</code>：获取栈的大小</li></ul><h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><p>栈在编程中有着广泛的应用。以下是一些常见的栈的应用场景：</p><ul><li>表达式求值：栈可以用于中缀表达式转后缀表达式，然后再对后缀表达式进行求值。在这个过程中，运算符可以按照优先级依次入栈和出栈，从而实现表达式的计算。</li><li>括号匹配：栈可以用于检查表达式中的括号是否匹配。当遇到左括号时，将其入栈；当遇到右括号时，检查栈顶元素是否为相应的左括号，如果是则弹出栈顶元素，否则说明括号不匹配。</li><li>函数调用时的局部变量存储：函数调用时，局部变量通常存储在栈中。每当进入一个函数，函数的局部变量会被入栈；当函数执行完毕后，局部变量会被弹出栈。</li><li>浏览器的返回功能：浏览器的返回按钮通常使用栈来记录访问页面的历史。每当用户访问一个新页面时，当前页面的URL会被入栈；当用户点击返回按钮时，栈顶的URL会被弹出栈，然后浏览器跳转到该URL对应的页面。</li></ul><h3 id="栈的实现示例"><a href="#栈的实现示例" class="headerlink" title="栈的实现示例"></a>栈的实现示例</h3><p>下面是使用<code>链表</code>实现栈的代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义栈类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Stack</span>() : <span class="built_in">top</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 压入栈顶元素</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> element)</span> </span>&#123;</span><br><span class="line">    Node* newNode = <span class="keyword">new</span> Node;</span><br><span class="line">    newNode-&gt;data = element;</span><br><span class="line">    newNode-&gt;next = top;</span><br><span class="line">    top = newNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;栈已为空，无法执行弹出操作&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* temp = top;</span><br><span class="line">    top = top-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 访问栈顶元素</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;栈为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> top-&gt;data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断栈是否为空</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> top == <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取栈的大小</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Node* current = top;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      count++;</span><br><span class="line">      current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Node* top;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试栈的使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Stack myStack;</span><br><span class="line"></span><br><span class="line">  myStack.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">  myStack.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">  myStack.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;栈顶元素：&quot;</span> &lt;&lt; myStack.<span class="built_in">peek</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  myStack.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;栈是否为空：&quot;</span> &lt;&lt; (myStack.<span class="built_in">isEmpty</span>() ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;栈的大小：&quot;</span> &lt;&lt; myStack.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是使用<code>数组</code>实现栈的代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* stack; <span class="comment">// 存储栈元素的数组</span></span><br><span class="line">    <span class="type">int</span> capacity; <span class="comment">// 栈的容量</span></span><br><span class="line">    <span class="type">int</span> top; <span class="comment">// 栈顶指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，初始化栈</span></span><br><span class="line">    <span class="built_in">ArrayStack</span>(<span class="type">int</span> size) &#123;</span><br><span class="line">        capacity = size;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="type">int</span>[capacity];</span><br><span class="line">        top = <span class="number">-1</span>; <span class="comment">// 初始时栈为空，栈顶指针为-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top == capacity - <span class="number">1</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Stack Overflow!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack[++top] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈操作</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Stack is empty!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> stack[top--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取栈顶元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Stack is empty!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> stack[top];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取栈的大小</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ArrayStack <span class="title">stack</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    stack.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    stack.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    stack.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Stack size: &quot;</span> &lt;&lt; stack.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top element: &quot;</span> &lt;&lt; stack.<span class="built_in">peek</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; stack.<span class="built_in">pop</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码使用数组实现了栈。其中，<code>ArrayStack</code>类使用数组来存储栈元素，并提供了入栈、出栈、获取栈顶元素、判断栈是否为空以及获取栈的大小等基本操作。</p><p>在<code>main()</code>函数中，我们对栈进行了一些测试操作，包括入栈、出栈、获取栈顶元素以及判断栈是否为空等。</p><h2 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h2><p>队列是一种遵循先进先出（First-In-First-Out，FIFO）原则的数据结构。最先插入队列的元素，最先被移除。队列可以用数组或链表等不同的数据结构来实现。</p><h3 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h3><p>与栈类似，队列也有一些基本操作：</p><ul><li><code>push(element)</code>：将元素插入队列尾部</li><li><code>pop()</code>：移除队列头部元素</li><li><code>front()</code>：访问队列头部元素</li><li><code>back()</code>：访问队列尾部元素</li><li><code>empty()</code>：判断队列是否为空</li><li><code>size()</code>：获取队列的大小</li></ul><h3 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h3><p>队列在编程中也有着广泛的应用。以下是一些常见的队列的应用场景：</p><ul><li>等待队列：用于处理并发请求，按照请求顺序进行处理。</li><li>进程调度：操作系统使用队列来管理进程的执行顺序。</li><li>缓存队列：用于缓存数据，如网络数据包的传输（TCP/IP协议中的滑动窗口）。</li></ul><h3 id="队列的实现示例"><a href="#队列的实现示例" class="headerlink" title="队列的实现示例"></a>队列的实现示例</h3><p>下面是使用<code>链表</code>实现队列的代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义队列类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Queue</span>() : <span class="built_in">front</span>(<span class="literal">nullptr</span>), <span class="built_in">rear</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入元素到队列尾部</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> element)</span> </span>&#123;</span><br><span class="line">    Node* newNode = <span class="keyword">new</span> Node;</span><br><span class="line">    newNode-&gt;data = element;</span><br><span class="line">    newNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rear == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      front = rear = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      rear-&gt;next = newNode;</span><br><span class="line">      rear = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除队列头部元素</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;队列已为空，无法执行移除操作&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* temp = front;</span><br><span class="line">    front = front-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (front == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      rear = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 访问队列头部元素</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;队列为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> front-&gt;data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 访问队列尾部元素</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;队列为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rear-&gt;data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断队列是否为空</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> front == <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取队列的大小</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Node* current = front;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      count++;</span><br><span class="line">      current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Node* front;</span><br><span class="line">  Node* rear;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试队列的使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Queue myQueue;</span><br><span class="line"></span><br><span class="line">  myQueue.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">  myQueue.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">  myQueue.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;队列头部元素：&quot;</span> &lt;&lt; myQueue.<span class="built_in">peek</span>() &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;队列尾部元素：&quot;</span> &lt;&lt; myQueue.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  myQueue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;队列是否为空：&quot;</span> &lt;&lt; (myQueue.<span class="built_in">isEmpty</span>() ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;队列的大小：&quot;</span> &lt;&lt; myQueue.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是使用<code>数组</code>实现队列的代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* queue; <span class="comment">// 存储队列元素的数组</span></span><br><span class="line">    <span class="type">int</span> capacity; <span class="comment">// 队列的容量</span></span><br><span class="line">    <span class="type">int</span> front; <span class="comment">// 队头指针</span></span><br><span class="line">    <span class="type">int</span> rear; <span class="comment">// 队尾指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，初始化队列</span></span><br><span class="line">    <span class="built_in">ArrayQueue</span>(<span class="type">int</span> size) &#123;</span><br><span class="line">        capacity = size;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="type">int</span>[capacity];</span><br><span class="line">        front = <span class="number">-1</span>; <span class="comment">// 初始时队列为空，队头指针为-1</span></span><br><span class="line">        rear = <span class="number">-1</span>; <span class="comment">// 初始时队列为空，队尾指针为-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isFull</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Queue is full!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">                front = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rear++;</span><br><span class="line">            queue[rear] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队操作</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Queue is empty!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> value = queue[front];</span><br><span class="line">            front++;</span><br><span class="line">            <span class="keyword">if</span> (front &gt; rear) &#123;</span><br><span class="line">                front = <span class="number">-1</span>;</span><br><span class="line">                rear = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队头元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Queue is empty!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue[front];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front == <span class="number">-1</span> &amp;&amp; rear == <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队列是否已满</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == capacity - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列的大小</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rear - front + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ArrayQueue <span class="title">queue</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    queue.<span class="built_in">enqueue</span>(<span class="number">1</span>);</span><br><span class="line">    queue.<span class="built_in">enqueue</span>(<span class="number">2</span>);</span><br><span class="line">    queue.<span class="built_in">enqueue</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Queue size: &quot;</span> &lt;&lt; queue.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Front element: &quot;</span> &lt;&lt; queue.<span class="built_in">peek</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; queue.<span class="built_in">dequeue</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码使用数组实现了栈。<code>ArrayQueue</code>类使用数组来存储队列元素，并提供了入队、出队、获取队头元素、判断队列是否为空以及获取队列的大小等基本操作。</p><p>在<code>main()</code>函数中，我们对队列进行了一些测试操作，包括入队、出队、获取队头元素以及判断队列是否为空等。</p><h2 id="STL（Standard-Template-Library）中提供的stack（堆栈）和queue（队列）"><a href="#STL（Standard-Template-Library）中提供的stack（堆栈）和queue（队列）" class="headerlink" title="STL（Standard Template Library）中提供的stack（堆栈）和queue（队列）"></a>STL（Standard Template Library）中提供的stack（堆栈）和queue（队列）</h2><h3 id="stack（堆栈）："><a href="#stack（堆栈）：" class="headerlink" title="stack（堆栈）："></a>stack（堆栈）：</h3><ul><li>堆栈是一种后进先出（Last In First Out，LIFO）的数据结构，类似于现实生活中的一叠盘子。最后放入堆栈的元素首先被取出。</li><li>STL中的stack模板类定义在<stack>头文件中，可以存储任意类型的元素。</li><li>stack提供以下常用操作：<ul><li>push(value)：将元素value压入堆栈的顶部。</li><li>pop()：删除堆栈顶部的元素。</li><li>top()：返回堆栈顶部的元素，但不删除它。</li><li>empty()：检查堆栈是否为空。</li><li>size()：返回堆栈中的元素数量。</li></ul></li></ul><p>   示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; myStack; <span class="comment">// 创建一个int类型的堆栈</span></span><br><span class="line"></span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">1</span>); <span class="comment">// 入栈操作，将元素1压入堆栈</span></span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">2</span>); <span class="comment">// 入栈操作，将元素2压入堆栈</span></span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">3</span>); <span class="comment">// 入栈操作，将元素3压入堆栈</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Stack size: &quot;</span> &lt;&lt; myStack.<span class="built_in">size</span>() &lt;&lt; std::endl; <span class="comment">// 打印堆栈的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!myStack.<span class="built_in">empty</span>()) &#123; <span class="comment">// 当堆栈不为空时</span></span><br><span class="line">        std::cout &lt;&lt; myStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 获取并打印堆栈顶部的元素</span></span><br><span class="line">        myStack.<span class="built_in">pop</span>(); <span class="comment">// 删除堆栈顶部的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="queue（队列）："><a href="#queue（队列）：" class="headerlink" title="queue（队列）："></a>queue（队列）：</h3><ul><li>队列是一种先进先出（First In First Out，FIFO）的数据结构，类似于现实生活中的排队。最先放入队列的元素首先被取出。</li><li>STL中的queue模板类定义在<queue>头文件中，可以存储任意类型的元素。</li><li>queue提供以下常用操作：<ul><li>push(value)：将元素value添加到队列的尾部。</li><li>pop()：删除队列头部的元素。</li><li>front()：返回队列头部的元素，但不删除它。</li><li>back()：返回队列尾部的元素，但不删除它。</li><li>empty()：检查队列是否为空。</li><li>size()：返回队列中的元素数量。</li></ul></li></ul><p>   示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; myQueue; <span class="comment">// 创建一个int类型的队列</span></span><br><span class="line"></span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">1</span>); <span class="comment">// 入队操作，将元素1添加到队列尾部</span></span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">2</span>); <span class="comment">// 入队操作，将元素2添加到队列尾部</span></span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">3</span>); <span class="comment">// 入队操作，将元素3添加到队列尾部</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Queue size: &quot;</span> &lt;&lt; myQueue.<span class="built_in">size</span>() &lt;&lt; std::endl; <span class="comment">// 打印队列的大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Front element: &quot;</span> &lt;&lt; myQueue.<span class="built_in">front</span>() &lt;&lt; std::endl; <span class="comment">// 打印队列头部的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Back element: &quot;</span> &lt;&lt; myQueue.<span class="built_in">back</span>() &lt;&lt; std::endl; <span class="comment">// 打印队列尾部的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!myQueue.<span class="built_in">empty</span>()) &#123; <span class="comment">// 当队列不为空时</span></span><br><span class="line">        std::cout &lt;&lt; myQueue.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 获取并打印队列头部的元素</span></span><br><span class="line">        myQueue.<span class="built_in">pop</span>(); <span class="comment">// 删除队列头部的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="stack和queue的示例"><a href="#stack和queue的示例" class="headerlink" title="stack和queue的示例"></a>stack和queue的示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// stack的使用示例</span></span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈操作</span></span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">6</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈操作</span></span><br><span class="line">    <span class="type">int</span> topElement = s.<span class="built_in">top</span>();  <span class="comment">// 获取栈顶元素</span></span><br><span class="line">    s.<span class="built_in">pop</span>();  <span class="comment">// 弹出栈顶元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出栈顶元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top element of the stack: &quot;</span> &lt;&lt; topElement &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stack is empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stack is not empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// queue的使用示例</span></span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队操作</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队操作</span></span><br><span class="line">    <span class="type">int</span> frontElement = q.<span class="built_in">front</span>();  <span class="comment">// 获取队头元素</span></span><br><span class="line">    q.<span class="built_in">pop</span>();  <span class="comment">// 弹出队头元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出队头元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Front element of the queue: &quot;</span> &lt;&lt; frontElement &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队列是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Queue is empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Queue is not empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用示例："><a href="#应用示例：" class="headerlink" title="应用示例："></a>应用示例：</h3><ul><li>stack的应用：在实现逆波兰表达式求值、括号匹配和深度优先搜索（DFS）等算法中，通常会使用堆栈来辅助实现。</li><li>queue的应用：在实现广度优先搜索（BFS）和缓冲区管理等场景中，常常使用队列来解决问题。例如，在排队系统中，可以使用队列来处理顾客的请求。</li></ul><h4 id="使用栈实现括号匹配"><a href="#使用栈实现括号匹配" class="headerlink" title="使用栈实现括号匹配"></a>使用栈实现括号匹配</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isMatching</span><span class="params">(<span class="type">char</span> opening, <span class="type">char</span> closing)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (opening == <span class="string">&#x27;(&#x27;</span> &amp;&amp; closing == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (opening == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; closing == <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (opening == <span class="string">&#x27;[&#x27;</span> &amp;&amp; closing == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(std::string expression)</span> </span>&#123;</span><br><span class="line">  std::stack&lt;<span class="type">char</span>&gt; myStack;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">char</span> ch : expression) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span> || ch == <span class="string">&#x27;&#123;&#x27;</span> || ch == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">      myStack.<span class="built_in">push</span>(ch);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;)&#x27;</span> || ch == <span class="string">&#x27;&#125;&#x27;</span> || ch == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (myStack.<span class="built_in">empty</span>() || !<span class="built_in">isMatching</span>(myStack.<span class="built_in">top</span>(), ch)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        myStack.<span class="built_in">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> myStack.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string expression1 = <span class="string">&quot;&#123;([])&#125;&quot;</span>;</span><br><span class="line">  std::string expression2 = <span class="string">&quot;&#123;([)]&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isBalanced</span>(expression1)) &#123;</span><br><span class="line">    std::cout &lt;&lt; expression1 &lt;&lt; <span class="string">&quot; is balanced.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; expression1 &lt;&lt; <span class="string">&quot; is not balanced.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isBalanced</span>(expression2)) &#123;</span><br><span class="line">    std::cout &lt;&lt; expression2 &lt;&lt; <span class="string">&quot; is balanced.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; expression2 &lt;&lt; <span class="string">&quot; is not balanced.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码演示了如何使用栈来检查表达式中的括号是否匹配。首先，我们定义了一个辅助函数<code>isMatching()</code>，用于判断括号对是否匹配。然后，定义了一个<code>isBalanced()</code>函数，用于检查表达式是否括号平衡。</p><p>在<code>isBalanced()</code>函数中，我们使用一个栈<code>myStack</code>来存储遇到的左括号。遍历表达式中的每个字符，如果是左括号（’(‘、’{‘或’[‘），则将其入栈；如果是右括号，则判断栈顶的左括号和当前右括号是否匹配，如果匹配则将栈顶元素弹出，否则表达式不平衡。最后，如果遍历完整个表达式后，栈为空，则表达式平衡，否则不平衡。</p><p>在<code>main()</code>函数中，我们测试了两个表达式<code>&quot;&#123;([])&#125;&quot;</code>和<code>&quot;&#123;([)]&#125;&quot;</code>。输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;([])&#125; is balanced.</span><br><span class="line">&#123;([)]&#125; is not balanced.</span><br></pre></td></tr></table></figure><p>这段代码展示了如何使用栈来检查括号匹配，可以作为栈应用的一个实际场景示例。</p><h4 id="使用std-queue实现等待队列"><a href="#使用std-queue实现等待队列" class="headerlink" title="使用std::queue实现等待队列"></a>使用<code>std::queue</code>实现等待队列</h4><p>等待队列是一种常见的使用队列的场景，特别是在并发编程中。当多个任务或请求同时到达时，可以使用队列来按照请求顺序进行处理。以下是一个简单的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; requestQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求到达，加入等待队列</span></span><br><span class="line">    requestQueue.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    requestQueue.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    requestQueue.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理请求</span></span><br><span class="line">    <span class="keyword">while</span> (!requestQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> request = requestQueue.<span class="built_in">front</span>();  <span class="comment">// 获取队头请求</span></span><br><span class="line">        requestQueue.<span class="built_in">pop</span>();  <span class="comment">// 弹出队头请求</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理请求的逻辑</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Processing request: &quot;</span> &lt;&lt; request &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们使用了<code>std::queue</code>实现了一个等待队列。请求到达时，将其加入到队列的末尾，然后按照先进先出的原则处理请求。通过循环遍历队列，每次处理队头的请求，直到队列为空。</p><h4 id="使用std-queue实现就绪队列"><a href="#使用std-queue实现就绪队列" class="headerlink" title="使用std::queue实现就绪队列"></a>使用<code>std::queue</code>实现就绪队列</h4><p>操作系统中使用队列来管理进程的执行顺序，即进程调度。具体而言，在多道批处理系统中，操作系统维护一个就绪队列（ready queue），将可运行的进程按照某种调度算法添加到队列中，并依次调度执行。以下是一个简单的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Process</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    std::string name;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Process</span>(<span class="type">int</span> _id, std::string _name)</span><br><span class="line">        : <span class="built_in">id</span>(_id), <span class="built_in">name</span>(_name) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::queue&lt;Process&gt; readyQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建进程并加入就绪队列</span></span><br><span class="line">    <span class="function">Process <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;Process 1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Process <span class="title">p2</span><span class="params">(<span class="number">2</span>, <span class="string">&quot;Process 2&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Process <span class="title">p3</span><span class="params">(<span class="number">3</span>, <span class="string">&quot;Process 3&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    readyQueue.<span class="built_in">push</span>(p1);</span><br><span class="line">    readyQueue.<span class="built_in">push</span>(p2);</span><br><span class="line">    readyQueue.<span class="built_in">push</span>(p3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度执行进程</span></span><br><span class="line">    <span class="keyword">while</span> (!readyQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Process currentProcess = readyQueue.<span class="built_in">front</span>();  <span class="comment">// 获取队头进程</span></span><br><span class="line">        readyQueue.<span class="built_in">pop</span>();  <span class="comment">// 弹出队头进程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行进程的逻辑</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Executing process: &quot;</span> &lt;&lt; currentProcess.name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们使用了<code>std::queue</code>实现了一个就绪队列，存储待执行的进程。创建进程时，将其加入到队列的末尾。通过循环遍历队列，每次执行队头的进程，直到队列为空。</p><h4 id="使用std-queue实现缓存队列"><a href="#使用std-queue实现缓存队列" class="headerlink" title="使用std::queue实现缓存队列"></a>使用<code>std::queue</code>实现缓存队列</h4><p>队列还常用于实现缓存，例如网络数据包传输中的滑动窗口（TCP/IP协议）。滑动窗口是一种流量控制机制，使用队列来缓存数据包，以平衡发送端和接收端的速度差异。以下是一个简单的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; packetQueue;</span><br><span class="line">    <span class="type">int</span> windowSize = <span class="number">5</span>;  <span class="comment">// 窗口大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据包到达，加入缓存队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        packetQueue.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查缓存队列是否超过窗口大小</span></span><br><span class="line">        <span class="keyword">if</span> (packetQueue.<span class="built_in">size</span>() &gt; windowSize) &#123;</span><br><span class="line">            <span class="type">int</span> packet = packetQueue.<span class="built_in">front</span>();  <span class="comment">// 获取队头数据包</span></span><br><span class="line">            packetQueue.<span class="built_in">pop</span>();  <span class="comment">// 弹出队头数据包</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理数据包的逻辑</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Processing packet: &quot;</span> &lt;&lt; packet &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们使用了<code>std::queue</code>实现了一个缓存队列，用于存储网络数据包。数据包到达时，将其加入到队列的末尾，并检查队列的长度是否超过滑动窗口的大小。若超过，则取出队头的数据包进行处理，再继续接收新的数据包。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细介绍了栈和队列的概念、基本操作、使用数组、链表分别实现了栈和队列以及使用C++ STL中的<code>std::stack</code>和<code>std::queue</code>实现栈和队列的一些应用场景等。栈和队列是常见的数据结构，具有广泛的应用范围。通过理解栈和队列的特性和使用方法，可以更好地解决实际问题。</p><p>本篇博客内容较长，你能阅读至此，很有毅力！期待下篇博客，有你一阅~</p>]]></content>
      
      
      <categories>
          
          <category> Data Structure Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
            <tag> C++ </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Explore Map Containers and Multimap Containers in STL</title>
      <link href="/2023/09/02/Explore-Map-Containers-and-Multimap-Containers-in-STL/"/>
      <url>/2023/09/02/Explore-Map-Containers-and-Multimap-Containers-in-STL/</url>
      
        <content type="html"><![CDATA[<h1 id="探索STL中的Map容器和Multimap容器：用于高效管理键值对的强大工具"><a href="#探索STL中的Map容器和Multimap容器：用于高效管理键值对的强大工具" class="headerlink" title="探索STL中的Map容器和Multimap容器：用于高效管理键值对的强大工具"></a>探索STL中的Map容器和Multimap容器：用于高效管理键值对的强大工具</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li><li><a href="#Map%E5%AE%B9%E5%99%A8">Map容器</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">基本介绍</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96Map%E5%AE%B9%E5%99%A8">创建和初始化Map容器</a></li><li><a href="#%E6%8F%92%E5%85%A5%E5%92%8C%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0">插入和访问元素</a></li><li><a href="#%E9%81%8D%E5%8E%86Map%E5%AE%B9%E5%99%A8">遍历Map容器</a></li><li><a href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C">其他常用操作</a></li></ul></li><li><a href="#Multimap%E5%AE%B9%E5%99%A8">Multimap容器</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">基本介绍</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96Multimap%E5%AE%B9%E5%99%A8">创建和初始化Multimap容器</a></li><li><a href="#%E6%8F%92%E5%85%A5%E5%92%8C%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0">插入和访问元素</a></li><li><a href="#%E9%81%8D%E5%8E%86Multimap%E5%AE%B9%E5%99%A8">遍历Multimap容器</a></li><li><a href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C">其他常用操作</a></li></ul></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>今天我将向大家分享关于STL中Map容器和Multimap容器的知识。Map容器和Multimap容器是C++标准模板库(STL)提供的两种关联容器，它们以键值对的形式存储数据，并提供高效的键值查找和插入操作。</p><p>本篇博客将详细介绍Map容器和Multimap容器的特性、用法和常用操作，并通过代码实践演示如何使用它们解决实际问题。让我们一起来探索这两种强大的工具吧！</p><h2 id="Map容器"><a href="#Map容器" class="headerlink" title="Map容器"></a>Map容器</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>Map容器是一种有序的关联容器，其中的每个元素都是一个键值对(pair)，其中键（key）和值（value）之间有一对一的映射关系。Map容器的特点包括：</p><ul><li>键唯一性：Map容器中的键是唯一的，不允许重复。</li><li>自动排序：Map容器根据键的大小自动进行排序，默认采用严格弱序（strict weak ordering）。</li><li>高效的查找和插入：Map容器基于红黑树实现，具有快速的查找和插入性能。</li></ul><h3 id="创建和初始化Map容器"><a href="#创建和初始化Map容器" class="headerlink" title="创建和初始化Map容器"></a>创建和初始化Map容器</h3><p>在使用Map容器之前，我们需要包含头文件<code>&lt;map&gt;</code>。接下来，我们可以通过以下方法创建和初始化Map容器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建空的Map容器</span></span><br><span class="line">std::map&lt;KeyType, ValueType&gt; myMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并初始化Map容器</span></span><br><span class="line">std::map&lt;KeyType, ValueType&gt; myMap = &#123;</span><br><span class="line">    &#123;key1, value1&#125;,</span><br><span class="line">    &#123;key2, value2&#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在创建和初始化Map容器时，我们需要指定键的类型(KeyType)和值的类型(ValueType)。通过大括号内的键值对列表，可以方便地初始化Map容器。</p><p>接下来，我们通过一个简单的例子演示如何创建和初始化Map容器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; myMap = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;apple&quot;</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;banana&quot;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;pear&quot;</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;orange&quot;</span>, <span class="number">5</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 输出Map中的所有元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = myMap.<span class="built_in">begin</span>(); it != myMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，我们创建了一个字符串到整数的Map容器<code>myMap</code>，并用大括号内的键值对列表初始化了它。接着，通过迭代器遍历<code>myMap</code>，输出了Map中所有元素的键和值。</p><h3 id="插入和访问元素"><a href="#插入和访问元素" class="headerlink" title="插入和访问元素"></a>插入和访问元素</h3><p>向Map容器中插入元素可以使用<code>insert()</code>函数或使用下标操作符<code>[]</code>。我们可以按照以下的方式进行操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入键值对</span></span><br><span class="line">myMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(key, value));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用下标操作符插入或修改元素</span></span><br><span class="line">myMap[key] = value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问元素</span></span><br><span class="line">ValueType val = myMap[key];</span><br></pre></td></tr></table></figure><p>需要注意的是，如果插入的键已经存在于Map容器中，<code>insert()</code>函数将不会改变Map容器，而使用下标操作符<code>[]</code>则会覆盖原有的值。</p><p>以下是一个示例代码，演示如何插入和访问Map容器中的元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; myMap;</span><br><span class="line">    <span class="comment">// 向Map中插入元素</span></span><br><span class="line">    myMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>));</span><br><span class="line">    myMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;banana&quot;</span>));</span><br><span class="line">    myMap[<span class="number">3</span>] = <span class="string">&quot;pear&quot;</span>;</span><br><span class="line">    myMap[<span class="number">4</span>] = <span class="string">&quot;orange&quot;</span>;</span><br><span class="line">    <span class="comment">// 访问Map中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The value associated with key 1 is &quot;</span> &lt;&lt; myMap[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt;::iterator it;</span><br><span class="line">    it = myMap.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The value associated with key 2 is &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，我们创建了一个整数到字符串的Map容器<code>myMap</code>，并向其中插入了四个元素。接着，通过下标操作符和<code>find()</code>函数访问了<code>myMap</code>中两个元素。需要注意的是，在使用<code>find()</code>函数查找一个键时，需要判断返回的迭代器是否等于<code>end()</code>，以避免访问不存在的元素。</p><h3 id="遍历Map容器"><a href="#遍历Map容器" class="headerlink" title="遍历Map容器"></a>遍历Map容器</h3><p>遍历Map容器可以使用迭代器实现，以下是一种常用的遍历方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = myMap.<span class="built_in">begin</span>(); it != myMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="comment">// 访问键值对</span></span><br><span class="line">    KeyType key = it-&gt;first;</span><br><span class="line">    ValueType value = it-&gt;second;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器<code>it</code>从Map容器的开始位置(<code>begin()</code>)移动到结束位置(<code>end()</code>)，通过<code>it-&gt;first</code>和<code>it-&gt;second</code>访问键和值。我们可以在循环中根据需要使用键值对进行操作。</p><p>下面是一个演示代码，展示如何使用迭代器遍历Map容器并输出所有键值对：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; myMap = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;apple&quot;</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;banana&quot;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;pear&quot;</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;orange&quot;</span>, <span class="number">5</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 遍历Map中的所有元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = myMap.<span class="built_in">begin</span>(); it != myMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，我们创建了一个字符串到整数的Map容器<code>myMap</code>，并用大括号内的键值对列表初始化了它。接着，通过迭代器遍历<code>myMap</code>，输出了Map中所有元素的键和值。</p><h3 id="其他常用操作"><a href="#其他常用操作" class="headerlink" title="其他常用操作"></a>其他常用操作</h3><p>Map容器还提供了许多其他常用的操作，包括：</p><ul><li><code>size()</code>：返回Map容器中键值对的数量。</li><li><code>find(key)</code>：返回指向具有给定键的元素的迭代器。如果键不存在，则返回<code>end()</code>。</li><li><code>erase(key)</code>：删除具有给定键的元素。</li><li><code>clear()</code>：清空Map容器，删除所有的元素。</li></ul><p>通过合理利用这些操作，我们可以更好地管理和操作Map容器中的键值对数据。</p><p>下面是一个演示代码，展示如何使用<code>size()</code>、<code>find()</code>、<code>erase()</code>和<code>clear()</code>等函数进行Map容器的管理和操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; myMap = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;apple&quot;</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;banana&quot;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;pear&quot;</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;orange&quot;</span>, <span class="number">5</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 输出Map大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The size of myMap is &quot;</span> &lt;&lt; myMap.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 删除指定键的元素</span></span><br><span class="line">    myMap.<span class="built_in">erase</span>(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">    <span class="comment">// 输出Map中指定键的值</span></span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt;::iterator it;</span><br><span class="line">    it = myMap.<span class="built_in">find</span>(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The value associated with key \&quot;pear\&quot; is &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空Map</span></span><br><span class="line">    myMap.<span class="built_in">clear</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The size of myMap after clear is &quot;</span> &lt;&lt; myMap.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，我们创建了一个字符串到整数的Map容器<code>myMap</code>，并用大括号内的键值对列表初始化了它。接着，使用<code>size()</code>函数输出了<code>myMap</code>的大小；使用<code>erase()</code>函数删除了键为”banana”的元素；使用<code>find()</code>函数查找了键为”pear”的元素，并输出了相应的值；最后，通过使用<code>clear()</code>函数清空了<code>myMap</code>。</p><h2 id="Multimap容器"><a href="#Multimap容器" class="headerlink" title="Multimap容器"></a>Multimap容器</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>Multimap容器是一种有序的关联容器，允许键重复，其中的每个元素也是一个键值对(pair)。Multimap容器的特点包括：</p><ul><li>键可以重复：Multimap容器中的键允许重复，可以插入多个相同键的元素。</li><li>自动排序：Multimap容器根据键的大小自动进行排序，默认采用严格弱序（strict weak ordering）。</li><li>高效的查找和插入：Multimap容器基于红黑树实现，具有快速的查找和插入性能。</li></ul><h3 id="创建和初始化Multimap容器"><a href="#创建和初始化Multimap容器" class="headerlink" title="创建和初始化Multimap容器"></a>创建和初始化Multimap容器</h3><p>创建和初始化Multimap容器与Map容器类似，我们同样需要包含头文件<code>&lt;map&gt;</code>，并可以通过以下方式创建和初始化Multimap容器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建空的Multimap容器</span></span><br><span class="line">std::multimap&lt;KeyType, ValueType&gt; myMultimap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并初始化Multimap容器</span></span><br><span class="line">std::multimap&lt;KeyType, ValueType&gt; myMultimap = &#123;</span><br><span class="line">    &#123;key1, value1&#125;,</span><br><span class="line">    &#123;key2, value2&#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在创建和初始化Multimap容器时，同样需要指定键的类型(KeyType)和值的类型(ValueType)。通过大括号内的键值对列表，可以方便地初始化Multimap容器。</p><h3 id="插入和访问元素-1"><a href="#插入和访问元素-1" class="headerlink" title="插入和访问元素"></a>插入和访问元素</h3><p>向Multimap容器中插入元素可以使用<code>insert()</code>函数，我们可以按照以下的方式进行操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入键值对</span></span><br><span class="line">myMultimap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(key, value));</span><br></pre></td></tr></table></figure><p>与Map容器不同，Multimap容器允许插入多个具有相同键的元素。</p><p>访问Multimap容器中的元素需要使用迭代器进行遍历，以下是一种常用的遍历方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = myMultimap.<span class="built_in">begin</span>(); it != myMultimap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="comment">// 访问键值对</span></span><br><span class="line">    KeyType key = it-&gt;first;</span><br><span class="line">    ValueType value = it-&gt;second;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过迭代器<code>it</code>从Multimap容器的开始位置(<code>begin()</code>)移动到结束位置(<code>end()</code>)，通过<code>it-&gt;first</code>和<code>it-&gt;second</code>访问键和值。我们可以在循环中根据需要使用键值对进行操作。</p><h3 id="遍历Multimap容器"><a href="#遍历Multimap容器" class="headerlink" title="遍历Multimap容器"></a>遍历Multimap容器</h3><p>遍历Multimap容器与遍历Map容器类似，可以使用迭代器实现，以下是一种常用的遍历方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = myMultimap.<span class="built_in">begin</span>(); it != myMultimap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="comment">// 访问键值对</span></span><br><span class="line">    KeyType key = it-&gt;first;</span><br><span class="line">    ValueType value = it-&gt;second;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过迭代器<code>it</code>从Multimap容器的开始位置(<code>begin()</code>)移动到结束位置(<code>end()</code>)，通过<code>it-&gt;first</code>和<code>it-&gt;second</code>访问键和值。我们可以在循环中根据需要使用键值对进行操作。</p><h3 id="其他常用操作-1"><a href="#其他常用操作-1" class="headerlink" title="其他常用操作"></a>其他常用操作</h3><p>Multimap容器也提供了许多其他常用的操作，包括：</p><ul><li><code>size()</code>：返回Multimap容器中键值对的数量。</li><li><code>count(key)</code>：返回具有给定键的元素的数量。</li><li><code>find(key)</code>：返回指向具有给定键的第一个元素的迭代器。如果键不存在，则返回<code>end()</code>。</li><li><code>equal_range(key)</code>：返回一个迭代器对，表示Multimap容器中具有给定键的元素的范围。</li><li><code>erase(key)</code>：删除具有给定键的所有元素。</li><li><code>clear()</code>：清空Multimap容器，删除所有的元素。</li></ul><p>通过合理利用这些操作，我们可以更好地管理和操作Multimap容器中的键值对数据。<br>当使用C++中的<code>multimap</code>容器时，可以使用以下代码演示这些常用操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::multimap&lt;<span class="type">int</span>, std::string&gt; multimap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    multimap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>));</span><br><span class="line">    multimap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;banana&quot;</span>));</span><br><span class="line">    multimap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;orange&quot;</span>));</span><br><span class="line">    multimap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="string">&quot;grape&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size() - 获取键值对的数量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size: &quot;</span> &lt;&lt; multimap.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// count(key) - 获取具有给定键的元素数量</span></span><br><span class="line">    <span class="type">int</span> key = <span class="number">2</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Count of &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; multimap.<span class="built_in">count</span>(key) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find(key) - 查找具有给定键的第一个元素的迭代器</span></span><br><span class="line">    <span class="keyword">auto</span> it = multimap.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">if</span> (it != multimap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element with key &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// equal_range(key) - 获取具有给定键的元素范围</span></span><br><span class="line">    <span class="keyword">auto</span> range = multimap.<span class="built_in">equal_range</span>(key);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elements with key &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = range.first; i != range.second; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; i-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// erase(key) - 删除具有给定键的所有元素</span></span><br><span class="line">    multimap.<span class="built_in">erase</span>(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear() - 清空Multimap容器</span></span><br><span class="line">    multimap.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (multimap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Multimap is empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码演示了<code>multimap</code>容器的常用操作，包括<code>size()</code>、<code>count(key)</code>、<code>find(key)</code>、<code>equal_range(key)</code>、<code>erase(key)</code>和<code>clear()</code>。你可以根据需要修改键和值的类型，并根据具体情况进行插入和查找。<br>以下是该代码的输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Size: 4</span><br><span class="line">Count of 2: 2</span><br><span class="line">Element with key 2: banana</span><br><span class="line">Elements with key 2:</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">Multimap is empty</span><br></pre></td></tr></table></figure><p>代码中插入了4个键值对，然后进行了一系列操作。首先，<code>size()</code>函数返回了容器中键值对的数量，即4。接下来，使用<code>count(key)</code>函数获取具有键2的元素数量，结果为2。然后，使用<code>find(key)</code>函数查找具有键2的第一个元素，并输出其对应的值为”banana”。接着，使用<code>equal_range(key)</code>函数获取具有键2的元素范围，并循环输出范围内的所有值，即”banana”和”orange”。然后，使用<code>erase(key)</code>函数删除具有键2的所有元素。最后，使用<code>clear()</code>函数清空了整个<code>multimap</code>容器，并通过<code>empty()</code>函数验证容器是否为空，输出”Multimap is empty”。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本篇博客中，我们探索了STL中Map容器和Multimap容器的基本特性、创建和初始化方式以及常用的操作方法。Map容器以及Multimap容器作为一种强大的工具，在处理键值对数据时提供了高效的查找和插入功能。</p><p>通过深入理解Map容器和Multimap容器的特性和用法，我们可以更好地利用它们来解决实际问题。</p><p>希望本篇博客对读者了解和使用STL中的Map容器和Multimap容器有所帮助。期待下篇博客，依旧能与你相见~</p>]]></content>
      
      
      <categories>
          
          <category> Data Structure Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
            <tag> C++ </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Detailed explanation of set container</title>
      <link href="/2023/09/01/Detailed-explanation-of-set-container/"/>
      <url>/2023/09/01/Detailed-explanation-of-set-container/</url>
      
        <content type="html"><![CDATA[<p>当你需要使用一个数据结构来存储一组唯一元素，并且对元素具有高效的插入、删除和查找操作时，C++标准库中的<code>std::set</code>容器就是一个理想的选择。<code>std::set</code>容器以平衡二叉搜索树（通常是红黑树）的形式实现，因此能够保持元素的有序性。</p><p>Set（集合）是C++ STL中的一个容器，它提供了存储一组唯一值的功能。在set中，每个元素都是唯一的，并按照一定的顺序进行排序。特点如下：</p><ul><li>set中的元素是唯一的，不存在重复值。</li><li>set中的元素会按照一定的顺序进行排序，默认是升序。</li><li>set中不支持修改元素的操作，只能插入和删除元素。</li><li>set内部使用红黑树（red-black tree）数据结构来实现，因此插入、删除、查找等操作的时间复杂度为O(logN)。</li></ul><p>需要注意的是，如果希望自定义元素的排序规则，可以使用自定义比较函数或自定义类型来实现。此外，还可以使用multiset容器来存储允许重复值的集合。</p><p>本篇博客将详细介绍<code>std::set</code>容器的用法，包括定义、插入元素、删除元素、判断容器是否为空、获取容器大小、查找元素以及遍历容器等操作。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#%E5%A3%B0%E6%98%8Eset%E5%AE%B9%E5%99%A8">声明set容器</a></li><li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96set%E5%AE%B9%E5%99%A8">初始化set容器</a></li><li><a href="#%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0">插入元素</a></li><li><a href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0">删除元素</a></li><li><a href="#%E5%88%A4%E6%96%AD%E5%AE%B9%E5%99%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA">判断容器是否为空</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E5%AE%B9%E5%99%A8%E5%A4%A7%E5%B0%8F">获取容器大小</a></li><li><a href="#%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0">查找元素</a></li><li><a href="#%E9%81%8D%E5%8E%86set%E5%AE%B9%E5%99%A8">遍历set容器</a></li><li><a href="#%E8%AF%A6%E7%BB%86%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E5%92%8C%E8%AE%B2%E8%A7%A3">详细代码示例和讲解</a></li><li><a href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C">其他常用操作</a></li><li><a href="#set%E5%AE%B9%E5%99%A8%E9%97%B4%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C">set容器间集合操作</a></li></ol><h3 id="声明set容器"><a href="#声明set容器" class="headerlink" title="声明set容器"></a>声明set容器</h3><p>在使用set容器之前，需要包含头文件<code>&lt;set&gt;</code>。然后可以使用如下方式声明一个set容器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;类型&gt; 容器名称;</span><br></pre></td></tr></table></figure><p>其中，<code>类型</code>是指set容器中元素的类型，<code>容器名称</code>是给set容器指定的名字。例如，我们可以声明一个存储整数的set容器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line">std::set&lt;<span class="type">int</span>&gt; mySet;</span><br></pre></td></tr></table></figure><h3 id="初始化set容器"><a href="#初始化set容器" class="headerlink" title="初始化set容器"></a>初始化set容器</h3><p>set容器可以通过多种方式进行初始化，常用的包括：</p><ul><li><p>默认初始化：创建一个空的set容器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;<span class="type">int</span>&gt; mySet;  <span class="comment">// 创建一个空的整数set容器</span></span><br></pre></td></tr></table></figure></li><li><p>使用初始化列表初始化：在声明set容器时使用花括号{}，将初始元素放入列表中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;<span class="type">int</span>&gt; mySet = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  <span class="comment">// 初始化一个包含元素1、2、3的整数set容器</span></span><br></pre></td></tr></table></figure></li><li><p>使用迭代器初始化：使用另一个Set容器（或者是其他容器）的起始和结束迭代器，来初始化新的set容器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;<span class="type">int</span>&gt; anotherSet = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="function">std::set&lt;<span class="type">int</span>&gt; <span class="title">mySet</span><span class="params">(anotherSet.begin(), anotherSet.end())</span></span>;  <span class="comment">// 使用迭代器初始化新的set容器</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>向<code>std::set</code>容器插入元素可以使用<code>insert</code>函数。插入操作会自动保持容器中的元素有序。</p><p>下面是一个插入元素的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mySet.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">mySet.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">mySet.<span class="built_in">insert</span>(<span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>上述代码将分别向<code>mySet</code>容器插入了3个整数：5、2和8。</p><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>从<code>std::set</code>容器中删除元素可以使用<code>erase</code>函数。你可以指定要删除的元素值，也可以通过迭代器删除指定位置的元素。</p><p>下面是一个删除元素的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mySet.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>上述代码将从<code>mySet</code>容器中删除值为2的元素。</p><h3 id="判断容器是否为空"><a href="#判断容器是否为空" class="headerlink" title="判断容器是否为空"></a>判断容器是否为空</h3><p>可以使用<code>empty</code>函数来判断<code>std::set</code>容器是否为空。</p><p>下面是一个判断容器是否为空的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mySet.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// 容器为空</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 容器不为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取容器大小"><a href="#获取容器大小" class="headerlink" title="获取容器大小"></a>获取容器大小</h3><p>使用<code>size</code>函数可以获取<code>std::set</code>容器中的元素数量。</p><p>下面是一个获取容器大小的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size = mySet.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure><p>上述代码将获取<code>mySet</code>容器中的元素数量，并将其赋值给变量<code>size</code>。</p><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>使用<code>find</code>函数可以在<code>std::set</code>容器中查找指定的元素。如果找到了匹配的元素，则返回指向该元素的迭代器；如果未找到，则返回容器的<code>end</code>迭代器。</p><p>下面是一个查找元素的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = mySet.<span class="built_in">find</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// 找到了元素</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 未找到元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码将在<code>mySet</code>容器中查找值为5的元素。如果找到了元素，<code>it</code>将指向该元素，否则<code>it</code>将等于容器的<code>end</code>迭代器。</p><h3 id="遍历set容器"><a href="#遍历set容器" class="headerlink" title="遍历set容器"></a>遍历set容器</h3><p>可以使用range-based for循环来遍历<code>std::set</code>容器中的元素。</p><p>下面是一个遍历容器的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : mySet) &#123;</span><br><span class="line">    <span class="comment">// 使用element进行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码将遍历<code>mySet</code>容器中的所有元素，并通过变量<code>element</code>访问每个元素。</p><h3 id="详细代码示例和讲解"><a href="#详细代码示例和讲解" class="headerlink" title="详细代码示例和讲解"></a>详细代码示例和讲解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义set容器</span></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    mySet.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断容器是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (mySet.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Set容器为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Set容器不为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取容器大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Set容器大小为：&quot;</span> &lt;&lt; mySet.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="type">int</span> searchElement = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">auto</span> it = mySet.<span class="built_in">find</span>(searchElement);</span><br><span class="line">    <span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素 &quot;</span> &lt;&lt; searchElement &lt;&lt; <span class="string">&quot; 存在于Set容器中&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素 &quot;</span> &lt;&lt; searchElement &lt;&lt; <span class="string">&quot; 不存在于Set容器中&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历set容器</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Set容器的元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : mySet) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set容器不为空</span><br><span class="line">Set容器大小为：2</span><br><span class="line">元素 5 存在于Set容器中</span><br><span class="line">Set容器的元素：5 8</span><br></pre></td></tr></table></figure><p>在上述代码示例中，我首先使用<code>std::set&lt;int&gt;</code>来定义一个名为<code>mySet</code>的set容器。然后，使用<code>insert</code>函数向set容器中插入元素。接下来，使用<code>erase</code>函数从容器中删除指定元素。使用<code>empty</code>函数判断set容器是否为空，并输出相应信息。使用<code>size</code>函数获取容器的大小，并打印输出。使用<code>find</code>函数查找指定元素，若找到则输出相应信息。最后，使用range-based for循环遍历set容器的元素，并打印输出。</p><h3 id="其他常用操作"><a href="#其他常用操作" class="headerlink" title="其他常用操作"></a>其他常用操作</h3><p>1.当使用<code>count(x)</code>函数时，它会返回Set容器中值为x的元素个数。如果该值存在，则返回1；如果不存在，则返回0。下面是一个使用<code>count(x)</code>函数的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = mySet.<span class="built_in">count</span>(<span class="number">30</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;值为30的元素个数为：&quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    count = mySet.<span class="built_in">count</span>(<span class="number">60</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;值为60的元素个数为：&quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">值为30的元素个数为：1</span><br><span class="line">值为60的元素个数为：0</span><br></pre></td></tr></table></figure><p>2.当使用<code>lower_bound(x)</code>函数时，它会返回一个指向大于或等于x的最小元素的迭代器。如果找不到这样的元素，则返回Set容器的end()迭代器。下面是一个使用<code>lower_bound(x)</code>函数的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = mySet.<span class="built_in">lower_bound</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;大于或等于30的最小元素为：&quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;没有找到大于或等于30的元素&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    it = mySet.<span class="built_in">lower_bound</span>(<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;大于或等于60的最小元素为：&quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;没有找到大于或等于60的元素&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">大于或等于30的最小元素为：30</span><br><span class="line">没有找到大于或等于60的元素</span><br></pre></td></tr></table></figure><p>3.当使用<code>upper_bound(x)</code>函数时，它会返回一个指向大于x的最小元素的迭代器。如果找不到这样的元素，则返回Set容器的end()迭代器。下面是一个使用<code>upper_bound(x)</code>函数的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = mySet.<span class="built_in">upper_bound</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;大于30的最小元素为：&quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;没有找到大于30的元素&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    it = mySet.<span class="built_in">upper_bound</span>(<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;大于60的最小元素为：&quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;没有找到大于60的元素&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">大于30的最小元素为：40</span><br><span class="line">没有找到大于60的元素</span><br></pre></td></tr></table></figure><p>4.当使用<code>equal_range(x)</code>函数时，它会返回一个pair对象，包含<code>lower_bound()</code>和<code>upper_bound()</code>的迭代器范围。<code>equal_range(x)</code>函数返回的pair对象中，first成员是<code>lower_bound(x)</code>函数返回的迭代器，second成员是<code>upper_bound(x)</code>函数返回的迭代器。下面是一个使用<code>equal_range(x)</code>函数的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> range = mySet.<span class="built_in">equal_range</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">if</span> (range.first != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;大于或等于30的最小元素为：&quot;</span> &lt;&lt; *(range.first) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;没有找到大于或等于30的元素&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (range.second != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;大于30的最小元素为：&quot;</span> &lt;&lt; *(range.second) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;没有找到大于30的元素&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    range = mySet.<span class="built_in">equal_range</span>(<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">if</span> (range.first != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;大于或等于60的最小元素为：&quot;</span> &lt;&lt; *(range.first) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;没有找到大于或等于60的元素&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (range.second != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;大于60的最小元素为：&quot;</span> &lt;&lt; *(range.second) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;没有找到大于60的元素&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">大于或等于30的最小元素为：30</span><br><span class="line">大于30的最小元素为：40</span><br><span class="line">没有找到大于或等于60的元素</span><br><span class="line">没有找到大于60的元素</span><br></pre></td></tr></table></figure><h3 id="set容器间集合操作"><a href="#set容器间集合操作" class="headerlink" title="set容器间集合操作"></a>set容器间集合操作</h3><p>当需要对两个set容器进行集合操作时，可以使用<code>set_intersection</code>、<code>set_difference</code>、<code>set_union</code>和<code>set_symmetric_difference</code>等函数。下面我将为你提供详细的代码示例。</p><h4 id="集合交集（set-intersection）"><a href="#集合交集（set-intersection）" class="headerlink" title="集合交集（set_intersection）"></a>集合交集（set_intersection）</h4><p><code>set_intersection</code>函数用于获取两个set容器的交集，即同时存在于两个容器中的元素。交集的结果保存在另一个set容器中。下面是一个使用<code>set_intersection</code>函数的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; set2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    std::<span class="built_in">set_intersection</span>(set1.<span class="built_in">begin</span>(), set1.<span class="built_in">end</span>(), set2.<span class="built_in">begin</span>(), set2.<span class="built_in">end</span>(), std::<span class="built_in">inserter</span>(result, result.<span class="built_in">begin</span>()));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;交集结果：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : result) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交集结果：3 4 5 </span><br></pre></td></tr></table></figure><h4 id="集合差集（set-difference）"><a href="#集合差集（set-difference）" class="headerlink" title="集合差集（set_difference）"></a>集合差集（set_difference）</h4><p><code>set_difference</code>函数用于获取两个set容器的差集，即在第一个容器中存在但在第二个容器中不存在的元素。差集的结果保存在另一个set容器中。下面是一个使用<code>set_difference</code>函数的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; set2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    std::<span class="built_in">set_difference</span>(set1.<span class="built_in">begin</span>(), set1.<span class="built_in">end</span>(), set2.<span class="built_in">begin</span>(), set2.<span class="built_in">end</span>(), std::<span class="built_in">inserter</span>(result, result.<span class="built_in">begin</span>()));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;差集结果：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : result) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">差集结果：1 2 </span><br></pre></td></tr></table></figure><h4 id="集合并集（set-union）"><a href="#集合并集（set-union）" class="headerlink" title="集合并集（set_union）"></a>集合并集（set_union）</h4><p><code>set_union</code>函数用于获取两个set容器的并集，即包含两个容器中所有元素的集合。并集的结果保存在另一个set容器中。下面是一个使用<code>set_union</code>函数的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; set2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    std::<span class="built_in">set_union</span>(set1.<span class="built_in">begin</span>(), set1.<span class="built_in">end</span>(), set2.<span class="built_in">begin</span>(), set2.<span class="built_in">end</span>(), std::<span class="built_in">inserter</span>(result, result.<span class="built_in">begin</span>()));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;并集结果：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : result) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">并集结果：1 2 3 4 5 6 7 </span><br></pre></td></tr></table></figure><h4 id="集合对称差集（set-symmetric-difference）"><a href="#集合对称差集（set-symmetric-difference）" class="headerlink" title="集合对称差集（set_symmetric_difference）"></a>集合对称差集（set_symmetric_difference）</h4><p><code>set_symmetric_difference</code>函数用于获取两个set容器的对称差集，即在两个容器中出现的元素，但不是同时出现在两个容器中的元素。对称差集的结果保存在另一个set容器中。下面是一个使用<code>set_symmetric_difference</code>函数的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; set2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    std::<span class="built_in">set_symmetric_difference</span>(set1.<span class="built_in">begin</span>(), set1.<span class="built_in">end</span>(), set2.<span class="built_in">begin</span>(), set2.<span class="built_in">end</span>(), std::<span class="built_in">inserter</span>(result, result.<span class="built_in">begin</span>()));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;对称差集结果：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : result) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对称差集结果：1 2 6 7 </span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇博客详细介绍了C++标准库中的<code>std::set</code>容器的用法。我们学习了如何定义set容器、插入元素、删除元素、判断容器是否为空、获取容器大小、查找元素以及遍历容器等操作。使用<code>std::set</code>容器，你可以高效地管理一组唯一元素，并根据需要进行各种操作。</p><p>希望本文能够帮助你理解和使用<code>std::set</code>容器。</p>]]></content>
      
      
      <categories>
          
          <category> Data Structure Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
            <tag> C++ </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>月与夜：哲学之光与深夜思索</title>
      <link href="/2023/08/13/Six-MoonNight/"/>
      <url>/2023/08/13/Six-MoonNight/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=2059208608&auto=1&height=66"></iframe><h1 id="月与夜：哲学之光与深夜思索"><a href="#月与夜：哲学之光与深夜思索" class="headerlink" title="月与夜：哲学之光与深夜思索"></a>月与夜：哲学之光与深夜思索</h1><p>夜幕低垂，寂静的夜晚中，皎洁的明月轻轻升起，点亮了黑暗中的一片天空。在月光的映照下，大自然仿佛进入了一个诗意远方的世界。</p><h2 id="月与夜的对立与统一"><a href="#月与夜的对立与统一" class="headerlink" title="月与夜的对立与统一"></a>月与夜的对立与统一</h2><p>从哲学的角度来看，月与夜可以被视为对立与统一的象征。月代表着光明、清晰和理性，而夜则代表着黑暗、隐秘和感性。这种对立关系中，月和夜互为补充，共同构成了世界的完整性。</p><p>在柏拉图的哲学观点中，月可以被视为理念的世界，而夜则代表具体的现象世界。月的光芒照耀着夜的黑暗，给予夜以存在的意义，同时也通过夜的存在凸显了月的纯粹和高尚。月与夜的共存，展示了理念与现象、抽象与具体之间的辩证关系。</p><h2 id="月与夜的哲学阐释"><a href="#月与夜的哲学阐释" class="headerlink" title="月与夜的哲学阐释"></a>月与夜的哲学阐释</h2><p>在黑格尔的哲学中，月和夜可以被解读为对立的两个概念，构成了辩证法的矛盾。月代表着主动性、明确性和自我意识，而夜则代表着被动性、模糊性和无意识。月和夜的对立与斗争产生了新的合一，从而形成了更高级别的统一，这种统一被称为“合理性”。</p><p>在尼采的哲学中，月和夜可以被视为阿波罗与狄奥尼修斯的象征。月代表着理性、秩序和稳定，而夜则代表着感性、激情和混乱。阿波罗与狄奥尼修斯是对人类本性的不同表达，它们同时存在于人类心灵深处。月和夜的结合体现了人类内心的多元性和矛盾性，也呼应了尼采哲学中的生命力与艺术力的交融。</p><h2 id="人类与月夜的关联"><a href="#人类与月夜的关联" class="headerlink" title="人类与月夜的关联"></a>人类与月夜的关联</h2><p>长久以来，人类与月与夜有着紧密的关联。古人常以明月抒发思念之情，月夜也鼓舞着诗人们的灵感。当我们凝望着那清冷的月光，或许能感受到一种离乡背井的孤寂与温暖。夜晚则为人们提供了一个安静的思考和反思的时刻，让我们关注生活中最纯粹、最真实的感觉。<br><img src="http://s0ihpsfaf.hn-bkt.clouddn.com/yourname.jpg"></p><h2 id="未来的展望"><a href="#未来的展望" class="headerlink" title="未来的展望"></a>未来的展望</h2><p>月与夜所承载的深层意义将继续引领我们的思考。我们应超越二元对立，以开放的心态去理解和体验世界的复杂性与多样性。未来，我们可以通过更深入的哲学思考，探索宇宙的奥秘、探索人类存在的意义，并将这些思考融入到我们的生活和追求之中。</p><p>夜已深，明月还高悬，让我们在这宁静的时刻，与月夜相连，启迪内心的智慧之光。愿我们珍惜这份美好，用诗意的眼光去感受月与夜带给我们的深远思索和宁静。</p>]]></content>
      
      
      <categories>
          
          <category> ramblings </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 哲学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Explore sorting algorithms:from bubble to cardinality</title>
      <link href="/2023/08/11/Detailed-Explanation-of-Top-Ten-Sorting-Algorithms/"/>
      <url>/2023/08/11/Detailed-Explanation-of-Top-Ten-Sorting-Algorithms/</url>
      
        <content type="html"><![CDATA[<h1 id="十大排序算法详解"><a href="#十大排序算法详解" class="headerlink" title="十大排序算法详解"></a>十大排序算法详解</h1><p>在计算机科学中，排序算法是一种将一组元素按照特定顺序排列的算法。排序算法是解决各种排序问题的基础，它们的性能和适用场景各不相同。本文将介绍数据结构中的十大排序算法，以及它们的实现原理和C++代码示例。</p><h2 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1. 冒泡排序（Bubble Sort）"></a>1. 冒泡排序（Bubble Sort）</h2><p>冒泡排序是一种简单但效率较低的排序算法。它通过重复地遍历要排序的列表，在每次遍历过程中比较相邻的两个元素，并根据需要交换位置，直到整个列表排序完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n-i<span class="number">-1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2. 选择排序（Selection Sort）"></a>2. 选择排序（Selection Sort）</h2><p>选择排序每次从未排序的部分选择最小（或最大）的元素，并将其放到已排序部分的末尾。通过重复进行选择操作，最终可以得到一个有序列表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> min_idx = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min_idx]) &#123;</span><br><span class="line">                min_idx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[min_idx];</span><br><span class="line">        arr[min_idx] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3. 插入排序（Insertion Sort）"></a>3. 插入排序（Insertion Sort）</h2><p>插入排序的核心思想是将未排序的元素逐个插入到已排序部分的正确位置。通过不断地比较和移动元素，可以逐步构建有序列表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> key = arr[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-希尔排序（Shell-Sort）"><a href="#4-希尔排序（Shell-Sort）" class="headerlink" title="4. 希尔排序（Shell Sort）"></a>4. 希尔排序（Shell Sort）</h2><p>希尔排序是一种改进的插入排序算法，它通过将整个列表分割成多个较小的子列表进行插入排序，并逐渐缩小子列表的规模，最终完成排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> gap = n/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = arr[i];</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp; j -= gap) &#123;</span><br><span class="line">                arr[j] = arr[j - gap];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-快速排序（Quick-Sort）"><a href="#5-快速排序（Quick-Sort）" class="headerlink" title="5. 快速排序（Quick Sort）"></a>5. 快速排序（Quick Sort）</h2><p>快速排序是一种高效的分治排序算法。它通过选择一个基准元素，将列表划分为两个子列表，其中一个子列表的所有元素都小于等于基准元素，另一个子列表的所有元素都大于基准元素。然后，对两个子列表递归地应用快速排序，最终得到有序列表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[high];</span><br><span class="line">    <span class="type">int</span> i = (low - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = low; j &lt;= high - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="type">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> temp = arr[i + <span class="number">1</span>];</span><br><span class="line">    arr[i + <span class="number">1</span>] = arr[high];</span><br><span class="line">    arr[high] = temp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pi = <span class="built_in">partition</span>(arr, low, high);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">quickSort</span>(arr, low, pi - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(arr, pi + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-归并排序（Merge-Sort）"><a href="#6-归并排序（Merge-Sort）" class="headerlink" title="6. 归并排序（Merge Sort）"></a>6. 归并排序（Merge Sort）</h2><p>归并排序是一种高效的分治排序算法。它将列表递归地划分为较小的子列表，然后将这些子列表按照顺序合并，最终得到有序列表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合并两个子数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = mid - left + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n2 = right - mid;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建临时数组</span></span><br><span class="line">    <span class="type">int</span> L[n1], R[n2];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将数据复制到临时数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">        L[i] = arr[left + i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n2; j++)</span><br><span class="line">        R[j] = arr[mid + <span class="number">1</span> + j];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合并两个子数组</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> k = left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L[i] &lt;= R[j]) &#123;</span><br><span class="line">            arr[k] = L[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k] = R[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制剩余的元素（如果有）</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1) &#123;</span><br><span class="line">        arr[k] = L[i];</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2) &#123;</span><br><span class="line">        arr[k] = R[j];</span><br><span class="line">        j++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归排序左右子数组</span></span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, left, mid);</span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 合并已排序的子数组</span></span><br><span class="line">        <span class="built_in">merge</span>(arr, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-堆排序（Heap-Sort）"><a href="#7-堆排序（Heap-Sort）" class="headerlink" title="7. 堆排序（Heap Sort）"></a>7. 堆排序（Heap Sort）</h2><p>堆排序是一种基于二叉堆数据结构的排序算法。它首先将列表转换为最大堆或最小堆，然后依次将堆顶元素移除并放入已排序部分，直到整个列表排序完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调整子树以满足堆性质</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> largest = i;  <span class="comment">// 初始化最大值为根节点</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果左子节点比最大值大，更新最大值</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest])</span><br><span class="line">        largest = left;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果右子节点比最大值大，更新最大值</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest])</span><br><span class="line">        largest = right;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果最大值不是根节点，进行交换并继续调整子树</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[largest]);</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建最大堆（初始状态）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, i);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 依次将堆顶元素移动到已排序部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);  <span class="comment">// 将当前根节点（最大值）与最后一个叶子节点交换</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调整剩余的部分为最大堆</span></span><br><span class="line">        <span class="built_in">heapify</span>(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-计数排序（Counting-Sort）"><a href="#8-计数排序（Counting-Sort）" class="headerlink" title="8. 计数排序（Counting Sort）"></a>8. 计数排序（Counting Sort）</h2><p>计数排序是一种非比较排序算法，适用于已知数据范围的整数排序。它统计每个元素出现的次数，并根据统计信息对元素进行排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查找列表中的最大值</span></span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max)</span><br><span class="line">            max = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建计数数组并初始化为0</span></span><br><span class="line">    <span class="type">int</span>* count = <span class="keyword">new</span> <span class="type">int</span>[max + <span class="number">1</span>]();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 统计元素出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        count[arr[i]]++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据计数数组重新排序元素</span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= max; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (count[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            arr[index] = i;</span><br><span class="line">            index++;</span><br><span class="line">            count[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span>[] count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-桶排序（Bucket-Sort）"><a href="#9-桶排序（Bucket-Sort）" class="headerlink" title="9. 桶排序（Bucket Sort）"></a>9. 桶排序（Bucket Sort）</h2><p>桶排序是一种非比较排序算法，适用于已知数据范围的浮点数排序。它将列表划分为一定数量的桶，然后将元素分配到对应的桶中，每个桶再使用其他排序算法或递归地进行排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用插入排序对桶内元素排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(vector&lt;<span class="type">float</span>&gt;&amp; bucket)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = bucket.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">float</span> key = bucket[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; bucket[j] &gt; key) &#123;</span><br><span class="line">            bucket[j + <span class="number">1</span>] = bucket[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        bucket[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bucketSort</span><span class="params">(<span class="type">float</span> arr[], <span class="type">int</span> n, <span class="type">int</span> numBuckets)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">float</span>&gt;&gt; <span class="built_in">buckets</span>(numBuckets);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将元素分配到桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> bucketIndex = arr[i] * numBuckets;</span><br><span class="line">        buckets[bucketIndex].<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对每个桶内的元素进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numBuckets; i++)</span><br><span class="line">        <span class="built_in">insertionSort</span>(buckets[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将桶内的元素按顺序放入原始数组</span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numBuckets; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; buckets[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            arr[index] = buckets[i][j];</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-基数排序（Radix-Sort）"><a href="#10-基数排序（Radix-Sort）" class="headerlink" title="10. 基数排序（Radix Sort）"></a>10. 基数排序（Radix Sort）</h2><p>基数排序是一种非比较排序算法，适用于整数排序。它通过按照各个位数对元素进行排序，从最低有效位到最高有效位，最终得到有序列表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求解最大值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMax</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max)</span><br><span class="line">            max = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基数排序主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> max = <span class="built_in">getMax</span>(arr, n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对每个位数进行计数排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> exp = <span class="number">1</span>; max / exp &gt; <span class="number">0</span>; exp *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="type">int</span> output[n];  <span class="comment">// 存储排序后的结果</span></span><br><span class="line">        <span class="type">int</span> count[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 0-9的计数数组</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 统计当前位数上每个数字的出现次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            count[(arr[i] / exp) % <span class="number">10</span>]++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算累积次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 按照当前位数进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            output[count[(arr[i] / exp) % <span class="number">10</span>] - <span class="number">1</span>] = arr[i];</span><br><span class="line">            count[(arr[i] / exp) % <span class="number">10</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将排序后的结果复制回原始数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            arr[i] = output[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Here-is-a-table-analysis-of-the-sorting-algorithms-using-Markdown-syntax"><a href="#Here-is-a-table-analysis-of-the-sorting-algorithms-using-Markdown-syntax" class="headerlink" title="Here is a table analysis of the sorting algorithms using Markdown syntax:"></a>Here is a table analysis of the sorting algorithms using Markdown syntax:</h2><table><thead><tr><th>排序算法</th><th>时间复杂度</th><th>空间复杂度</th><th>适用场景</th></tr></thead><tbody><tr><td>冒泡排序</td><td>最好情况：O(n)<br>最坏情况：O(n^2)</td><td>O(1)</td><td>适用于小型数据集或基本有序的数据集，实现简单，但对于大规模数据效率较低</td></tr><tr><td>选择排序</td><td>O(n^2)</td><td>O(1)</td><td>适用于小型数据集，不占用额外空间，但对于大规模数据效率较低</td></tr><tr><td>插入排序</td><td>最好情况：O(n)<br>最坏情况：O(n^2)</td><td>O(1)</td><td>适用于小型数据集或基本有序的数据集，对于部分有序的数据效果较好</td></tr><tr><td>快速排序</td><td>平均情况：O(n*log(n))<br>最坏情况：O(n^2)</td><td>O(log(n))-O(n)</td><td>适用于大规模数据集，具有较高的平均性能，不需要额外空间</td></tr><tr><td>希尔排序</td><td>取决于增量序列的选择</td><td>O(1)</td><td>适用于中等大小的数据集，相较于简单排序算法，希尔排序在一定程度上提升了排序速度</td></tr><tr><td>归并排序</td><td>O(n*log(n))</td><td>O(n)</td><td>适用于大规模数据集，稳定且可靠，但占用较多的额外空间</td></tr><tr><td>堆排序</td><td>O(n*log(n))</td><td>O(1)</td><td>适用于大规模数据集，对于选择最大/最小元素具有高效性能，但不稳定</td></tr><tr><td>计数排序</td><td>O(n+k)（k为输入范围）</td><td>O(k)</td><td>适用于已知数据范围的整数排序，非常高效，但需要额外空间</td></tr><tr><td>桶排序</td><td>O(n+k)（k为桶的数量）</td><td>O(n+k)</td><td>适用于已知数据范围的浮点数排序，对于分布均匀的数据集效果较好</td></tr><tr><td>基数排序</td><td>O(d*(n+k))（d为最大元素位数，k为基数）</td><td>O(n+k)</td><td>适用于整数排序，特别是位数较小的整数，且数据集范围较小</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Data Structure Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构算法 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>风的旅程</title>
      <link href="/2023/08/11/xzp-fblog-ramblings/"/>
      <url>/2023/08/11/xzp-fblog-ramblings/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=427606780&auto=1&height=66"></iframe><h1 id="风的旅程"><a href="#风的旅程" class="headerlink" title="风的旅程"></a>风的旅程</h1><p>风来自很远的地方，轻柔地穿梭于时光的缝隙，<br>它带着远方的气息，漫游在无垠的天空中。</p><p>偶尔，风会停下脚步，近距离观察每一个细微的瞬间，<br>它轻抚花瓣，轻拂树叶，似乎在述说着流转的故事。</p><p>风没有栖息之处，却无所畏惧，<br>它以自由的姿态展翅飞翔，留下一串渐行渐远的足迹。</p><p><img src="http://s0ihpsfaf.hn-bkt.clouddn.com/%E4%BA%BA%E5%83%8F3.jpg"></p><p>或许，风是在寻找迷失的灵魂，寻觅心灵的归宿，<br>它吹散沉重的忧伤，吹拂人们内心的尘埃。</p><p>风知道，每一个刹那瞬间都是美的存在，<br>它用轻轻的呼吸，将这美好的瞬间铭记于心灵深处。</p><p>去去也无妨，风终将回到起点，<br>它将带着经历的智慧，告诉那些犹豫前行的旅人：</p><p>生活如同风的旅程，不妨放飞心灵，追寻内心的真实，<br>在短暂的人生中，将美好的瞬间谱写成永恒的诗篇。</p><p>让风带走忧愁，让心灵荡起勇敢的涟漪，<br>风来自很远的地方，去去也无妨，让生命在追寻中闪烁绽放。<br><img src="http://s0ihpsfaf.hn-bkt.clouddn.com/%E9%A3%8E%E6%99%AF1.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> ramblings </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读四大名著有感</title>
      <link href="/2023/08/10/xiao-third-blog-reading/"/>
      <url>/2023/08/10/xiao-third-blog-reading/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=2042350186&auto=1&height=66"></iframe><h2 id="《红楼梦》"><a href="#《红楼梦》" class="headerlink" title="《红楼梦》"></a><strong>《红楼梦》</strong></h2><p>《红楼梦》是中国四大名著之一，被誉为中国古典小说的巅峰之作。它以贾、史、王、薛四大家族的兴衰为背景，通过一系列丰富多彩的人物形象和情节，展现了封建社会的种种弊端和虚伪。这部小说以其独特的艺术魅力和深刻的社会批判性使其在现实中依然具有重要的意义。</p><h3 id="观后感："><a href="#观后感：" class="headerlink" title="观后感："></a><strong>观后感：</strong></h3><p>《红楼梦》描绘了一个宏大而精致的封建社会，不仅仅是一部家族的兴衰史，更是对封建社会道德观念的深刻剖析。小说中的人物形象栩栩如生，他们追求权力、享乐和财富，却忽略了真正的人情与真善美。贾宝玉、林黛玉、王熙凤等人物的形象给人留下深刻的印象，他们既是传统文化的典型代表，也具备着普遍的生命意义。</p><p>《红楼梦》通过对贾、史、王、薛四大家族的描写，展现了封建社会的虚伪和道德沦丧。尤其是通过贾府的描述，小说深刻地揭示了封建家族内部权力斗争和人性的复杂性。从贾政、贾母到贾宝玉，他们身陷权谋之中，忘记了最初的善良与纯真。这些形象使读者深思封建社会的道德沦丧和人性的扭曲。</p><h3 id="与现实的联系："><a href="#与现实的联系：" class="headerlink" title="与现实的联系："></a>与现实的联系：</h3><p>《红楼梦》中描写的虚伪、权谋、财富追逐等主题在现实社会同样存在。封建社会虽已过去，但人性的弱点和社会问题依然存在。现实中，我们也经常看到人们追求权力、财富而忽略了真正的人情与真善美。贪污腐败、权力斗争等问题仍然不断涌现，这些现象与小说中描述的封建社会的虚伪性有着异曲同工之妙。</p><p>同时，《红楼梦》中展现的女性形象和性别歧视问题也与现实息息相关。小说中的女性形象丰满而复杂，她们有着自己的思想和情感，但却受制于封建社会的束缚。这使人们反思在现实社会中女性地位的问题和性别歧视的存在。</p><p>总的来说，《红楼梦》以其细腻的描写、深刻的人物形象和对封建社会弊端的批判，在现实中依然具有深远的意义。小说通过对社会和个人的剖析，引发了读者对现实社会的思考和反思。它不仅是一部文学作品，更是一面镜子，让人们反思人性的弱点、社会的问题，进而寻求改变和进步的可能性。</p><h2 id="《西游记》"><a href="#《西游记》" class="headerlink" title="《西游记》"></a>《西游记》</h2><p>《西游记》是中国四大名著之一，被誉为中国古代小说中的经典之作。它讲述了孙悟空、猪八戒、沙僧和唐僧师徒四人西天取经的故事，在奇幻的背景下，呈现了各种人物形象和故事情节。这部小说以其幽默风趣、寓意深远的特点，深受广大读者的喜爱，并在现实中有着广泛的影响。</p><h3 id="观后感：-1"><a href="#观后感：-1" class="headerlink" title="观后感："></a><strong>观后感：</strong></h3><p>《西游记》以其独特的创意和神话色彩成为中国古代小说中的经典之作。小说通过一系列想象丰富、情节曲折的故事，呈现了各种神仙、妖怪和人类的形象。其中最引人注目的是孙悟空，他聪明机智、勇敢无畏，成为了中国文化中具有象征意义的英雄形象。通过这些幽默而深刻的描写，小说传递了对于人性的思考和对于正义与善的追求。</p><p>《西游记》中的每个故事情节都寓意深远，蕴含着对人性、善恶、道德等方面的品味。小说中的形象和故事超越了现实世界的限制，带有一种超然的艺术感和哲学思考。孙悟空的反叛、唐僧的慈悲、猪八戒的贪婪和沙僧的忍耐，都给人以启示，让人们反思自身的行为和价值观。</p><h3 id="与现实的联系：-1"><a href="#与现实的联系：-1" class="headerlink" title="与现实的联系："></a>与现实的联系：</h3><p>《西游记》中的故事情节和人物形象在现实中也有着深远的影响。故事中展现出的对于正义与善的追求、对于勇气和智慧的推崇，都是现实生活中值得借鉴的品质。孙悟空作为一个反抗者和保护者的形象，给人们勇气和力量去面对困难和挑战。</p><p>同时，《西游记》中的人物形象也反映了人性中的弱点和问题。孙悟空的傲慢、猪八戒的贪婪等都是现实社会中存在的弱点，这使得人们反思自身的行为和修炼。</p><p>总的来说，《西游记》以其丰富的想象力和深刻的寓意，在现实中依然具有重要的价值。小说展示了正义与善的力量，鼓舞了人们勇气和智慧的追求。通过对人性的深刻描写，小说让读者反思自身的行为和思考，去探索人性的本质和价值观的塑造。</p><h2 id="《水浒传》"><a href="#《水浒传》" class="headerlink" title="《水浒传》"></a><strong>《水浒传》</strong></h2><p>《水浒传》是中国四大名著之一，被誉为中国古代小说中的巅峰之作。它以宋江等梁山好汉的故事为主线，描绘了农民起义和反抗封建统治的斗争。这部小说具有浓厚的英雄史诗风格，通过对人物形象的塑造和故事情节的铺陈，展现了正义与邪恶、忠诚与背叛等复杂的道德困境。</p><h3 id="观后感：-2"><a href="#观后感：-2" class="headerlink" title="观后感："></a><strong>观后感：</strong></h3><p>《水浒传》通过对宋江等108位梁山好汉的故事的描述，展现了他们的成长经历、人性斗争和忠诚品质。小说中的人物形象生动鲜明，每个梁山好汉都有自己的性格特点和命运轨迹，使读者能够真切地感受到他们的喜怒哀乐。小说还揭示了封建社会不公和压迫的问题，并以梁山好汉的反抗精神和正义情怀呼唤着社会的改变。</p><p>《水浒传》以其宏大的史诗气势和丰富的情节成为中国古代小说中的经典之作。小说中的英雄形象和故事情节激发着读者的崇高情怀和正义意识，展现了人性中的复杂性。</p><h3 id="与现实的联系：-2"><a href="#与现实的联系：-2" class="headerlink" title="与现实的联系："></a>与现实的联系：</h3><p>《水浒传》中描绘的农民起义、反抗封建统治的主题在现实中具有深刻的联系。尽管故事背景发生在古代，但其中所蕴含的反抗不义、追求自由和正义的精神依然具有现实意义。现实社会中，仍然存在着各种不公平和不正义的现象，人们对于这些问题的反抗和呼唤正义的声音依然存在。</p><p>同时，《水浒传》中塑造的人物形象也与现实中的人性存在共鸣。小说中的人物有着各式各样的性格和命运，有英勇善战的好汉，亦有机智狡诈的奸人，他们的行为和选择反映了现实中人性的复杂性。这使人们不仅能够欣赏故事的精彩，也能够思考和反思自身的行为和选择。</p><p>总的来说，《水浒传》以其壮观的叙事风格和对人性、正义的思考，在现实中依然具有重要的价值。小说通过对英雄形象和故事情节的描绘，引发了读者对社会现象的深思和社会变革的渴望。尽管时代变迁，但《水浒传》中所展现的人性困境和反抗精神依然在现实中具有重要的意义。</p><h2 id="《三国演义》"><a href="#《三国演义》" class="headerlink" title="《三国演义》"></a><strong>《三国演义》</strong></h2><p>《三国演义》是中国四大名著之一，是一部以中国历史上三国时期为背景的长篇历史小说。它以刘备、关羽、张飞等著名人物的故事为主线，描绘了三国鼎立的历史画卷。这部小说不仅展示了英雄豪杰的形象和战争的激烈，也反映了权谋斗争和人性的复杂性。</p><h3 id="观后感：-3"><a href="#观后感：-3" class="headerlink" title="观后感："></a><strong>观后感：</strong></h3><p>《三国演义》是一部宏大的历史史诗，通过对那个战乱纷争的时代的描写，展现了各类人物的命运和选择。小说中的人物形象栩栩如生，刘备、关羽、张飞等英雄人物给人留下了深刻的印象。他们或忠诚无私，或机智谋略，或短视贪婪，都是那个时代和社会的缩影。</p><p>《三国演义》通过对权谋斗争、英雄事迹的描写，展示了人性的复杂性。小说中的人物有着各自的欲望、利益和信仰，他们在权力的角逐中展现出各种品质和行为。这使得读者对于权力与道德、忠诚与背叛等问题进行了深刻思考。</p><h3 id="与现实的联系：-3"><a href="#与现实的联系：-3" class="headerlink" title="与现实的联系："></a>与现实的联系：</h3><p>《三国演义》中塑造的人物形象和情节在现实中有着深远的影响。故事中展现的权谋斗争、战争冲突等主题在现实社会中依然存在。人们对于权力、利益的追逐和争夺是人性中普遍存在的弱点。小说对权力、利益、忠诚等问题的探讨，引发了读者对现实社会的思考和反思。</p><p>同时，《三国演义》中英雄形象所表现的忠诚、勇气、智慧等品质也与现实中的人性存在共通之处。现实社会中仍然有人们追求正义、维护和平的行为，这些行为与小说中英雄形象所展现的特质不谋而合。</p><p>总的来说，《三国演义》以其壮阔的历史背景和丰富的人物群像，在现实中依然具有重要的意义。小说通过对权谋斗争和人性复杂性的描写，引发了读者对权力、道德和人性的思考。它不仅是一部具有历史价值的文学作品，也是一面反映现实社会中人性困境和价值观的镜子。</p>]]></content>
      
      
      <categories>
          
          <category> literature </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读后感 </tag>
            
            <tag> 经典百书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Analysis of classic algorithm problems of linked list</title>
      <link href="/2023/08/10/xiao-second-blog/"/>
      <url>/2023/08/10/xiao-second-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="链表经典算法题解析"><a href="#链表经典算法题解析" class="headerlink" title="链表经典算法题解析"></a>链表经典算法题解析</h1><p>链表是常用的数据结构之一，它由一系列节点组成，每个节点包含两个部分：数据和指向下一个节点的指针。在编程中，常常需要处理链表相关的问题，例如复制链表、找到环的入口节点、合并链表等。本文将对几个经典的链表算法题进行详细解析，并使用C++编程语言来实现（本文只提供Hard、Middle难度题的代码实现）。</p><h2 id="第一题：JZ35-复杂链表的复制（Hard）"><a href="#第一题：JZ35-复杂链表的复制（Hard）" class="headerlink" title="第一题：JZ35 复杂链表的复制（Hard）"></a>第一题：JZ35 复杂链表的复制（Hard）</h2><h3 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h3><p>算法首先检查链表是否为空，如果是空链表，则直接返回。</p><p>接下来，算法遍历原始链表，并进行拷贝操作。对于每个原始节点 <code>cur</code>，都创建一个新节点 <code>clone</code>，其值为原始节点的值。然后将新节点 <code>clone</code> 插入到原始节点 <code>cur</code> 后面。这样，新的链表中的节点就是原始链表的节点的拷贝。</p><p>接着，算法再次遍历链表，连接新链表的 <code>random</code> 节点。根据原始链表中的 <code>random</code> 指针，我们可以找到对应节点的拷贝节点的位置，然后将其赋给新链表节点的 <code>random</code> 指针。</p><p>最后，算法再次遍历链表，拆分原始链表和新链表。对于每个节点，我们将原始链表中的节点的 <code>next</code> 指针指向下一个原始节点，将新链表中的节点的 <code>next</code> 指针指向下一个新节点。</p><p>最终，算法返回复制后的链表的头指针。</p><p>该算法的时间复杂度为 O(n)，其中 n 是链表的长度。需要遍历链表三次，每次遍历都需要线性时间。</p><p>空间复杂度为 O(1)，即常数空间。除了复制出的新节点和一些指针变量外，没有使用额外的空间。</p><p>以下是用C++实现的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node* next;</span><br><span class="line">    Node* random;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>), <span class="built_in">random</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建拷贝节点并插入到原始节点后面</span></span><br><span class="line">    Node* cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        Node* clone = <span class="keyword">new</span> <span class="built_in">Node</span>(cur-&gt;val);</span><br><span class="line">        clone-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = clone;</span><br><span class="line">        cur = clone-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 连接拷贝节点的random指针</span></span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;random != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拆分原始链表和新链表</span></span><br><span class="line">    cur = head;</span><br><span class="line">    Node* cloneHead = head-&gt;next;</span><br><span class="line">    Node* cloneCur = cloneHead;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (cloneCur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cloneCur-&gt;next = cloneCur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        cloneCur = cloneCur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cloneHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printLinkedList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        cout &lt;&lt; head-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;random != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; head-&gt;random-&gt;val &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;null&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建测试链表</span></span><br><span class="line">    Node* node1 = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">1</span>);</span><br><span class="line">    Node* node2 = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">2</span>);</span><br><span class="line">    Node* node3 = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">3</span>);</span><br><span class="line">    Node* node4 = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">4</span>);</span><br><span class="line">    Node* node5 = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    node1-&gt;next = node2;</span><br><span class="line">    node2-&gt;next = node3;</span><br><span class="line">    node3-&gt;next = node4;</span><br><span class="line">    node4-&gt;next = node5;</span><br><span class="line">    </span><br><span class="line">    node1-&gt;random = node3;</span><br><span class="line">    node2-&gt;random = node4;</span><br><span class="line">    node4-&gt;random = node2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制链表</span></span><br><span class="line">    Node* cloneHead = <span class="built_in">copyRandomList</span>(node1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出原始链表和复制链表</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Original Linked List: &quot;</span>;</span><br><span class="line">    <span class="built_in">printLinkedList</span>(node1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Cloned Linked List: &quot;</span>;</span><br><span class="line">    <span class="built_in">printLinkedList</span>(cloneHead);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    Node* cur = node1;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        Node* temp = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cur = cloneHead;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        Node* temp = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上代码，将会输出以下结果：</p><p>Original Linked List: 1(3) -&gt; 2(4) -&gt; 3 -&gt; 4(2) -&gt; 5(null)<br>Cloned Linked List: 1(3) -&gt; 2(4) -&gt; 3 -&gt; 4(2) -&gt; 5(null)</p><p>请注意，为了方便起见，我在输出链表节点的值后面用括号表示了 <code>random</code> 指针指向的节点的值。</p><h2 id="第二题：JZ23-链表中环的入口结点-Middle"><a href="#第二题：JZ23-链表中环的入口结点-Middle" class="headerlink" title="第二题：JZ23 链表中环的入口结点(Middle)"></a>第二题：JZ23 链表中环的入口结点(Middle)</h2><h3 id="解析：-1"><a href="#解析：-1" class="headerlink" title="解析："></a>解析：</h3><p>算法使用快慢指针技巧来判断链表中是否存在环，并找到环的入口节点。</p><p>首先，我们定义两个指针 fast 和 slow，初始时都指向链表的头节点 pHead。</p><p>接下来，我们使用一个循环来判断是否存在环。在循环中，慢指针 slow 每次向后移动一步，快指针 fast 每次向后移动两步。</p><p>如果存在环，那么快指针 fast 最终会追上慢指针 slow，它们会在环中的某个位置相遇。</p><p>一旦相遇，我们将快指针 fast 移回链表头节点 pHead，然后使用两个指针同时向后移动一步，直到它们再次相遇。这时，它们相遇的位置就是环的入口节点。</p><p>最后，我们返回找到的入口节点。</p><p>该算法的时间复杂度为 O(n)，其中 n 是链表的长度。在最坏情况下，快指针需要遍历整个链表才能找到环。</p><p>空间复杂度为 O(1)，即常数空间。只使用了两个额外的指针来标记快慢指针的位置。</p><p>以下是使用C++实现的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">detectCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否存在环，并找到相遇点</span></span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    <span class="type">bool</span> hasCycle = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            hasCycle = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果不存在环，直接返回nullptr</span></span><br><span class="line">    <span class="keyword">if</span> (!hasCycle) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将快指针移回头节点，并与慢指针同时向后移动，直到它们再次相遇</span></span><br><span class="line">    fast = head;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建测试链表</span></span><br><span class="line">    ListNode* node1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">    ListNode* node2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">    ListNode* node3 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">    ListNode* node4 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">    ListNode* node5 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);</span><br><span class="line">    ListNode* node6 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line">    node1-&gt;next = node2;</span><br><span class="line">    node2-&gt;next = node3;</span><br><span class="line">    node3-&gt;next = node4;</span><br><span class="line">    node4-&gt;next = node5;</span><br><span class="line">    node5-&gt;next = node6;</span><br><span class="line">    node6-&gt;next = node3;  <span class="comment">// 创建环，连接node6和node3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检测环的入口节点</span></span><br><span class="line">    ListNode* entryNode = <span class="built_in">detectCycle</span>(node1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">if</span> (entryNode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The linked list doesn&#x27;t have a cycle.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The entry node of the cycle is &quot;</span> &lt;&lt; entryNode-&gt;val &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    ListNode* cur = node1;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode* temp = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上代码，将会输出以下结果：</p><p>The entry node of the cycle is 3.</p><p>请注意，由于链表中存在环，所以我们输出了环的入口节点的值。如果链表中不存在环，则输出 “The linked list doesn’t have a cycle.”。</p><h2 id="第三题：JZ52-两个链表的第一个公共结点-Easy"><a href="#第三题：JZ52-两个链表的第一个公共结点-Easy" class="headerlink" title="第三题：JZ52 两个链表的第一个公共结点(Easy)"></a>第三题：JZ52 两个链表的第一个公共结点(Easy)</h2><h3 id="解析：-2"><a href="#解析：-2" class="headerlink" title="解析："></a>解析：</h3><p>首先，我们检查输入的链表是否为空，如果有一个为空，则直接返回 nullptr。</p><p>然后，我们创建两个指针 ta和 tb，并分别指向两个链表的头节点。</p><p>接下来，我们进入循环，判断 ta 和 tb 是否相等，如果相等，则说明找到了第一个公共节点，直接返回该节点。</p><p>如果 ta 不为空，则将 ta 移动到下一个节点；如果为空，则将 ta 指向 pHead2，继续遍历。</p><p>同样地，如果 tb 不为空，则将 tb 移动到下一个节点；如果为空，则将 tb 指向 pHead1，继续遍历。</p><p>循环会一直进行，直到找到第一个公共节点或者两个链表都遍历完。</p><p>最后，我们返回第一个公共节点的指针（可能为 nullptr）。</p><h2 id="第四题：JZ24-反转链表（Easy）"><a href="#第四题：JZ24-反转链表（Easy）" class="headerlink" title="第四题：JZ24 反转链表（Easy）"></a>第四题：JZ24 反转链表（Easy）</h2><h3 id="解析：-3"><a href="#解析：-3" class="headerlink" title="解析："></a>解析：</h3><p>函数的参数是一个指向链表头节点的指针 head，我们首先检查 head 是否为空，如果为空，则直接返回 nullptr 表示空链表。</p><p>接下来，我们创建一个 std::stack 对象 stack 来保存需要反转的链表节点。通过遍历原始链表，我们将每个节点依次入栈。</p><p>如果栈为空，说明原始链表没有节点，直接返回 nullptr。否则，我们取出栈顶节点并将其赋值给 node 和 dummy。然后，我们从栈中移除该节点。</p><p>接下来，我们从栈中依次取出节点，并将其连接成一个新的链表。我们使用 tempNode 临时存储每次从栈中取出的节点，并通过 node 将它们连接起来。</p><p>最后，我们需要将最后一个节点的 next 指针设置为 nullptr，以避免形成环。然后，我们返回 dummy 节点作为反转后的链表的新头节点。</p><h2 id="第五题：JZ6-从尾到头打印链表-Easy"><a href="#第五题：JZ6-从尾到头打印链表-Easy" class="headerlink" title="第五题：JZ6 从尾到头打印链表(Easy)"></a>第五题：JZ6 从尾到头打印链表(Easy)</h2><h3 id="解析：-4"><a href="#解析：-4" class="headerlink" title="解析："></a>解析：</h3><p>函数首先创建了一个空的 vector<int> 类型的结果向量 res 和一个空的 stack<int> 类型的栈 s。</p><p>接下来，函数通过遍历链表将链表中的节点值从头到尾依次压入栈中。</p><p>然后，函数通过循环将栈中的元素依次弹出，同时将弹出的元素添加到结果向量中。</p><p>最后，函数返回结果向量 res，其中存储了链表从尾到头的节点值。</p><h2 id="第六题：JZ25-合并两个排序的链表-Easy"><a href="#第六题：JZ25-合并两个排序的链表-Easy" class="headerlink" title="第六题：JZ25 合并两个排序的链表(Easy)"></a>第六题：JZ25 合并两个排序的链表(Easy)</h2><h3 id="解析：-5"><a href="#解析：-5" class="headerlink" title="解析："></a>解析：</h3><p>首先，我们进行空指针判断。如果其中一个链表为空，则直接返回另一个链表的头指针。</p><p>然后，我们创建一个新的链表头节点 <code>head</code> 和一个指向当前节点的指针 <code>cur</code>，初始时它们都指向一个值为 0 的节点。</p><p>接下来，我们使用循环来遍历两个链表，比较节点的值大小，将较小的节点接入新的链表中，同时更新指针的位置。</p><p>最后，我们检查是否有链表还有剩余节点，如果有，则将剩余节点接入新的链表的尾部。</p><p>最后，我们返回 <code>head-&gt;next</code>，即合并后的有序链表的头指针。</p><h2 id="第七题：JZ22-链表中倒数最后k个结点-Easy"><a href="#第七题：JZ22-链表中倒数最后k个结点-Easy" class="headerlink" title="第七题：JZ22 链表中倒数最后k个结点(Easy)"></a>第七题：JZ22 链表中倒数最后k个结点(Easy)</h2><h3 id="解析：-6"><a href="#解析：-6" class="headerlink" title="解析："></a>解析：</h3><p>首先，我们定义两个指针 fast 和 slow，初始时都指向链表的头节点 pHead。</p><p>然后，我们让快指针 fast 先行 k 步。在每一步循环中，我们检查 fast 是否为 nullptr，如果不是，则将 fast 指针向后移动一个节点，表示快指针先行 k 步。如果 fast 为 nullptr，说明链表的长度不足 k，直接返回 nullptr。</p><p>接下来，我们同时移动快指针 fast 和慢指针 slow，直到快指针 fast 到达链表的末尾（即 fast 为 nullptr）。在每一步循环中，我们先将 fast 指针向后移动一个节点，然后再将 slow 指针向后移动一个节点。最终，当快指针 fast 到达链表末尾时，慢指针 slow 就指向了倒数第 k 个节点。</p><p>最后，我们返回慢指针 slow 所指向的节点作为结果。</p><h2 id="第八题：JZ76-删除链表中重复的结点-Middle"><a href="#第八题：JZ76-删除链表中重复的结点-Middle" class="headerlink" title="第八题：JZ76 删除链表中重复的结点(Middle)"></a>第八题：JZ76 删除链表中重复的结点(Middle)</h2><h3 id="解析：-7"><a href="#解析：-7" class="headerlink" title="解析："></a>解析：</h3><p>首先，我们创建一个哨兵节点 res，并将其 next 指针指向原始的链表头节点 pHead，以便在删除操作时可以处理头节点的情况。</p><p>然后，我们定义一个指针 cur，初始时指向哨兵节点 res。</p><p>接下来，我们使用 cur 指针遍历链表，查找重复节点。如果当前节点的值和下一个节点的值相同，说明遇到了重复节点。我们使用一个临时变量 temp 来保存重复节点的值，并通过循环将所有相同的节点跳过。</p><p>如果当前节点和下一个节点的值不相同，说明没有遇到重复节点，我们将 cur 指针向后移动一位。</p><p>最后，我们返回去掉哨兵节点的链表，即返回哨兵节点的 next 指针。</p><p>这段代码的时间复杂度为 O(n)，其中 n 是链表的长度。因为我们需要遍历整个链表来删除重复节点。</p><p>空间复杂度为 O(1)，即常数空间。虽然创建了一个哨兵节点，但它不随输入链表的长度而变化，并且在返回结果时并没有将其计入空间占用。</p><p>以下是使用C++实现的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="literal">nullptr</span> || pHead-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode* res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);  <span class="comment">// 哨兵节点</span></span><br><span class="line">    res-&gt;next = pHead;</span><br><span class="line">    </span><br><span class="line">    ListNode* cur = res;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;next-&gt;val == cur-&gt;next-&gt;next-&gt;val) &#123;</span><br><span class="line">            <span class="type">int</span> temp = cur-&gt;next-&gt;val;</span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;val == temp) &#123;</span><br><span class="line">                ListNode* delNode = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> delNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode* result = res-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        cout &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ListNode* node1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">    ListNode* node2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">    ListNode* node3 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">    ListNode* node4 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">    ListNode* node5 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">    ListNode* node6 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">    ListNode* node7 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    node1-&gt;next = node2;</span><br><span class="line">    node2-&gt;next = node3;</span><br><span class="line">    node3-&gt;next = node4;</span><br><span class="line">    node4-&gt;next = node5;</span><br><span class="line">    node5-&gt;next = node6;</span><br><span class="line">    node6-&gt;next = node7;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Original List: &quot;</span>;</span><br><span class="line">    <span class="built_in">printList</span>(node1);</span><br><span class="line">    </span><br><span class="line">    ListNode* result = <span class="built_in">deleteDuplication</span>(node1);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After Deletion: &quot;</span>;</span><br><span class="line">    <span class="built_in">printList</span>(result);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    ListNode* cur = result;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode* temp = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上代码，将会输出以下结果：</p><p>Original List: 1 2 3 3 4 4 5<br>After Deletion: 1 2 5 </p><p>请注意，原始链表中有重复的节点 3 和 4，在删除重复节点后，我们得到的链表为 1 2 5。</p><h2 id="第九题：JZ18-删除链表的节点-Easy"><a href="#第九题：JZ18-删除链表的节点-Easy" class="headerlink" title="第九题：JZ18 删除链表的节点(Easy)"></a>第九题：JZ18 删除链表的节点(Easy)</h2><h3 id="解析：-8"><a href="#解析：-8" class="headerlink" title="解析："></a>解析：</h3><p>首先，我们创建一个哨兵节点 res，并将其 next 指针指向原始的链表头节点 head，以便在删除操作时可以处理头节点的情况。</p><p>然后，我们定义两个指针 pre 和 cur，初始时分别指向哨兵节点 res 和链表头节点 head。</p><p>接下来，我们使用 cur 指针遍历链表，查找目标节点。如果当前节点的值等于目标值 val，则将前序节点 pre 的 next 指针指向当前节点的下一个节点，即删除目标节点。然后，我们使用 break 语句跳出循环。</p><p>最后，我们返回去掉哨兵节点的链表，即返回哨兵节点的 next 指针。</p><p>这段代码的时间复杂度为 O(n)，其中 n 是链表的长度。因为我们需要遍历整个链表来查找目标节点。</p><p>空间复杂度为 O(1)，即常数空间。虽然创建了一个哨兵节点，但它不随输入链表的长度而变化，并且在返回结果时并没有将其计入空间占用。</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《剃须。然后捡到女高中生》观后有感</title>
      <link href="/2022/10/20/Review%20of%20Shaving/"/>
      <url>/2022/10/20/Review%20of%20Shaving/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=2069668052&auto=1&height=66"></iframe><h2 id="剧情介绍"><a href="#剧情介绍" class="headerlink" title="剧情介绍"></a>剧情介绍</h2><p>《剃须。然后捡到女高中生》是一部令人深思的动画作品，以其复杂而又严肃的剧情展示了主人公沙优在困境中的成长与救赎的故事。这部作品通过探讨人性、友情和爱的力量，引发观众对社会议题如家庭问题、校园暴力和个人心理困境等的思考。</p><p>故事一开始，我们见识到了主人公沙优的不幸遭遇。她的父亲出轨导致家庭破裂，母亲为了挽回丈夫的爱，选择怀孕并生下了沙优。然而，这样做并没有改变事实，沙优的母亲仍然无法获得她所渴望的完整家庭和幸福。沙优从小就受到母亲的冷漠对待，她感到自己毫无存在感，缺乏面对生活的动力，甚至在学校里也没有朋友。</p><p>然而，一切都发生了改变。沙优遇到了一个真正的朋友，一个陪伴她度过黑暗时光的好闺蜜。然而，由于校园暴力的压力，好闺蜜最终选择了自杀。这个悲剧深深地打击了沙优，让她感到自责和痛苦。更加令人痛心的是，她的母亲对此事反应冷漠，甚至怀疑沙优可能是好闺蜜自杀的凶手。这个事件引发了沙优对母亲的愤怒和厌恶，她决定离开家寻找新的生活。</p><p>在这个过程中，沙优遇到了吉田，一个善良而坚定的人。吉田并没有对沙优有任何不良企图，他只是愿意帮助沙优重新审视自己的处境，并给她力量重新开始。通过吉田和他的同事们的帮助，沙优逐渐摆脱困境，重建了自己的生活。这个过程并非一帆风顺，沙优曾经走上错误道路，出卖自己的身体以谋取生活所需。然而，她最终通过吉田的引导和支持，找回了自尊和勇气，重新投身于正常的生活。</p><p><img src="http://s0ihpsfaf.hn-bkt.clouddn.com/eye.jpg"></p><h2 id="观后有感"><a href="#观后有感" class="headerlink" title="观后有感"></a>观后有感</h2><p>《剃须。然后捡到女高中生》这部动画作品深入探讨了社会中存在的一系列问题，并引发了观众对更深层次议题的思考。</p><p>首先，家庭破裂是这部作品中一个重要的主题。沙优来自一个破碎的家庭，她的母亲选择怀孕来填补家庭的空虚，却并未解决问题。这一情节引发了观众对家庭价值观、亲情关系和家庭责任的思考。作品中通过沙优与她的家人之间的交流和矛盾，展现了家庭关系对个体成长的重要性以及家庭矛盾背后隐藏的心理压力。</p><p>其次，校园暴力是另一个重要的议题。作品中描绘了沙优在学校中遭受的欺凌和暴力行为，她面临着身体和心理上的伤害。这激发了观众对校园暴力现象的反思，以及对学校和社会应如何处理这一问题的思考。同时，作品也通过描绘沙优与其他同学的互动，探索了友谊、团结和支持对于个体自我认同和生活质量的重要性。</p><p>此外，人际关系的脆弱性也是这部作品的一个重要主题。在故事中，沙优与一个真正的朋友建立了联系，然而这段关系却因意外而突然终结。这让观众对友谊的定义和友谊的稳固性产生思考，以及对于在现实世界中面临困境时如何建立和维护健康的人际关系的探索。</p><p>这些议题都提醒观众们去反思现实社会中存在的问题，并激发他们思考应对这些问题的方法。在故事中，吉田作为一个支持者和引导者的角色，教会了沙优如何勇敢地面对现实，并逐渐找到自己的力量。这也呼应了现实世界中的挑战，鼓励观众不畏困难，积极应对生活中的问题，寻求正确的解决方案。</p><p>除了以上的主题，这部作品还通过角色的内心独白、情感细节和表情动作等元素，深入探索了人性的复杂性和心理层面的挣扎。观众们可以从中思考人的内心世界、情绪管理和自我成长的重要性。此外，作品中的意象和隐喻也为观众提供了丰富的思考空间，让他们思索生命的意义、幸福的追求以及个体在社会中的角色。</p><p>总而言之，《剃须。然后捡到女高中生》通过深入探讨家庭、校园、人际关系等议题，引发观众对于现实社会的思考和反思。通过描绘一个受伤和孤立的年轻女孩，以及她在困境中寻求救赎和重生的旅程，展示主人公的成长和救赎，作品鼓励观众积极面对挑战、追求真理和成长，并思考个体与社会、内心与现实之间的关系。通过这些思考，观众可以更加深入地理解人性和社会，从而在现实生活中作出积极的改变和选择。</p><p>沙优的成长之路充满了挑战和痛苦，但最终她通过勇气和坚持走出了阴影。这种积极的主题激励着我们，让我们相信即使面临困境，也存在希望和改变的可能。</p><p><img src="http://s0ihpsfaf.hn-bkt.clouddn.com/cupgirl.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Thoughts after viewing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 观后感 </tag>
            
            <tag> 影评 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
