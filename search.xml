<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>全网最细！————Analysis of classic algorithm problems of linked list</title>
      <link href="/2023/08/10/xiao-second-blog/"/>
      <url>/2023/08/10/xiao-second-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="链表经典算法题解析"><a href="#链表经典算法题解析" class="headerlink" title="链表经典算法题解析"></a>链表经典算法题解析</h1><p>链表是常用的数据结构之一，它由一系列节点组成，每个节点包含两个部分：数据和指向下一个节点的指针。在编程中，常常需要处理链表相关的问题，例如复制链表、找到环的入口节点、合并链表等。本文将对几个经典的链表算法题进行详细解析，并使用C++编程语言来实现（本文只提供Hard、Middle难度题的代码实现）。</p><h2 id="第一题：JZ35-复杂链表的复制（Hard）"><a href="#第一题：JZ35-复杂链表的复制（Hard）" class="headerlink" title="第一题：JZ35 复杂链表的复制（Hard）"></a>第一题：JZ35 复杂链表的复制（Hard）</h2><h3 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h3><p>算法首先检查链表是否为空，如果是空链表，则直接返回。</p><p>接下来，算法遍历原始链表，并进行拷贝操作。对于每个原始节点 <code>cur</code>，都创建一个新节点 <code>clone</code>，其值为原始节点的值。然后将新节点 <code>clone</code> 插入到原始节点 <code>cur</code> 后面。这样，新的链表中的节点就是原始链表的节点的拷贝。</p><p>接着，算法再次遍历链表，连接新链表的 <code>random</code> 节点。根据原始链表中的 <code>random</code> 指针，我们可以找到对应节点的拷贝节点的位置，然后将其赋给新链表节点的 <code>random</code> 指针。</p><p>最后，算法再次遍历链表，拆分原始链表和新链表。对于每个节点，我们将原始链表中的节点的 <code>next</code> 指针指向下一个原始节点，将新链表中的节点的 <code>next</code> 指针指向下一个新节点。</p><p>最终，算法返回复制后的链表的头指针。</p><p>该算法的时间复杂度为 O(n)，其中 n 是链表的长度。需要遍历链表三次，每次遍历都需要线性时间。</p><p>空间复杂度为 O(1)，即常数空间。除了复制出的新节点和一些指针变量外，没有使用额外的空间。</p><p>以下是用C++实现的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node* next;</span><br><span class="line">    Node* random;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>), <span class="built_in">random</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建拷贝节点并插入到原始节点后面</span></span><br><span class="line">    Node* cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        Node* clone = <span class="keyword">new</span> <span class="built_in">Node</span>(cur-&gt;val);</span><br><span class="line">        clone-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = clone;</span><br><span class="line">        cur = clone-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 连接拷贝节点的random指针</span></span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;random != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拆分原始链表和新链表</span></span><br><span class="line">    cur = head;</span><br><span class="line">    Node* cloneHead = head-&gt;next;</span><br><span class="line">    Node* cloneCur = cloneHead;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (cloneCur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cloneCur-&gt;next = cloneCur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        cloneCur = cloneCur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cloneHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printLinkedList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        cout &lt;&lt; head-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;random != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; head-&gt;random-&gt;val &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;null&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建测试链表</span></span><br><span class="line">    Node* node1 = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">1</span>);</span><br><span class="line">    Node* node2 = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">2</span>);</span><br><span class="line">    Node* node3 = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">3</span>);</span><br><span class="line">    Node* node4 = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">4</span>);</span><br><span class="line">    Node* node5 = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    node1-&gt;next = node2;</span><br><span class="line">    node2-&gt;next = node3;</span><br><span class="line">    node3-&gt;next = node4;</span><br><span class="line">    node4-&gt;next = node5;</span><br><span class="line">    </span><br><span class="line">    node1-&gt;random = node3;</span><br><span class="line">    node2-&gt;random = node4;</span><br><span class="line">    node4-&gt;random = node2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制链表</span></span><br><span class="line">    Node* cloneHead = <span class="built_in">copyRandomList</span>(node1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出原始链表和复制链表</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Original Linked List: &quot;</span>;</span><br><span class="line">    <span class="built_in">printLinkedList</span>(node1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Cloned Linked List: &quot;</span>;</span><br><span class="line">    <span class="built_in">printLinkedList</span>(cloneHead);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    Node* cur = node1;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        Node* temp = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cur = cloneHead;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        Node* temp = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上代码，将会输出以下结果：</p><p>Original Linked List: 1(3) -&gt; 2(4) -&gt; 3 -&gt; 4(2) -&gt; 5(null)<br>Cloned Linked List: 1(3) -&gt; 2(4) -&gt; 3 -&gt; 4(2) -&gt; 5(null)</p><p>请注意，为了方便起见，我在输出链表节点的值后面用括号表示了 <code>random</code> 指针指向的节点的值。</p><h2 id="第二题：JZ23-链表中环的入口结点-Middle"><a href="#第二题：JZ23-链表中环的入口结点-Middle" class="headerlink" title="第二题：JZ23 链表中环的入口结点(Middle)"></a>第二题：JZ23 链表中环的入口结点(Middle)</h2><h3 id="解析：-1"><a href="#解析：-1" class="headerlink" title="解析："></a>解析：</h3><p>算法使用快慢指针技巧来判断链表中是否存在环，并找到环的入口节点。</p><p>首先，我们定义两个指针 fast 和 slow，初始时都指向链表的头节点 pHead。</p><p>接下来，我们使用一个循环来判断是否存在环。在循环中，慢指针 slow 每次向后移动一步，快指针 fast 每次向后移动两步。</p><p>如果存在环，那么快指针 fast 最终会追上慢指针 slow，它们会在环中的某个位置相遇。</p><p>一旦相遇，我们将快指针 fast 移回链表头节点 pHead，然后使用两个指针同时向后移动一步，直到它们再次相遇。这时，它们相遇的位置就是环的入口节点。</p><p>最后，我们返回找到的入口节点。</p><p>该算法的时间复杂度为 O(n)，其中 n 是链表的长度。在最坏情况下，快指针需要遍历整个链表才能找到环。</p><p>空间复杂度为 O(1)，即常数空间。只使用了两个额外的指针来标记快慢指针的位置。</p><p>以下是使用C++实现的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">detectCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否存在环，并找到相遇点</span></span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    <span class="type">bool</span> hasCycle = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            hasCycle = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果不存在环，直接返回nullptr</span></span><br><span class="line">    <span class="keyword">if</span> (!hasCycle) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将快指针移回头节点，并与慢指针同时向后移动，直到它们再次相遇</span></span><br><span class="line">    fast = head;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建测试链表</span></span><br><span class="line">    ListNode* node1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">    ListNode* node2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">    ListNode* node3 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">    ListNode* node4 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">    ListNode* node5 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);</span><br><span class="line">    ListNode* node6 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line">    node1-&gt;next = node2;</span><br><span class="line">    node2-&gt;next = node3;</span><br><span class="line">    node3-&gt;next = node4;</span><br><span class="line">    node4-&gt;next = node5;</span><br><span class="line">    node5-&gt;next = node6;</span><br><span class="line">    node6-&gt;next = node3;  <span class="comment">// 创建环，连接node6和node3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检测环的入口节点</span></span><br><span class="line">    ListNode* entryNode = <span class="built_in">detectCycle</span>(node1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">if</span> (entryNode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The linked list doesn&#x27;t have a cycle.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The entry node of the cycle is &quot;</span> &lt;&lt; entryNode-&gt;val &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    ListNode* cur = node1;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode* temp = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上代码，将会输出以下结果：</p><p>The entry node of the cycle is 3.</p><p>请注意，由于链表中存在环，所以我们输出了环的入口节点的值。如果链表中不存在环，则输出 “The linked list doesn’t have a cycle.”。</p><h2 id="第三题：JZ52-两个链表的第一个公共结点-Easy"><a href="#第三题：JZ52-两个链表的第一个公共结点-Easy" class="headerlink" title="第三题：JZ52 两个链表的第一个公共结点(Easy)"></a>第三题：JZ52 两个链表的第一个公共结点(Easy)</h2><h3 id="解析：-2"><a href="#解析：-2" class="headerlink" title="解析："></a>解析：</h3><p>首先，我们检查输入的链表是否为空，如果有一个为空，则直接返回 nullptr。</p><p>然后，我们创建两个指针 ta和 tb，并分别指向两个链表的头节点。</p><p>接下来，我们进入循环，判断 ta 和 tb 是否相等，如果相等，则说明找到了第一个公共节点，直接返回该节点。</p><p>如果 ta 不为空，则将 ta 移动到下一个节点；如果为空，则将 ta 指向 pHead2，继续遍历。</p><p>同样地，如果 tb 不为空，则将 tb 移动到下一个节点；如果为空，则将 tb 指向 pHead1，继续遍历。</p><p>循环会一直进行，直到找到第一个公共节点或者两个链表都遍历完。</p><p>最后，我们返回第一个公共节点的指针（可能为 nullptr）。</p><h2 id="第四题：JZ24-反转链表（Easy）"><a href="#第四题：JZ24-反转链表（Easy）" class="headerlink" title="第四题：JZ24 反转链表（Easy）"></a>第四题：JZ24 反转链表（Easy）</h2><h3 id="解析：-3"><a href="#解析：-3" class="headerlink" title="解析："></a>解析：</h3><p>函数的参数是一个指向链表头节点的指针 head，我们首先检查 head 是否为空，如果为空，则直接返回 nullptr 表示空链表。</p><p>接下来，我们创建一个 std::stack 对象 stack 来保存需要反转的链表节点。通过遍历原始链表，我们将每个节点依次入栈。</p><p>如果栈为空，说明原始链表没有节点，直接返回 nullptr。否则，我们取出栈顶节点并将其赋值给 node 和 dummy。然后，我们从栈中移除该节点。</p><p>接下来，我们从栈中依次取出节点，并将其连接成一个新的链表。我们使用 tempNode 临时存储每次从栈中取出的节点，并通过 node 将它们连接起来。</p><p>最后，我们需要将最后一个节点的 next 指针设置为 nullptr，以避免形成环。然后，我们返回 dummy 节点作为反转后的链表的新头节点。</p><h2 id="第五题：JZ6-从尾到头打印链表-Easy"><a href="#第五题：JZ6-从尾到头打印链表-Easy" class="headerlink" title="第五题：JZ6 从尾到头打印链表(Easy)"></a>第五题：JZ6 从尾到头打印链表(Easy)</h2><h3 id="解析：-4"><a href="#解析：-4" class="headerlink" title="解析："></a>解析：</h3><p>函数首先创建了一个空的 vector<int> 类型的结果向量 res 和一个空的 stack<int> 类型的栈 s。</p><p>接下来，函数通过遍历链表将链表中的节点值从头到尾依次压入栈中。</p><p>然后，函数通过循环将栈中的元素依次弹出，同时将弹出的元素添加到结果向量中。</p><p>最后，函数返回结果向量 res，其中存储了链表从尾到头的节点值。</p><h2 id="第六题：JZ25-合并两个排序的链表-Easy"><a href="#第六题：JZ25-合并两个排序的链表-Easy" class="headerlink" title="第六题：JZ25 合并两个排序的链表(Easy)"></a>第六题：JZ25 合并两个排序的链表(Easy)</h2><h3 id="解析：-5"><a href="#解析：-5" class="headerlink" title="解析："></a>解析：</h3><p>首先，我们进行空指针判断。如果其中一个链表为空，则直接返回另一个链表的头指针。</p><p>然后，我们创建一个新的链表头节点 <code>head</code> 和一个指向当前节点的指针 <code>cur</code>，初始时它们都指向一个值为 0 的节点。</p><p>接下来，我们使用循环来遍历两个链表，比较节点的值大小，将较小的节点接入新的链表中，同时更新指针的位置。</p><p>最后，我们检查是否有链表还有剩余节点，如果有，则将剩余节点接入新的链表的尾部。</p><p>最后，我们返回 <code>head-&gt;next</code>，即合并后的有序链表的头指针。</p><h2 id="第七题：JZ22-链表中倒数最后k个结点-Easy"><a href="#第七题：JZ22-链表中倒数最后k个结点-Easy" class="headerlink" title="第七题：JZ22 链表中倒数最后k个结点(Easy)"></a>第七题：JZ22 链表中倒数最后k个结点(Easy)</h2><h3 id="解析：-6"><a href="#解析：-6" class="headerlink" title="解析："></a>解析：</h3><p>首先，我们定义两个指针 fast 和 slow，初始时都指向链表的头节点 pHead。</p><p>然后，我们让快指针 fast 先行 k 步。在每一步循环中，我们检查 fast 是否为 nullptr，如果不是，则将 fast 指针向后移动一个节点，表示快指针先行 k 步。如果 fast 为 nullptr，说明链表的长度不足 k，直接返回 nullptr。</p><p>接下来，我们同时移动快指针 fast 和慢指针 slow，直到快指针 fast 到达链表的末尾（即 fast 为 nullptr）。在每一步循环中，我们先将 fast 指针向后移动一个节点，然后再将 slow 指针向后移动一个节点。最终，当快指针 fast 到达链表末尾时，慢指针 slow 就指向了倒数第 k 个节点。</p><p>最后，我们返回慢指针 slow 所指向的节点作为结果。</p><h2 id="第八题：JZ76-删除链表中重复的结点-Middle"><a href="#第八题：JZ76-删除链表中重复的结点-Middle" class="headerlink" title="第八题：JZ76 删除链表中重复的结点(Middle)"></a>第八题：JZ76 删除链表中重复的结点(Middle)</h2><h3 id="解析：-7"><a href="#解析：-7" class="headerlink" title="解析："></a>解析：</h3><p>首先，我们创建一个哨兵节点 res，并将其 next 指针指向原始的链表头节点 pHead，以便在删除操作时可以处理头节点的情况。</p><p>然后，我们定义一个指针 cur，初始时指向哨兵节点 res。</p><p>接下来，我们使用 cur 指针遍历链表，查找重复节点。如果当前节点的值和下一个节点的值相同，说明遇到了重复节点。我们使用一个临时变量 temp 来保存重复节点的值，并通过循环将所有相同的节点跳过。</p><p>如果当前节点和下一个节点的值不相同，说明没有遇到重复节点，我们将 cur 指针向后移动一位。</p><p>最后，我们返回去掉哨兵节点的链表，即返回哨兵节点的 next 指针。</p><p>这段代码的时间复杂度为 O(n)，其中 n 是链表的长度。因为我们需要遍历整个链表来删除重复节点。</p><p>空间复杂度为 O(1)，即常数空间。虽然创建了一个哨兵节点，但它不随输入链表的长度而变化，并且在返回结果时并没有将其计入空间占用。</p><p>以下是使用C++实现的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="literal">nullptr</span> || pHead-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode* res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);  <span class="comment">// 哨兵节点</span></span><br><span class="line">    res-&gt;next = pHead;</span><br><span class="line">    </span><br><span class="line">    ListNode* cur = res;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;next-&gt;val == cur-&gt;next-&gt;next-&gt;val) &#123;</span><br><span class="line">            <span class="type">int</span> temp = cur-&gt;next-&gt;val;</span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;val == temp) &#123;</span><br><span class="line">                ListNode* delNode = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> delNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode* result = res-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        cout &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ListNode* node1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">    ListNode* node2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">    ListNode* node3 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">    ListNode* node4 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">    ListNode* node5 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">    ListNode* node6 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">    ListNode* node7 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    node1-&gt;next = node2;</span><br><span class="line">    node2-&gt;next = node3;</span><br><span class="line">    node3-&gt;next = node4;</span><br><span class="line">    node4-&gt;next = node5;</span><br><span class="line">    node5-&gt;next = node6;</span><br><span class="line">    node6-&gt;next = node7;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Original List: &quot;</span>;</span><br><span class="line">    <span class="built_in">printList</span>(node1);</span><br><span class="line">    </span><br><span class="line">    ListNode* result = <span class="built_in">deleteDuplication</span>(node1);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After Deletion: &quot;</span>;</span><br><span class="line">    <span class="built_in">printList</span>(result);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    ListNode* cur = result;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode* temp = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上代码，将会输出以下结果：</p><p>Original List: 1 2 3 3 4 4 5<br>After Deletion: 1 2 5 </p><p>请注意，原始链表中有重复的节点 3 和 4，在删除重复节点后，我们得到的链表为 1 2 5。</p><h2 id="第九题：JZ18-删除链表的节点-Easy"><a href="#第九题：JZ18-删除链表的节点-Easy" class="headerlink" title="第九题：JZ18 删除链表的节点(Easy)"></a>第九题：JZ18 删除链表的节点(Easy)</h2><h3 id="解析：-8"><a href="#解析：-8" class="headerlink" title="解析："></a>解析：</h3><p>首先，我们创建一个哨兵节点 res，并将其 next 指针指向原始的链表头节点 head，以便在删除操作时可以处理头节点的情况。</p><p>然后，我们定义两个指针 pre 和 cur，初始时分别指向哨兵节点 res 和链表头节点 head。</p><p>接下来，我们使用 cur 指针遍历链表，查找目标节点。如果当前节点的值等于目标值 val，则将前序节点 pre 的 next 指针指向当前节点的下一个节点，即删除目标节点。然后，我们使用 break 语句跳出循环。</p><p>最后，我们返回去掉哨兵节点的链表，即返回哨兵节点的 next 指针。</p><p>这段代码的时间复杂度为 O(n)，其中 n 是链表的长度。因为我们需要遍历整个链表来查找目标节点。</p><p>空间复杂度为 O(1)，即常数空间。虽然创建了一个哨兵节点，但它不随输入链表的长度而变化，并且在返回结果时并没有将其计入空间占用。</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xiao-first-blog</title>
      <link href="/2023/08/09/xiao-third-blog/"/>
      <url>/2023/08/09/xiao-third-blog/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是小萧~~~</p><p>本文目标：解析剑指offer————链表专栏</p><p>格式采用#题目描述##算法思路###代码编写展开</p><p>序号代表困难等级，1表示困难，2表示中等，3表示简单，比如下面先拿困难题hard里的一道算法题开刀，记1-1</p><p>1-1题目描述：JZ35 复杂链表的复制</p><p>1-2算法思路：<br>【1】算法首先检查链表是否为空，如果是空链表，则直接返回。<br>【2】接下来，算法遍历原始链表，并进行拷贝操作。对于每个原始节点 cur，都创建一个新节点 clone，其值为原始节点的值。然后将新节点 clone 插入到原始节点 cur 后面。这样，新的链表中的节点就是原始链表的节点的拷贝。<br>【3】接着，算法再次遍历链表，连接新链表的 random 节点。根据原始链表中的 random 指针，我们可以找到对应节点的拷贝节点的位置，然后将其赋给新链表节点的 random 指针。<br>【4】最后，算法再次遍历链表，拆分原始链表和新链表。对于每个节点，我们将原始链表中的节点的 next 指针指向下一个原始节点，将新链表中的节点的 next 指针指向下一个新节点。<br>【5】最终，算法返回复制后的链表的头指针。<br>【6】该算法的时间复杂度为 O(n)，其中 n 是链表的长度。需要遍历链表三次，每次遍历都需要线性时间。<br>【7】空间复杂度为 O(1)，即常数空间。除了复制出的新节点和一些指针变量外，没有使用额外的空间。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/04/20/hello-world/"/>
      <url>/2023/04/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
